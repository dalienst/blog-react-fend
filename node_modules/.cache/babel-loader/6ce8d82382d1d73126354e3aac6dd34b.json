{"ast":null,"code":"import { toHex } from \"@aws-sdk/util-hex-encoding\";\n/**\n * A lossless representation of a signed, 64-bit integer. Instances of this\n * class may be used in arithmetic expressions as if they were numeric\n * primitives, but the binary representation will be preserved unchanged as the\n * `bytes` property of the object. The bytes should be encoded as big-endian,\n * two's complement integers.\n */\n\nvar Int64 =\n/** @class */\nfunction () {\n  function Int64(bytes) {\n    this.bytes = bytes;\n\n    if (bytes.byteLength !== 8) {\n      throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n    }\n  }\n\n  Int64.fromNumber = function (number) {\n    if (number > 9223372036854775807 || number < -9223372036854775808) {\n      throw new Error(number + \" is too large (or, if negative, too small) to represent as an Int64\");\n    }\n\n    var bytes = new Uint8Array(8);\n\n    for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n      bytes[i] = remaining;\n    }\n\n    if (number < 0) {\n      negate(bytes);\n    }\n\n    return new Int64(bytes);\n  };\n  /**\n   * Called implicitly by infix arithmetic operators.\n   */\n\n\n  Int64.prototype.valueOf = function () {\n    var bytes = this.bytes.slice(0);\n    var negative = bytes[0] & 128;\n\n    if (negative) {\n      negate(bytes);\n    }\n\n    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n  };\n\n  Int64.prototype.toString = function () {\n    return String(this.valueOf());\n  };\n\n  return Int64;\n}();\n\nexport { Int64 };\n\nfunction negate(bytes) {\n  for (var i = 0; i < 8; i++) {\n    bytes[i] ^= 0xff;\n  }\n\n  for (var i = 7; i > -1; i--) {\n    bytes[i]++;\n    if (bytes[i] !== 0) break;\n  }\n}","map":{"version":3,"mappings":"AACA,SAASA,KAAT,QAAsB,4BAAtB;AAIA;;;;;;;;AAOA;AAAA;AAAA;AACE,iBAAqBC,KAArB,EAAsC;AAAjB;;AACnB,QAAIA,KAAK,CAACC,UAAN,KAAqB,CAAzB,EAA4B;AAC1B,YAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;AAEMC,qBAAP,UAAkBC,MAAlB,EAAgC;AAC9B,QAAIA,MAAM,GAAG,mBAAT,IAAgCA,MAAM,GAAG,CAAC,mBAA9C,EAAmE;AACjE,YAAM,IAAIF,KAAJ,CAAaE,MAAM,wEAAnB,CAAN;AACD;;AAED,QAAMJ,KAAK,GAAG,IAAIK,UAAJ,CAAe,CAAf,CAAd;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,KAAL,CAAWN,MAAX,CAAT,CAA5B,EAA0DE,CAAC,GAAG,CAAC,CAAL,IAAUC,SAAS,GAAG,CAAhF,EAAmFD,CAAC,IAAIC,SAAS,IAAI,GAArG,EAA0G;AACxGP,WAAK,CAACM,CAAD,CAAL,GAAWC,SAAX;AACD;;AAED,QAAIH,MAAM,GAAG,CAAb,EAAgB;AACdO,YAAM,CAACX,KAAD,CAAN;AACD;;AAED,WAAO,IAAIG,KAAJ,CAAUH,KAAV,CAAP;AACD,GAfM;AAiBP;;;;;AAGAG;AACE,QAAMH,KAAK,GAAG,KAAKA,KAAL,CAAWY,KAAX,CAAiB,CAAjB,CAAd;AACA,QAAMC,QAAQ,GAAGb,KAAK,CAAC,CAAD,CAAL,GAAW,GAA5B;;AACA,QAAIa,QAAJ,EAAc;AACZF,YAAM,CAACX,KAAD,CAAN;AACD;;AAED,WAAOc,QAAQ,CAACf,KAAK,CAACC,KAAD,CAAN,EAAe,EAAf,CAAR,IAA8Ba,QAAQ,GAAG,CAAC,CAAJ,GAAQ,CAA9C,CAAP;AACD,GARD;;AAUAV;AACE,WAAOY,MAAM,CAAC,KAAKC,OAAL,EAAD,CAAb;AACD,GAFD;;AAGF;AAAC,CAxCD;;;;AA0CA,SAASL,MAAT,CAAgBX,KAAhB,EAAiC;AAC/B,OAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1BN,SAAK,CAACM,CAAD,CAAL,IAAY,IAAZ;AACD;;AAED,OAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAAC,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BN,SAAK,CAACM,CAAD,CAAL;AACA,QAAIN,KAAK,CAACM,CAAD,CAAL,KAAa,CAAjB,EAAoB;AACrB;AACF","names":["toHex","bytes","byteLength","Error","Int64","number","Uint8Array","i","remaining","Math","abs","round","negate","slice","negative","parseInt","String","valueOf"],"sources":["/home/dalienst/node_modules/@aws-sdk/eventstream-marshaller/src/Int64.ts"],"sourcesContent":["import { Int64 as IInt64 } from \"@aws-sdk/types\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\n\nexport interface Int64 extends IInt64 {}\n\n/**\n * A lossless representation of a signed, 64-bit integer. Instances of this\n * class may be used in arithmetic expressions as if they were numeric\n * primitives, but the binary representation will be preserved unchanged as the\n * `bytes` property of the object. The bytes should be encoded as big-endian,\n * two's complement integers.\n */\nexport class Int64 {\n  constructor(readonly bytes: Uint8Array) {\n    if (bytes.byteLength !== 8) {\n      throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n    }\n  }\n\n  static fromNumber(number: number): Int64 {\n    if (number > 9223372036854775807 || number < -9223372036854775808) {\n      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);\n    }\n\n    const bytes = new Uint8Array(8);\n    for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n      bytes[i] = remaining;\n    }\n\n    if (number < 0) {\n      negate(bytes);\n    }\n\n    return new Int64(bytes);\n  }\n\n  /**\n   * Called implicitly by infix arithmetic operators.\n   */\n  valueOf(): number {\n    const bytes = this.bytes.slice(0);\n    const negative = bytes[0] & 0b10000000;\n    if (negative) {\n      negate(bytes);\n    }\n\n    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n  }\n\n  toString() {\n    return String(this.valueOf());\n  }\n}\n\nfunction negate(bytes: Uint8Array): void {\n  for (let i = 0; i < 8; i++) {\n    bytes[i] ^= 0xff;\n  }\n\n  for (let i = 7; i > -1; i--) {\n    bytes[i]++;\n    if (bytes[i] !== 0) break;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}