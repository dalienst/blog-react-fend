{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { ClientDevice, Credentials, getAmplifyUserAgent, StorageHelper, transferKeyToUpperCase } from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport { ChannelType, GetInAppMessagesCommand, UpdateEndpointCommand, PinpointClient } from '@aws-sdk/client-pinpoint';\nimport { v4 as uuid } from 'uuid';\nimport { addMessageInteractionEventListener } from '../../eventListeners';\nimport SessionTracker from '../../SessionTracker';\nimport { InAppMessageInteractionEvent } from '../../types';\nimport { AWSPinpointMessageEvent } from './types';\nimport { clearMemo, dispatchInAppMessagingEvent, extractContent, extractMetadata, getStartOfDay, interpretLayout, isBeforeEndDate, logger, matchesAttributes, matchesEventType, matchesMetrics, recordAnalyticsEvent } from './utils';\nvar MESSAGE_DAILY_COUNT_KEY = 'pinpointProvider_inAppMessages_dailyCount';\nvar MESSAGE_TOTAL_COUNT_KEY = 'pinpointProvider_inAppMessages_totalCount';\n\nvar AWSPinpointProvider =\n/** @class */\nfunction () {\n  function AWSPinpointProvider() {\n    var _this = this;\n\n    var _a;\n\n    this.config = {};\n    this.configured = false;\n    this.endpointInitialized = false;\n    this.initialized = false;\n\n    this.configure = function (config) {\n      if (config === void 0) {\n        config = {};\n      }\n\n      _this.config = __assign(__assign({}, _this.config), config);\n      logger.debug('configure AWSPinpointProvider', _this.config); // some configuration steps should not be re-run even if provider is re-configured for some reason\n\n      if (!_this.configured) {\n        _this.sessionTracker = new SessionTracker(_this.sessionStateChangeHandler);\n\n        _this.sessionTracker.start(); // wire up default Pinpoint message event handling\n\n\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISPLAYED);\n        }, InAppMessageInteractionEvent.MESSAGE_DISPLAYED);\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISMISSED);\n        }, InAppMessageInteractionEvent.MESSAGE_DISMISSED);\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_ACTION_TAKEN);\n        }, InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN);\n      }\n\n      _this.configured = true;\n      dispatchInAppMessagingEvent('pinpointProvider_configured', null);\n      return _this.config;\n    };\n\n    this.getInAppMessages = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, endpointId, pinpointClient, input, command, response, messages, err_1;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!!this.initialized) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.init()];\n\n            case 1:\n              _b.sent();\n\n              _b.label = 2;\n\n            case 2:\n              // There is no way to granuarly reconcile the filter memoization as the keys are composited from a message id and\n              // event properties thus opting to just clear them out when getting messages rather than leave potentially\n              // obsolete entries that will no longer serve any purpose.\n              clearMemo();\n              _b.label = 3;\n\n            case 3:\n              _b.trys.push([3, 6,, 7]);\n\n              return [4\n              /*yield*/\n              , this.updateEndpoint()];\n\n            case 4:\n              _b.sent();\n\n              _a = this.config, appId = _a.appId, endpointId = _a.endpointId, pinpointClient = _a.pinpointClient;\n              input = {\n                ApplicationId: appId,\n                EndpointId: endpointId\n              };\n              command = new GetInAppMessagesCommand(input);\n              logger.debug('getting in-app messages', input);\n              return [4\n              /*yield*/\n              , pinpointClient.send(command)];\n\n            case 5:\n              response = _b.sent();\n              messages = response.InAppMessagesResponse.InAppMessageCampaigns;\n              dispatchInAppMessagingEvent('getInAppMessages', messages);\n              return [2\n              /*return*/\n              , messages];\n\n            case 6:\n              err_1 = _b.sent();\n              logger.error('Error getting in-app messages', err_1);\n              throw err_1;\n\n            case 7:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.processInAppMessages = function (messages, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var highestPrioritySeen;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.init()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              return [2\n              /*return*/\n              , this.normalizeMessages(messages.reduce(function (acc, message) {\n                var messageQualifies = matchesEventType(message, event) && matchesAttributes(message, event) && matchesMetrics(message, event) && isBeforeEndDate(message) && _this.isBelowCap(message); // filter all qualifying messages returning only those that are of (relative) highest priority\n\n\n                if (messageQualifies) {\n                  // have not yet encountered message with priority\n                  if (!highestPrioritySeen) {\n                    // this message has priority, so reset the accumulator with this message only\n                    if (message.Priority) {\n                      highestPrioritySeen = message.Priority;\n                      return [message];\n                    } else {\n                      // this message also has no priority, so just add this message to accumulator\n                      acc.push(message);\n                    } // have previously encountered message with priority, so only messages with priority matter now\n\n                  } else if (message.Priority) {\n                    // this message has higher priority (lower number), so reset the accumulator with this message only\n                    if (message.Priority < highestPrioritySeen) {\n                      highestPrioritySeen = message.Priority;\n                      return [message]; // this message has the same priority, so just add this message to accumulator\n                    } else if (message.Priority === highestPrioritySeen) {\n                      acc.push(message);\n                    }\n                  }\n                }\n\n                return acc;\n              }, []))];\n          }\n        });\n      });\n    };\n\n    this.identifyUser = function (userId, userInfo) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var err_2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.init()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              _a.trys.push([2, 4,, 5]);\n\n              return [4\n              /*yield*/\n              , this.updateEndpoint(userId, userInfo)];\n\n            case 3:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 5];\n\n            case 4:\n              err_2 = _a.sent();\n              logger.error('Error identifying user', err_2);\n              throw err_2;\n\n            case 5:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.init = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, endpointId, storage, providerName, _b, err_3;\n\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              _a = this.config, endpointId = _a.endpointId, storage = _a.storage;\n              providerName = this.getProviderName();\n              _c.label = 1;\n\n            case 1:\n              _c.trys.push([1, 6,, 7]);\n\n              if (!(typeof storage.sync === 'function')) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , storage.sync()];\n\n            case 2:\n              _c.sent();\n\n              _c.label = 3;\n\n            case 3:\n              if (!!endpointId) return [3\n              /*break*/\n              , 5];\n              _b = this.config;\n              return [4\n              /*yield*/\n              , this.getEndpointId()];\n\n            case 4:\n              _b.endpointId = _c.sent();\n              _c.label = 5;\n\n            case 5:\n              this.initialized = true;\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              err_3 = _c.sent();\n              logger.error(\"Failed to initialize \" + providerName, err_3);\n              return [3\n              /*break*/\n              , 7];\n\n            case 7:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.initPinpointClient = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, credentials, pinpointClient, region;\n\n        return __generator(this, function (_b) {\n          _a = this.config, appId = _a.appId, credentials = _a.credentials, pinpointClient = _a.pinpointClient, region = _a.region;\n\n          if (!appId || !credentials || !region) {\n            throw new Error('One or more of credentials, appId or region is not configured');\n          }\n\n          if (pinpointClient) {\n            pinpointClient.destroy();\n          }\n\n          this.config.pinpointClient = new PinpointClient({\n            region: region,\n            credentials: credentials,\n            customUserAgent: getAmplifyUserAgent()\n          });\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    };\n\n    this.getEndpointId = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var appId, cacheKey, cachedEndpointId, endpointId, ttl, expiration;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              appId = this.config.appId;\n              cacheKey = this.getSubCategory() + \":\" + this.getProviderName() + \":\" + appId;\n              return [4\n              /*yield*/\n              , Cache.getItem(cacheKey)];\n\n            case 1:\n              cachedEndpointId = _a.sent(); // Found in cache, just return it\n\n              if (cachedEndpointId) {\n                return [2\n                /*return*/\n                , cachedEndpointId];\n              }\n\n              endpointId = uuid();\n              ttl = 1000 * 60 * 60 * 24 * 365 * 100;\n              expiration = new Date().getTime() + ttl;\n              Cache.setItem(cacheKey, endpointId, {\n                expires: expiration,\n                priority: 1\n              });\n              return [2\n              /*return*/\n              , endpointId];\n          }\n        });\n      });\n    };\n\n    this.updateEndpoint = function (userId, userInfo) {\n      if (userId === void 0) {\n        userId = null;\n      }\n\n      if (userInfo === void 0) {\n        userInfo = null;\n      }\n\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, credentials, endpointId, _b, endpointInfo, pinpointClient, currentCredentials, credentialsUpdated, _c, address, attributes, demographic, location_1, metrics, optOut, _d, appVersion, make, model, platform, version, input, command, err_4;\n\n        var _e;\n\n        return __generator(this, function (_f) {\n          switch (_f.label) {\n            case 0:\n              _a = this.config, appId = _a.appId, credentials = _a.credentials, endpointId = _a.endpointId, _b = _a.endpointInfo, endpointInfo = _b === void 0 ? {} : _b, pinpointClient = _a.pinpointClient;\n              return [4\n              /*yield*/\n              , this.getCredentials()];\n\n            case 1:\n              currentCredentials = _f.sent();\n              credentialsUpdated = !credentials || Object.keys(currentCredentials).some(function (key) {\n                return currentCredentials[key] !== credentials[key];\n              }); // If endpoint is already initialized, and nothing else is changing, just early return\n\n              if (this.endpointInitialized && !credentialsUpdated && !userId && !userInfo) {\n                return [2\n                /*return*/\n                ];\n              } // Update credentials\n\n\n              this.config.credentials = currentCredentials;\n              _f.label = 2;\n\n            case 2:\n              _f.trys.push([2, 6,, 7]);\n\n              if (!(!pinpointClient || credentialsUpdated)) return [3\n              /*break*/\n              , 4];\n              return [4\n              /*yield*/\n              , this.initPinpointClient()];\n\n            case 3:\n              _f.sent();\n\n              _f.label = 4;\n\n            case 4:\n              _c = userInfo !== null && userInfo !== void 0 ? userInfo : {}, address = _c.address, attributes = _c.attributes, demographic = _c.demographic, location_1 = _c.location, metrics = _c.metrics, optOut = _c.optOut;\n              _d = this.clientInfo, appVersion = _d.appVersion, make = _d.make, model = _d.model, platform = _d.platform, version = _d.version;\n              input = {\n                ApplicationId: appId,\n                EndpointId: endpointId,\n                EndpointRequest: {\n                  RequestId: uuid(),\n                  EffectiveDate: new Date().toISOString(),\n                  ChannelType: ChannelType.IN_APP,\n                  Address: address !== null && address !== void 0 ? address : endpointInfo.address,\n                  Attributes: __assign(__assign({}, endpointInfo.attributes), attributes),\n                  Demographic: __assign({\n                    AppVersion: appVersion,\n                    Make: make,\n                    Model: model,\n                    ModelVersion: version,\n                    Platform: platform\n                  }, transferKeyToUpperCase(__assign(__assign({}, endpointInfo.demographic), demographic))),\n                  Location: transferKeyToUpperCase(__assign(__assign({}, endpointInfo.location), location_1)),\n                  Metrics: __assign(__assign({}, endpointInfo.metrics), metrics),\n                  OptOut: optOut !== null && optOut !== void 0 ? optOut : endpointInfo.optOut,\n                  User: {\n                    UserId: (_e = userId !== null && userId !== void 0 ? userId : endpointInfo.userId) !== null && _e !== void 0 ? _e : currentCredentials.identityId,\n                    UserAttributes: attributes !== null && attributes !== void 0 ? attributes : endpointInfo.userAttributes\n                  }\n                }\n              };\n              command = new UpdateEndpointCommand(input);\n              logger.debug('updating endpoint', input);\n              return [4\n              /*yield*/\n              , this.config.pinpointClient.send(command)];\n\n            case 5:\n              _f.sent();\n\n              this.endpointInitialized = true;\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              err_4 = _f.sent();\n              throw err_4;\n\n            case 7:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.getCredentials = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var credentials, err_5;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4\n              /*yield*/\n              , Credentials.get()];\n\n            case 1:\n              credentials = _a.sent();\n\n              if (!credentials) {\n                logger.debug('no credentials found');\n                return [2\n                /*return*/\n                , null];\n              }\n\n              return [2\n              /*return*/\n              , Credentials.shear(credentials)];\n\n            case 2:\n              err_5 = _a.sent();\n              logger.error('Error getting credentials:', err_5);\n              return [2\n              /*return*/\n              , null];\n\n            case 3:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.sessionStateChangeHandler = function (state) {\n      if (state === 'started') {\n        // reset all session counts\n        _this.sessionMessageCountMap = {};\n      }\n    };\n\n    this.isBelowCap = function (_a) {\n      var CampaignId = _a.CampaignId,\n          SessionCap = _a.SessionCap,\n          DailyCap = _a.DailyCap,\n          TotalCap = _a.TotalCap;\n\n      var _b = _this.getMessageCounts(CampaignId),\n          sessionCount = _b.sessionCount,\n          dailyCount = _b.dailyCount,\n          totalCount = _b.totalCount;\n\n      return (!SessionCap || sessionCount < SessionCap) && (!DailyCap || dailyCount < DailyCap) && (!TotalCap || totalCount < TotalCap);\n    }; // Use the current session count in memory or initialize as empty count\n\n\n    this.getSessionCount = function (messageId) {\n      return _this.sessionMessageCountMap[messageId] || 0;\n    };\n\n    this.getDailyCount = function () {\n      var storage = _this.config.storage;\n      var today = getStartOfDay();\n      var item = storage.getItem(MESSAGE_DAILY_COUNT_KEY); // Parse stored count or initialize as empty count\n\n      var counter = item ? JSON.parse(item) : {\n        count: 0,\n        lastCountTimestamp: today\n      }; // If the stored counter timestamp is today, use it as the count, otherwise reset to 0\n\n      return counter.lastCountTimestamp === today ? counter.count : 0;\n    };\n\n    this.getTotalCountMap = function () {\n      var storage = _this.config.storage;\n      var item = storage.getItem(MESSAGE_TOTAL_COUNT_KEY); // Parse stored count map or initialize as empty\n\n      return item ? JSON.parse(item) : {};\n    };\n\n    this.getTotalCount = function (messageId) {\n      var countMap = _this.getTotalCountMap(); // Return stored count or initialize as empty count\n\n\n      return countMap[messageId] || 0;\n    };\n\n    this.getMessageCounts = function (messageId) {\n      try {\n        return {\n          sessionCount: _this.getSessionCount(messageId),\n          dailyCount: _this.getDailyCount(),\n          totalCount: _this.getTotalCount(messageId)\n        };\n      } catch (err) {\n        logger.error('Failed to get message counts from storage', err);\n      }\n    };\n\n    this.setSessionCount = function (messageId, count) {\n      _this.sessionMessageCountMap[messageId] = count;\n    };\n\n    this.setDailyCount = function (count) {\n      var storage = _this.config.storage;\n      var dailyCount = {\n        count: count,\n        lastCountTimestamp: getStartOfDay()\n      };\n\n      try {\n        storage.setItem(MESSAGE_DAILY_COUNT_KEY, JSON.stringify(dailyCount));\n      } catch (err) {\n        logger.error('Failed to save daily message count to storage', err);\n      }\n    };\n\n    this.setTotalCountMap = function (countMap) {\n      var storage = _this.config.storage;\n\n      try {\n        storage.setItem(MESSAGE_TOTAL_COUNT_KEY, JSON.stringify(countMap));\n      } catch (err) {\n        logger.error('Failed to save total count to storage', err);\n      }\n    };\n\n    this.setTotalCount = function (messageId, count) {\n      var _a;\n\n      var updatedMap = __assign(__assign({}, _this.getTotalCountMap()), (_a = {}, _a[messageId] = count, _a));\n\n      _this.setTotalCountMap(updatedMap);\n    };\n\n    this.incrementCounts = function (messageId) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, sessionCount, dailyCount, totalCount;\n\n        return __generator(this, function (_b) {\n          _a = this.getMessageCounts(messageId), sessionCount = _a.sessionCount, dailyCount = _a.dailyCount, totalCount = _a.totalCount;\n          this.setSessionCount(messageId, sessionCount + 1);\n          this.setDailyCount(dailyCount + 1);\n          this.setTotalCount(messageId, totalCount + 1);\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    };\n\n    this.normalizeMessages = function (messages) {\n      return messages.map(function (message) {\n        var CampaignId = message.CampaignId,\n            InAppMessage = message.InAppMessage;\n        return {\n          id: CampaignId,\n          content: extractContent(message),\n          layout: interpretLayout(InAppMessage.Layout),\n          metadata: extractMetadata(message)\n        };\n      });\n    };\n\n    this.recordMessageEvent = function (message, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.init()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              recordAnalyticsEvent(event, message);\n              if (!(event === AWSPinpointMessageEvent.MESSAGE_DISPLAYED)) return [3\n              /*break*/\n              , 4];\n              return [4\n              /*yield*/\n              , this.incrementCounts(message.id)];\n\n            case 3:\n              _a.sent();\n\n              _a.label = 4;\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.sessionMessageCountMap = {};\n    this.config = {\n      storage: new StorageHelper().getStorage()\n    };\n    this.clientInfo = (_a = ClientDevice.clientInfo()) !== null && _a !== void 0 ? _a : {};\n  }\n  /**\n   * get the category of the plugin\n   */\n\n\n  AWSPinpointProvider.prototype.getCategory = function () {\n    return AWSPinpointProvider.category;\n  };\n  /**\n   * get the sub-category of the plugin\n   */\n\n\n  AWSPinpointProvider.prototype.getSubCategory = function () {\n    return AWSPinpointProvider.subCategory;\n  };\n  /**\n   * get provider name of the plugin\n   */\n\n\n  AWSPinpointProvider.prototype.getProviderName = function () {\n    return AWSPinpointProvider.providerName;\n  };\n\n  AWSPinpointProvider.category = 'Notifications';\n  AWSPinpointProvider.subCategory = 'InAppMessaging';\n  AWSPinpointProvider.providerName = 'AWSPinpoint';\n  return AWSPinpointProvider;\n}();\n\nexport default AWSPinpointProvider;","map":{"version":3,"mappings":"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","names":["ClientDevice","Credentials","getAmplifyUserAgent","StorageHelper","transferKeyToUpperCase","Cache","ChannelType","GetInAppMessagesCommand","UpdateEndpointCommand","PinpointClient","v4","uuid","addMessageInteractionEventListener","SessionTracker","InAppMessageInteractionEvent","AWSPinpointMessageEvent","clearMemo","dispatchInAppMessagingEvent","extractContent","extractMetadata","getStartOfDay","interpretLayout","isBeforeEndDate","logger","matchesAttributes","matchesEventType","matchesMetrics","recordAnalyticsEvent","MESSAGE_DAILY_COUNT_KEY","MESSAGE_TOTAL_COUNT_KEY","config","_this","__assign","debug","configured","sessionTracker","sessionStateChangeHandler","start","message","recordMessageEvent","MESSAGE_DISPLAYED","MESSAGE_DISMISSED","MESSAGE_ACTION_TAKEN","initialized","init","_b","updateEndpoint","_a","appId","endpointId","pinpointClient","input","ApplicationId","EndpointId","command","send","response","messages","InAppMessagesResponse","InAppMessageCampaigns","error","err_1","event","normalizeMessages","reduce","acc","messageQualifies","isBelowCap","highestPrioritySeen","Priority","push","userId","userInfo","err_2","storage","providerName","getProviderName","sync","_c","getEndpointId","err_3","credentials","region","Error","destroy","customUserAgent","cacheKey","getSubCategory","getItem","cachedEndpointId","ttl","expiration","Date","getTime","setItem","expires","priority","endpointInfo","getCredentials","currentCredentials","_f","credentialsUpdated","Object","keys","some","key","endpointInitialized","initPinpointClient","address","attributes","demographic","location_1","metrics","optOut","_d","clientInfo","appVersion","make","model","platform","version","EndpointRequest","RequestId","EffectiveDate","toISOString","IN_APP","Address","Attributes","Demographic","AppVersion","Make","Model","ModelVersion","Platform","Location","location","Metrics","OptOut","User","UserId","_e","identityId","UserAttributes","userAttributes","err_4","get","shear","err_5","state","sessionMessageCountMap","CampaignId","SessionCap","DailyCap","TotalCap","sessionCount","dailyCount","totalCount","messageId","today","item","counter","JSON","parse","count","lastCountTimestamp","countMap","getTotalCountMap","getSessionCount","getDailyCount","getTotalCount","err","stringify","updatedMap","setTotalCountMap","getMessageCounts","setSessionCount","setDailyCount","setTotalCount","map","InAppMessage","id","content","layout","Layout","metadata","incrementCounts","getStorage","AWSPinpointProvider","category","subCategory"],"sources":["/home/dalienst/node_modules/@aws-amplify/notifications/src/InAppMessaging/Providers/AWSPinpointProvider/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tClientDevice,\n\tCredentials,\n\tgetAmplifyUserAgent,\n\tStorageHelper,\n\ttransferKeyToUpperCase,\n} from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport {\n\tChannelType,\n\tGetInAppMessagesCommand,\n\tGetInAppMessagesCommandInput,\n\tInAppMessageCampaign as PinpointInAppMessage,\n\tUpdateEndpointCommand,\n\tUpdateEndpointCommandInput,\n\tPinpointClient,\n} from '@aws-sdk/client-pinpoint';\nimport { v4 as uuid } from 'uuid';\n\nimport { addMessageInteractionEventListener } from '../../eventListeners';\nimport { NotificationsCategory } from '../../../types';\nimport SessionTracker, {\n\tSessionState,\n\tSessionStateChangeHandler,\n} from '../../SessionTracker';\nimport {\n\tInAppMessage,\n\tInAppMessageInteractionEvent,\n\tInAppMessageLayout,\n\tInAppMessagingEvent,\n\tInAppMessagingProvider,\n\tNotificationsSubcategory,\n\tUserInfo,\n} from '../../types';\nimport {\n\tAWSPinpointMessageEvent,\n\tAWSPinpointUserInfo,\n\tDailyInAppMessageCounter,\n\tInAppMessageCountMap,\n\tInAppMessageCounts,\n} from './types';\nimport {\n\tclearMemo,\n\tdispatchInAppMessagingEvent,\n\textractContent,\n\textractMetadata,\n\tgetStartOfDay,\n\tinterpretLayout,\n\tisBeforeEndDate,\n\tlogger,\n\tmatchesAttributes,\n\tmatchesEventType,\n\tmatchesMetrics,\n\trecordAnalyticsEvent,\n} from './utils';\n\nconst MESSAGE_DAILY_COUNT_KEY = 'pinpointProvider_inAppMessages_dailyCount';\nconst MESSAGE_TOTAL_COUNT_KEY = 'pinpointProvider_inAppMessages_totalCount';\n\nexport default class AWSPinpointProvider implements InAppMessagingProvider {\n\tstatic category: NotificationsCategory = 'Notifications';\n\tstatic subCategory: NotificationsSubcategory = 'InAppMessaging';\n\tstatic providerName = 'AWSPinpoint';\n\n\tprivate clientInfo;\n\tprivate config: Record<string, any> = {};\n\tprivate configured = false;\n\tprivate endpointInitialized = false;\n\tprivate initialized = false;\n\tprivate sessionMessageCountMap: InAppMessageCountMap;\n\tprivate sessionTracker: SessionTracker;\n\n\tconstructor() {\n\t\tthis.sessionMessageCountMap = {};\n\t\tthis.config = {\n\t\t\tstorage: new StorageHelper().getStorage(),\n\t\t};\n\t\tthis.clientInfo = ClientDevice.clientInfo() ?? {};\n\t}\n\n\t/**\n\t * get the category of the plugin\n\t */\n\tgetCategory() {\n\t\treturn AWSPinpointProvider.category;\n\t}\n\n\t/**\n\t * get the sub-category of the plugin\n\t */\n\tgetSubCategory() {\n\t\treturn AWSPinpointProvider.subCategory;\n\t}\n\n\t/**\n\t * get provider name of the plugin\n\t */\n\tgetProviderName(): string {\n\t\treturn AWSPinpointProvider.providerName;\n\t}\n\n\tconfigure = (config = {}): object => {\n\t\tthis.config = { ...this.config, ...config };\n\n\t\tlogger.debug('configure AWSPinpointProvider', this.config);\n\n\t\t// some configuration steps should not be re-run even if provider is re-configured for some reason\n\t\tif (!this.configured) {\n\t\t\tthis.sessionTracker = new SessionTracker(this.sessionStateChangeHandler);\n\t\t\tthis.sessionTracker.start();\n\t\t\t// wire up default Pinpoint message event handling\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_DISPLAYED\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_DISPLAYED);\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_DISMISSED\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_DISMISSED);\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_ACTION_TAKEN\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN);\n\t\t}\n\n\t\tthis.configured = true;\n\t\tdispatchInAppMessagingEvent('pinpointProvider_configured', null);\n\t\treturn this.config;\n\t};\n\n\tgetInAppMessages = async () => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\t// There is no way to granuarly reconcile the filter memoization as the keys are composited from a message id and\n\t\t// event properties thus opting to just clear them out when getting messages rather than leave potentially\n\t\t// obsolete entries that will no longer serve any purpose.\n\t\tclearMemo();\n\t\ttry {\n\t\t\tawait this.updateEndpoint();\n\t\t\tconst { appId, endpointId, pinpointClient } = this.config;\n\t\t\tconst input: GetInAppMessagesCommandInput = {\n\t\t\t\tApplicationId: appId,\n\t\t\t\tEndpointId: endpointId,\n\t\t\t};\n\t\t\tconst command: GetInAppMessagesCommand = new GetInAppMessagesCommand(\n\t\t\t\tinput\n\t\t\t);\n\t\t\tlogger.debug('getting in-app messages', input);\n\t\t\tconst response = await pinpointClient.send(command);\n\t\t\tconst { InAppMessageCampaigns: messages } =\n\t\t\t\tresponse.InAppMessagesResponse;\n\t\t\tdispatchInAppMessagingEvent('getInAppMessages', messages);\n\t\t\treturn messages;\n\t\t} catch (err) {\n\t\t\tlogger.error('Error getting in-app messages', err);\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprocessInAppMessages = async (\n\t\tmessages: any[],\n\t\tevent: InAppMessagingEvent\n\t): Promise<InAppMessage[]> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\tlet highestPrioritySeen;\n\t\treturn this.normalizeMessages(\n\t\t\t(messages as PinpointInAppMessage[]).reduce((acc, message) => {\n\t\t\t\tconst messageQualifies =\n\t\t\t\t\tmatchesEventType(message, event) &&\n\t\t\t\t\tmatchesAttributes(message, event) &&\n\t\t\t\t\tmatchesMetrics(message, event) &&\n\t\t\t\t\tisBeforeEndDate(message) &&\n\t\t\t\t\tthis.isBelowCap(message);\n\t\t\t\t// filter all qualifying messages returning only those that are of (relative) highest priority\n\t\t\t\tif (messageQualifies) {\n\t\t\t\t\t// have not yet encountered message with priority\n\t\t\t\t\tif (!highestPrioritySeen) {\n\t\t\t\t\t\t// this message has priority, so reset the accumulator with this message only\n\t\t\t\t\t\tif (message.Priority) {\n\t\t\t\t\t\t\thighestPrioritySeen = message.Priority;\n\t\t\t\t\t\t\treturn [message];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// this message also has no priority, so just add this message to accumulator\n\t\t\t\t\t\t\tacc.push(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// have previously encountered message with priority, so only messages with priority matter now\n\t\t\t\t\t} else if (message.Priority) {\n\t\t\t\t\t\t// this message has higher priority (lower number), so reset the accumulator with this message only\n\t\t\t\t\t\tif (message.Priority < highestPrioritySeen) {\n\t\t\t\t\t\t\thighestPrioritySeen = message.Priority;\n\t\t\t\t\t\t\treturn [message];\n\t\t\t\t\t\t\t// this message has the same priority, so just add this message to accumulator\n\t\t\t\t\t\t} else if (message.Priority === highestPrioritySeen) {\n\t\t\t\t\t\t\tacc.push(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn acc;\n\t\t\t}, [])\n\t\t);\n\t};\n\n\tidentifyUser = async (userId: string, userInfo: UserInfo): Promise<void> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\ttry {\n\t\t\tawait this.updateEndpoint(userId, userInfo);\n\t\t} catch (err) {\n\t\t\tlogger.error('Error identifying user', err);\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprivate init = async () => {\n\t\tconst { endpointId, storage } = this.config;\n\t\tconst providerName = this.getProviderName();\n\t\ttry {\n\t\t\t// Only run sync() if it's available (i.e. React Native)\n\t\t\tif (typeof storage.sync === 'function') {\n\t\t\t\tawait storage.sync();\n\t\t\t}\n\t\t\t// If an endpoint was not provided via configuration, try to get it from cache\n\t\t\tif (!endpointId) {\n\t\t\t\tthis.config.endpointId = await this.getEndpointId();\n\t\t\t}\n\t\t\tthis.initialized = true;\n\t\t} catch (err) {\n\t\t\tlogger.error(`Failed to initialize ${providerName}`, err);\n\t\t}\n\t};\n\n\tprivate initPinpointClient = async () => {\n\t\tconst { appId, credentials, pinpointClient, region } = this.config;\n\n\t\tif (!appId || !credentials || !region) {\n\t\t\tthrow new Error(\n\t\t\t\t'One or more of credentials, appId or region is not configured'\n\t\t\t);\n\t\t}\n\n\t\tif (pinpointClient) {\n\t\t\tpinpointClient.destroy();\n\t\t}\n\n\t\tthis.config.pinpointClient = new PinpointClient({\n\t\t\tregion,\n\t\t\tcredentials,\n\t\t\tcustomUserAgent: getAmplifyUserAgent(),\n\t\t});\n\t};\n\n\tprivate getEndpointId = async () => {\n\t\tconst { appId } = this.config;\n\t\t// Each Pinpoint channel requires its own Endpoint ID\n\t\tconst cacheKey = `${this.getSubCategory()}:${this.getProviderName()}:${appId}`;\n\t\t// First attempt to retrieve the ID from cache\n\t\tconst cachedEndpointId = await Cache.getItem(cacheKey);\n\t\t// Found in cache, just return it\n\t\tif (cachedEndpointId) {\n\t\t\treturn cachedEndpointId;\n\t\t}\n\t\t// Otherwise, generate a new ID and store it in long-lived cache before returning it\n\t\tconst endpointId = uuid();\n\t\t// Set a longer TTL to avoid endpoint id being deleted after the default TTL (3 days)\n\t\t// Also set its priority to the highest to reduce its chance of being deleted when cache is full\n\t\tconst ttl = 1000 * 60 * 60 * 24 * 365 * 100; // 100 years\n\t\tconst expiration = new Date().getTime() + ttl;\n\t\tCache.setItem(cacheKey, endpointId, {\n\t\t\texpires: expiration,\n\t\t\tpriority: 1,\n\t\t});\n\t\treturn endpointId;\n\t};\n\n\tprivate updateEndpoint = async (\n\t\tuserId: string = null,\n\t\tuserInfo: AWSPinpointUserInfo = null\n\t) => {\n\t\tconst {\n\t\t\tappId,\n\t\t\tcredentials,\n\t\t\tendpointId,\n\t\t\tendpointInfo = {},\n\t\t\tpinpointClient,\n\t\t} = this.config;\n\t\tconst currentCredentials = await this.getCredentials();\n\t\t// Shallow compare to determine if credentials stored here are outdated\n\t\tconst credentialsUpdated =\n\t\t\t!credentials ||\n\t\t\tObject.keys(currentCredentials).some(\n\t\t\t\tkey => currentCredentials[key] !== credentials[key]\n\t\t\t);\n\t\t// If endpoint is already initialized, and nothing else is changing, just early return\n\t\tif (\n\t\t\tthis.endpointInitialized &&\n\t\t\t!credentialsUpdated &&\n\t\t\t!userId &&\n\t\t\t!userInfo\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\t// Update credentials\n\t\tthis.config.credentials = currentCredentials;\n\t\ttry {\n\t\t\t// Initialize a new pinpoint client if one isn't already configured or if credentials changed\n\t\t\tif (!pinpointClient || credentialsUpdated) {\n\t\t\t\tawait this.initPinpointClient();\n\t\t\t}\n\t\t\tconst { address, attributes, demographic, location, metrics, optOut } =\n\t\t\t\tuserInfo ?? {};\n\t\t\tconst { appVersion, make, model, platform, version } = this.clientInfo;\n\t\t\t// Create the UpdateEndpoint input, prioritizing passed in user info and falling back to\n\t\t\t// defaults (if any) obtained from the config\n\t\t\tconst input: UpdateEndpointCommandInput = {\n\t\t\t\tApplicationId: appId,\n\t\t\t\tEndpointId: endpointId,\n\t\t\t\tEndpointRequest: {\n\t\t\t\t\tRequestId: uuid(),\n\t\t\t\t\tEffectiveDate: new Date().toISOString(),\n\t\t\t\t\tChannelType: ChannelType.IN_APP,\n\t\t\t\t\tAddress: address ?? endpointInfo.address,\n\t\t\t\t\tAttributes: {\n\t\t\t\t\t\t...endpointInfo.attributes,\n\t\t\t\t\t\t...attributes,\n\t\t\t\t\t},\n\t\t\t\t\tDemographic: {\n\t\t\t\t\t\tAppVersion: appVersion,\n\t\t\t\t\t\tMake: make,\n\t\t\t\t\t\tModel: model,\n\t\t\t\t\t\tModelVersion: version,\n\t\t\t\t\t\tPlatform: platform,\n\t\t\t\t\t\t...transferKeyToUpperCase({\n\t\t\t\t\t\t\t...endpointInfo.demographic,\n\t\t\t\t\t\t\t...demographic,\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t\tLocation: transferKeyToUpperCase({\n\t\t\t\t\t\t...endpointInfo.location,\n\t\t\t\t\t\t...location,\n\t\t\t\t\t}),\n\t\t\t\t\tMetrics: {\n\t\t\t\t\t\t...endpointInfo.metrics,\n\t\t\t\t\t\t...metrics,\n\t\t\t\t\t},\n\t\t\t\t\tOptOut: optOut ?? endpointInfo.optOut,\n\t\t\t\t\tUser: {\n\t\t\t\t\t\tUserId:\n\t\t\t\t\t\t\tuserId ?? endpointInfo.userId ?? currentCredentials.identityId,\n\t\t\t\t\t\tUserAttributes: attributes ?? endpointInfo.userAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst command: UpdateEndpointCommand = new UpdateEndpointCommand(input);\n\t\t\tlogger.debug('updating endpoint', input);\n\t\t\tawait this.config.pinpointClient.send(command);\n\t\t\tthis.endpointInitialized = true;\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprivate getCredentials = async () => {\n\t\ttry {\n\t\t\tconst credentials = await Credentials.get();\n\t\t\tif (!credentials) {\n\t\t\t\tlogger.debug('no credentials found');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Credentials.shear(credentials);\n\t\t} catch (err) {\n\t\t\tlogger.error('Error getting credentials:', err);\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tprivate sessionStateChangeHandler: SessionStateChangeHandler = (\n\t\tstate: SessionState\n\t) => {\n\t\tif (state === 'started') {\n\t\t\t// reset all session counts\n\t\t\tthis.sessionMessageCountMap = {};\n\t\t}\n\t};\n\n\tprivate isBelowCap = ({\n\t\tCampaignId,\n\t\tSessionCap,\n\t\tDailyCap,\n\t\tTotalCap,\n\t}: PinpointInAppMessage): boolean => {\n\t\tconst { sessionCount, dailyCount, totalCount } =\n\t\t\tthis.getMessageCounts(CampaignId);\n\t\treturn (\n\t\t\t(!SessionCap || sessionCount < SessionCap) &&\n\t\t\t(!DailyCap || dailyCount < DailyCap) &&\n\t\t\t(!TotalCap || totalCount < TotalCap)\n\t\t);\n\t};\n\n\t// Use the current session count in memory or initialize as empty count\n\tprivate getSessionCount = (messageId: string): number =>\n\t\tthis.sessionMessageCountMap[messageId] || 0;\n\n\tprivate getDailyCount = (): number => {\n\t\tconst { storage } = this.config;\n\t\tconst today = getStartOfDay();\n\t\tconst item = storage.getItem(MESSAGE_DAILY_COUNT_KEY);\n\t\t// Parse stored count or initialize as empty count\n\t\tconst counter: DailyInAppMessageCounter = item\n\t\t\t? JSON.parse(item)\n\t\t\t: { count: 0, lastCountTimestamp: today };\n\t\t// If the stored counter timestamp is today, use it as the count, otherwise reset to 0\n\t\treturn counter.lastCountTimestamp === today ? counter.count : 0;\n\t};\n\n\tprivate getTotalCountMap = (): InAppMessageCountMap => {\n\t\tconst { storage } = this.config;\n\t\tconst item = storage.getItem(MESSAGE_TOTAL_COUNT_KEY);\n\t\t// Parse stored count map or initialize as empty\n\t\treturn item ? JSON.parse(item) : {};\n\t};\n\n\tprivate getTotalCount = (messageId: string): number => {\n\t\tconst countMap = this.getTotalCountMap();\n\t\t// Return stored count or initialize as empty count\n\t\treturn countMap[messageId] || 0;\n\t};\n\n\tprivate getMessageCounts = (messageId: string): InAppMessageCounts => {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tsessionCount: this.getSessionCount(messageId),\n\t\t\t\tdailyCount: this.getDailyCount(),\n\t\t\t\ttotalCount: this.getTotalCount(messageId),\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to get message counts from storage', err);\n\t\t}\n\t};\n\n\tprivate setSessionCount = (messageId: string, count: number): void => {\n\t\tthis.sessionMessageCountMap[messageId] = count;\n\t};\n\n\tprivate setDailyCount = (count: number): void => {\n\t\tconst { storage } = this.config;\n\t\tconst dailyCount: DailyInAppMessageCounter = {\n\t\t\tcount,\n\t\t\tlastCountTimestamp: getStartOfDay(),\n\t\t};\n\t\ttry {\n\t\t\tstorage.setItem(MESSAGE_DAILY_COUNT_KEY, JSON.stringify(dailyCount));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to save daily message count to storage', err);\n\t\t}\n\t};\n\n\tprivate setTotalCountMap = (countMap: InAppMessageCountMap): void => {\n\t\tconst { storage } = this.config;\n\t\ttry {\n\t\t\tstorage.setItem(MESSAGE_TOTAL_COUNT_KEY, JSON.stringify(countMap));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to save total count to storage', err);\n\t\t}\n\t};\n\n\tprivate setTotalCount = (messageId: string, count: number): void => {\n\t\tconst updatedMap = {\n\t\t\t...this.getTotalCountMap(),\n\t\t\t[messageId]: count,\n\t\t};\n\t\tthis.setTotalCountMap(updatedMap);\n\t};\n\n\tprivate incrementCounts = async (messageId: string): Promise<void> => {\n\t\tconst { sessionCount, dailyCount, totalCount } =\n\t\t\tthis.getMessageCounts(messageId);\n\t\tthis.setSessionCount(messageId, sessionCount + 1);\n\t\tthis.setDailyCount(dailyCount + 1);\n\t\tthis.setTotalCount(messageId, totalCount + 1);\n\t};\n\n\tprivate normalizeMessages = (\n\t\tmessages: PinpointInAppMessage[]\n\t): InAppMessage[] => {\n\t\treturn messages.map(message => {\n\t\t\tconst { CampaignId, InAppMessage } = message;\n\t\t\treturn {\n\t\t\t\tid: CampaignId,\n\t\t\t\tcontent: extractContent(message),\n\t\t\t\tlayout: interpretLayout(InAppMessage.Layout),\n\t\t\t\tmetadata: extractMetadata(message),\n\t\t\t};\n\t\t});\n\t};\n\n\tprivate recordMessageEvent = async (\n\t\tmessage: InAppMessage,\n\t\tevent: AWSPinpointMessageEvent\n\t): Promise<void> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\trecordAnalyticsEvent(event, message);\n\t\tif (event === AWSPinpointMessageEvent.MESSAGE_DISPLAYED) {\n\t\t\tawait this.incrementCounts(message.id);\n\t\t}\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}