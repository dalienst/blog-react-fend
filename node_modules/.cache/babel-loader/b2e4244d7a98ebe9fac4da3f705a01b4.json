{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator, __rest } from \"tslib\";\nimport { ConsoleLogger as Logger, Hub, StorageHelper } from '@aws-amplify/core';\nimport flatten from 'lodash/flatten';\nimport { AWSPinpointProvider } from './Providers';\nimport { addMessageInteractionEventListener, notifyMessageInteractionEventListeners } from './eventListeners';\nimport { InAppMessageInteractionEvent } from './types';\nvar STORAGE_KEY_SUFFIX = '_inAppMessages';\nvar logger = new Logger('Notifications.InAppMessaging');\n\nvar InAppMessaging =\n/** @class */\nfunction () {\n  function InAppMessaging() {\n    var _this = this;\n\n    this.config = {};\n    this.listeningForAnalyticEvents = false;\n    this.pluggables = [];\n    this.storageSynced = false;\n    /**\n     * Configure InAppMessaging\n     * @param {Object} config - InAppMessaging configuration object\n     */\n\n    this.configure = function (_a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n\n      var _b = _a.listenForAnalyticsEvents,\n          listenForAnalyticsEvents = _b === void 0 ? true : _b,\n          config = __rest(_a, [\"listenForAnalyticsEvents\"]);\n\n      _this.config = __assign(__assign({}, _this.config), config);\n      logger.debug('configure InAppMessaging', _this.config);\n\n      _this.pluggables.forEach(function (pluggable) {\n        pluggable.configure(_this.config[pluggable.getProviderName()]);\n      });\n\n      if (_this.pluggables.length === 0) {\n        _this.addPluggable(new AWSPinpointProvider());\n      }\n\n      if (listenForAnalyticsEvents && !_this.listeningForAnalyticEvents) {\n        Hub.listen('analytics', _this.analyticsListener);\n        _this.listeningForAnalyticEvents = true;\n      }\n\n      return _this.config;\n    };\n    /**\n     * Get a plugin from added plugins\n     * @param {string} providerName - the name of the plugin to get\n     */\n\n\n    this.getPluggable = function (providerName) {\n      var _a;\n\n      var pluggable = (_a = _this.pluggables.find(function (pluggable) {\n        return pluggable.getProviderName() === providerName;\n      })) !== null && _a !== void 0 ? _a : null;\n\n      if (!pluggable) {\n        logger.debug(\"No plugin found with name \" + providerName);\n      }\n\n      return pluggable;\n    };\n    /**\n     * Add plugin into InAppMessaging\n     * @param {InAppMessagingProvider} pluggable - an instance of the plugin\n     */\n\n\n    this.addPluggable = function (pluggable) {\n      if (pluggable && pluggable.getCategory() === 'Notifications' && pluggable.getSubCategory() === 'InAppMessaging') {\n        if (_this.getPluggable(pluggable.getProviderName())) {\n          throw new Error(\"Pluggable \" + pluggable.getProviderName() + \" has already been added.\");\n        }\n\n        _this.pluggables.push(pluggable);\n\n        pluggable.configure(_this.config[pluggable.getProviderName()]);\n      }\n    };\n    /**\n     * Remove a plugin from added plugins\n     * @param {string} providerName - the name of the plugin to remove\n     */\n\n\n    this.removePluggable = function (providerName) {\n      var index = _this.pluggables.findIndex(function (pluggable) {\n        return pluggable.getProviderName() === providerName;\n      });\n\n      if (index === -1) {\n        logger.debug(\"No plugin found with name \" + providerName);\n      } else {\n        _this.pluggables.splice(index, 1);\n      }\n    };\n    /**\n     * Get the map resources that are currently available through the provider\n     * @param {string} provider\n     * @returns - Array of available map resources\n     */\n\n\n    this.syncMessages = function () {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var messages, key, err_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 3,, 4]);\n\n                return [4\n                /*yield*/\n                , pluggable.getInAppMessages()];\n\n              case 1:\n                messages = _a.sent();\n                key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                return [4\n                /*yield*/\n                , this.setMessages(key, messages)];\n\n              case 2:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 4];\n\n              case 3:\n                err_1 = _a.sent();\n                logger.error('Failed to sync messages', err_1);\n                throw err_1;\n\n              case 4:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }));\n    };\n\n    this.clearMessages = function () {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var key;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                return [4\n                /*yield*/\n                , this.removeMessages(key)];\n\n              case 1:\n                _a.sent();\n\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }));\n    };\n\n    this.dispatchEvent = function (event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var messages, flattenedMessages;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , Promise.all(this.pluggables.map(function (pluggable) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var key, messages;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        key = \"\" + pluggable.getProviderName() + STORAGE_KEY_SUFFIX;\n                        return [4\n                        /*yield*/\n                        , this.getMessages(key)];\n\n                      case 1:\n                        messages = _a.sent();\n                        return [2\n                        /*return*/\n                        , pluggable.processInAppMessages(messages, event)];\n                    }\n                  });\n                });\n              }))];\n\n            case 1:\n              messages = _a.sent();\n              flattenedMessages = flatten(messages);\n\n              if (flattenedMessages.length) {\n                notifyMessageInteractionEventListeners(this.conflictHandler(flattenedMessages), InAppMessageInteractionEvent.MESSAGE_RECEIVED);\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.identifyUser = function (userId, userInfo) {\n      return Promise.all(_this.pluggables.map(function (pluggable) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_2;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n\n                return [4\n                /*yield*/\n                , pluggable.identifyUser(userId, userInfo)];\n\n              case 1:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 3];\n\n              case 2:\n                err_2 = _a.sent();\n                logger.error('Failed to identify user', err_2);\n                throw err_2;\n\n              case 3:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }));\n    };\n\n    this.onMessageReceived = function (handler) {\n      return addMessageInteractionEventListener(handler, InAppMessageInteractionEvent.MESSAGE_RECEIVED);\n    };\n\n    this.onMessageDisplayed = function (handler) {\n      return addMessageInteractionEventListener(handler, InAppMessageInteractionEvent.MESSAGE_DISPLAYED);\n    };\n\n    this.onMessageDismissed = function (handler) {\n      return addMessageInteractionEventListener(handler, InAppMessageInteractionEvent.MESSAGE_DISMISSED);\n    };\n\n    this.onMessageActionTaken = function (handler) {\n      return addMessageInteractionEventListener(handler, InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN);\n    };\n\n    this.notifyMessageInteraction = function (message, event) {\n      notifyMessageInteractionEventListeners(message, event);\n    };\n\n    this.setConflictHandler = function (handler) {\n      _this.conflictHandler = handler;\n    };\n\n    this.analyticsListener = function (_a) {\n      var payload = _a.payload;\n      var event = payload.event,\n          data = payload.data;\n\n      switch (event) {\n        case 'record':\n          {\n            _this.dispatchEvent(data);\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    };\n\n    this.syncStorage = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_3;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              storage = this.config.storage;\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 4,, 5]);\n\n              if (!(typeof storage.sync === 'function')) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , storage.sync()];\n\n            case 2:\n              _a.sent();\n\n              _a.label = 3;\n\n            case 3:\n              this.storageSynced = true;\n              return [3\n              /*break*/\n              , 5];\n\n            case 4:\n              err_3 = _a.sent();\n              logger.error('Failed to sync storage', err_3);\n              return [3\n              /*break*/\n              , 5];\n\n            case 5:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.getMessages = function (key) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, storedMessages, err_4;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 3,, 4]);\n\n              if (!!this.storageSynced) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.syncStorage()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              storage = this.config.storage;\n              storedMessages = storage.getItem(key);\n              return [2\n              /*return*/\n              , storedMessages ? JSON.parse(storedMessages) : []];\n\n            case 3:\n              err_4 = _a.sent();\n              logger.error('Failed to retrieve in-app messages from storage', err_4);\n              return [3\n              /*break*/\n              , 4];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.setMessages = function (key, messages) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_5;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!messages) {\n                return [2\n                /*return*/\n                ];\n              }\n\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 4,, 5]);\n\n              if (!!this.storageSynced) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , this.syncStorage()];\n\n            case 2:\n              _a.sent();\n\n              _a.label = 3;\n\n            case 3:\n              storage = this.config.storage;\n              storage.setItem(key, JSON.stringify(messages));\n              return [3\n              /*break*/\n              , 5];\n\n            case 4:\n              err_5 = _a.sent();\n              logger.error('Failed to store in-app messages', err_5);\n              return [3\n              /*break*/\n              , 5];\n\n            case 5:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.removeMessages = function (key) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var storage, err_6;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 3,, 4]);\n\n              if (!!this.storageSynced) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.syncStorage()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              storage = this.config.storage;\n              storage.removeItem(key);\n              return [3\n              /*break*/\n              , 4];\n\n            case 3:\n              err_6 = _a.sent();\n              logger.error('Failed to remove in-app messages from storage', err_6);\n              return [3\n              /*break*/\n              , 4];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.defaultConflictHandler = function (messages) {\n      // default behavior is to return the message closest to expiry\n      // this function assumes that messages processed by providers already filters out expired messages\n      var sorted = messages.sort(function (a, b) {\n        var _a, _b;\n\n        var endDateA = (_a = a.metadata) === null || _a === void 0 ? void 0 : _a.endDate;\n        var endDateB = (_b = b.metadata) === null || _b === void 0 ? void 0 : _b.endDate; // if both message end dates are falsy or have the same date string, treat them as equal\n\n        if (endDateA === endDateB) {\n          return 0;\n        } // if only message A has an end date, treat it as closer to expiry\n\n\n        if (endDateA && !endDateB) {\n          return -1;\n        } // if only message B has an end date, treat it as closer to expiry\n\n\n        if (!endDateA && endDateB) {\n          return 1;\n        } // otherwise, compare them\n\n\n        return new Date(endDateA) < new Date(endDateB) ? -1 : 1;\n      }); // always return the top sorted\n\n      return sorted[0];\n    };\n\n    this.config = {\n      storage: new StorageHelper().getStorage()\n    };\n    this.setConflictHandler(this.defaultConflictHandler);\n  }\n  /**\n   * Get the name of this module\n   * @returns {string} name of this module\n   */\n\n\n  InAppMessaging.prototype.getModuleName = function () {\n    return 'InAppMessaging';\n  };\n\n  return InAppMessaging;\n}();\n\nexport default InAppMessaging;","map":{"version":3,"mappings":"AAAA;AACA;;AAEA,SACCA,aAAa,IAAIC,MADlB,EAICC,GAJD,EAKCC,aALD,QAMO,mBANP;AAOA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SAASC,mBAAT,QAAoC,aAApC;AACA,SACCC,kCADD,EAECC,sCAFD,QAGO,kBAHP;AAIA,SAECC,4BAFD,QAWO,SAXP;AAaA,IAAMC,kBAAkB,GAAG,gBAA3B;AAEA,IAAMC,MAAM,GAAG,IAAIT,MAAJ,CAAW,8BAAX,CAAf;;AAEA;AAAA;AAAA;AAOC;AAAA;;AANQ,kBAA8B,EAA9B;AAEA,sCAA6B,KAA7B;AACA,sBAAuC,EAAvC;AACA,yBAAgB,KAAhB;AASR;;;;;AAIA,qBAAY,UAACU,EAAD,EAGgB;AAHf;AAAAA;AAGe;;AAF3B;AAAA;AAAA,UACAC,iDADA;;AAGAC,WAAI,CAACD,MAAL,GAAWE,sBAAQD,KAAI,CAACD,MAAb,GAAwBA,MAAxB,CAAX;AAEAF,YAAM,CAACK,KAAP,CAAa,0BAAb,EAAyCF,KAAI,CAACD,MAA9C;;AAEAC,WAAI,CAACG,UAAL,CAAgBC,OAAhB,CAAwB,qBAAS;AAChCC,iBAAS,CAACC,SAAV,CAAoBN,KAAI,CAACD,MAAL,CAAYM,SAAS,CAACE,eAAV,EAAZ,CAApB;AACA,OAFD;;AAIA,UAAIP,KAAI,CAACG,UAAL,CAAgBK,MAAhB,KAA2B,CAA/B,EAAkC;AACjCR,aAAI,CAACS,YAAL,CAAkB,IAAIjB,mBAAJ,EAAlB;AACA;;AAED,UAAIkB,wBAAwB,IAAI,CAACV,KAAI,CAACW,0BAAtC,EAAkE;AACjEtB,WAAG,CAACuB,MAAJ,CAAW,WAAX,EAAwBZ,KAAI,CAACa,iBAA7B;AACAb,aAAI,CAACW,0BAAL,GAAkC,IAAlC;AACA;;AAED,aAAOX,KAAI,CAACD,MAAZ;AACA,KAtBD;AAgCA;;;;;;AAIA,wBAAe,UAACe,YAAD,EAAqB;;;AACnC,UAAMT,SAAS,SACdL,KAAI,CAACG,UAAL,CAAgBY,IAAhB,CACC,qBAAS;AAAI,wBAAS,CAACR,eAAV,OAAgCO,YAAhC;AAA4C,OAD1D,CADc,MAGb,IAHa,IAGbhB,aAHa,GAGbA,EAHa,GAGT,IAHN;;AAKA,UAAI,CAACO,SAAL,EAAgB;AACfR,cAAM,CAACK,KAAP,CAAa,+BAA6BY,YAA1C;AACA;;AAED,aAAOT,SAAP;AACA,KAXD;AAaA;;;;;;AAIA,wBAAe,UAACA,SAAD,EAAkC;AAChD,UACCA,SAAS,IACTA,SAAS,CAACW,WAAV,OAA4B,eAD5B,IAEAX,SAAS,CAACY,cAAV,OAA+B,gBAHhC,EAIE;AACD,YAAIjB,KAAI,CAACkB,YAAL,CAAkBb,SAAS,CAACE,eAAV,EAAlB,CAAJ,EAAoD;AACnD,gBAAM,IAAIY,KAAJ,CACL,eAAad,SAAS,CAACE,eAAV,EAAb,GAAwC,0BADnC,CAAN;AAGA;;AACDP,aAAI,CAACG,UAAL,CAAgBiB,IAAhB,CAAqBf,SAArB;;AACAA,iBAAS,CAACC,SAAV,CAAoBN,KAAI,CAACD,MAAL,CAAYM,SAAS,CAACE,eAAV,EAAZ,CAApB;AACA;AACD,KAdD;AAgBA;;;;;;AAIA,2BAAkB,UAACO,YAAD,EAAqB;AACtC,UAAMO,KAAK,GAAGrB,KAAI,CAACG,UAAL,CAAgBmB,SAAhB,CACb,qBAAS;AAAI,wBAAS,CAACf,eAAV,OAAgCO,YAAhC;AAA4C,OAD5C,CAAd;;AAGA,UAAIO,KAAK,KAAK,CAAC,CAAf,EAAkB;AACjBxB,cAAM,CAACK,KAAP,CAAa,+BAA6BY,YAA1C;AACA,OAFD,MAEO;AACNd,aAAI,CAACG,UAAL,CAAgBoB,MAAhB,CAAuBF,KAAvB,EAA8B,CAA9B;AACA;AACD,KATD;AAWA;;;;;;;AAKA,wBAAe;AACd,oBAAO,CAACG,GAAR,CACCxB,KAAI,CAACG,UAAL,CAAgBsB,GAAhB,CAAoB,UAAMpB,SAAN,EAAe;AAAA;;;;;;;AAEhB;AAAA;AAAA,kBAAMA,SAAS,CAACqB,gBAAV,EAAN;;;AAAXC,wBAAQ,GAAG7B,SAAX;AACA8B,mBAAG,GAAG,KAAGvB,SAAS,CAACE,eAAV,EAAH,GAAiCX,kBAAvC;AACN;AAAA;AAAA,kBAAM,KAAKiC,WAAL,CAAiBD,GAAjB,EAAsBD,QAAtB,CAAN;;;AAAA7B;;;;;;;;AAEAD,sBAAM,CAACiC,KAAP,CAAa,yBAAb,EAAwCC,KAAxC;AACA,sBAAMA,KAAN;;;;;;;;SAPiC;AASlC,OATD,CADD;AAWC,KAZF;;AAcA,yBAAgB;AACf,oBAAO,CAACP,GAAR,CACCxB,KAAI,CAACG,UAAL,CAAgBsB,GAAhB,CAAoB,UAAMpB,SAAN,EAAe;AAAA;;;;;AAC5BuB,mBAAG,GAAG,KAAGvB,SAAS,CAACE,eAAV,EAAH,GAAiCX,kBAAvC;AACN;AAAA;AAAA,kBAAM,KAAKoC,cAAL,CAAoBJ,GAApB,CAAN;;;AAAA9B;;;;;;;SAFkC;AAGlC,OAHD,CADD;AAKC,KANF;;AAQA,yBAAgB,UAAOmC,KAAP,EAAiC;AAAA;;;;;;;;AACb;AAAA;AAAA,gBAAMC,OAAO,CAACV,GAAR,CACxC,KAAKrB,UAAL,CAAgBsB,GAAhB,CAAoB,UAAMpB,SAAN,EAAe;AAAA;;;;;AAC5BuB,2BAAG,GAAG,KAAGvB,SAAS,CAACE,eAAV,EAAH,GAAiCX,kBAAvC;AACW;AAAA;AAAA,0BAAM,KAAKuC,WAAL,CAAiBP,GAAjB,CAAN;;;AAAXD,gCAAQ,GAAG7B,SAAX;AACN;AAAA;AAAA,0BAAOO,SAAS,CAAC+B,oBAAV,CAA+BT,QAA/B,EAAyCM,KAAzC,CAAP;;;iBAHkC;AAIlC,eAJD,CADwC,CAAN;;;AAA7BN,sBAAQ,GAAqB7B,SAA7B;AAQAuC,+BAAiB,GAAG9C,OAAO,CAACoC,QAAD,CAA3B;;AAEN,kBAAIU,iBAAiB,CAAC7B,MAAtB,EAA8B;AAC7Bd,sDAAsC,CACrC,KAAK4C,eAAL,CAAqBD,iBAArB,CADqC,EAErC1C,4BAA4B,CAAC4C,gBAFQ,CAAtC;AAIA;;;;;;;OAhB+C;AAiBhD,KAjBD;;AAmBA,wBAAe,UAACC,MAAD,EAAiBC,QAAjB,EAAmC;AACjD,oBAAO,CAACjB,GAAR,CACCxB,KAAI,CAACG,UAAL,CAAgBsB,GAAhB,CAAoB,UAAMpB,SAAN,EAAe;AAAA;;;;;;;AAEjC;AAAA;AAAA,kBAAMA,SAAS,CAACqC,YAAV,CAAuBF,MAAvB,EAA+BC,QAA/B,CAAN;;;AAAA3C;;;;;;;;AAEAD,sBAAM,CAACiC,KAAP,CAAa,yBAAb,EAAwCa,KAAxC;AACA,sBAAMA,KAAN;;;;;;;;SALiC;AAOlC,OAPD,CADD;AASC,KAVF;;AAYA,6BAAoB,UACnBC,OADmB,EACsB;AAEzC,+CAAkC,CACjCA,OADiC,EAEjCjD,4BAA4B,CAAC4C,gBAFI,CAAlC;AAGC,KANF;;AAQA,8BAAqB,UACpBK,OADoB,EACqB;AAEzC,+CAAkC,CACjCA,OADiC,EAEjCjD,4BAA4B,CAACkD,iBAFI,CAAlC;AAGC,KANF;;AAQA,8BAAqB,UACpBD,OADoB,EACqB;AAEzC,+CAAkC,CACjCA,OADiC,EAEjCjD,4BAA4B,CAACmD,iBAFI,CAAlC;AAGC,KANF;;AAQA,gCAAuB,UACtBF,OADsB,EACmB;AAEzC,+CAAkC,CACjCA,OADiC,EAEjCjD,4BAA4B,CAACoD,oBAFI,CAAlC;AAGC,KANF;;AAQA,oCAA2B,UAC1BC,OAD0B,EAE1Bf,KAF0B,EAES;AAEnCvC,4CAAsC,CAACsD,OAAD,EAAUf,KAAV,CAAtC;AACA,KALD;;AAOA,8BAAqB,UAACW,OAAD,EAAqC;AACzD5C,WAAI,CAACsC,eAAL,GAAuBM,OAAvB;AACA,KAFD;;AAIQ,6BAAiC,UAAC9C,EAAD,EAAwB;UAArBmD;AACnC;AAAA,UAAOC,mBAAP;;AACR,cAAQjB,KAAR;AACC,aAAK,QAAL;AAAe;AACdjC,iBAAI,CAACmD,aAAL,CAAmBD,IAAnB;;AACA;AACA;;AACD;AACC;AANF;AAQA,KAVO;;AAYA,uBAAc;AAAA;;;;;AACbE,qBAAO,GAAK,KAAKrD,MAAL,CAAWqD,OAAvB;;;;;;oBAGH,OAAOA,OAAO,CAACC,IAAf,KAAwB,aAAxB;AAAA;AAAA;AACH;AAAA;AAAA,gBAAMD,OAAO,CAACC,IAAR,EAAN;;;AAAAvD;;;;;AAED,mBAAKwD,aAAL,GAAqB,IAArB;;;;;;;AAEAzD,oBAAM,CAACiC,KAAP,CAAa,wBAAb,EAAuCyB,KAAvC;;;;;;;;;;;OAToB;AAWrB,KAXO;;AAaA,uBAAc,UAAO3B,GAAP,EAAkB;AAAA;;;;;;;mBAElC,CAAC,KAAK0B,eAAN;AAAA;AAAA;AACH;AAAA;AAAA,gBAAM,KAAKE,WAAL,EAAN;;;AAAA1D;;;;;AAEOsD,qBAAO,GAAK,KAAKrD,MAAL,CAAWqD,OAAvB;AACFK,4BAAc,GAAGL,OAAO,CAACM,OAAR,CAAgB9B,GAAhB,CAAjB;AACN;AAAA;AAAA,gBAAO6B,cAAc,GAAGE,IAAI,CAACC,KAAL,CAAWH,cAAX,CAAH,GAAgC,EAArD;;;;AAEA5D,oBAAM,CAACiC,KAAP,CAAa,iDAAb,EAAgE+B,KAAhE;;;;;;;;;;;OATsC;AAWvC,KAXO;;AAaA,uBAAc,UACrBjC,GADqB,EAErBD,QAFqB,EAEG;AAAA;;;;;AAExB,kBAAI,CAACA,QAAL,EAAe;AACd;AAAA;AAAA;AACA;;;;;;;mBAGI,CAAC,KAAK2B,eAAN;AAAA;AAAA;AACH;AAAA;AAAA,gBAAM,KAAKE,WAAL,EAAN;;;AAAA1D;;;;;AAEOsD,qBAAO,GAAK,KAAKrD,MAAL,CAAWqD,OAAvB;AACRA,qBAAO,CAACU,OAAR,CAAgBlC,GAAhB,EAAqB+B,IAAI,CAACI,SAAL,CAAepC,QAAf,CAArB;;;;;;;AAEA9B,oBAAM,CAACiC,KAAP,CAAa,iCAAb,EAAgDkC,KAAhD;;;;;;;;;;;OAbuB;AAexB,KAjBO;;AAmBA,0BAAiB,UAAOpC,GAAP,EAAkB;AAAA;;;;;;;mBAErC,CAAC,KAAK0B,eAAN;AAAA;AAAA;AACH;AAAA;AAAA,gBAAM,KAAKE,WAAL,EAAN;;;AAAA1D;;;;;AAEOsD,qBAAO,GAAK,KAAKrD,MAAL,CAAWqD,OAAvB;AACRA,qBAAO,CAACa,UAAR,CAAmBrC,GAAnB;;;;;;;AAEA/B,oBAAM,CAACiC,KAAP,CAAa,+CAAb,EAA8DoC,KAA9D;;;;;;;;;;;OARyC;AAU1C,KAVO;;AAYA,kCAAyB,UAACvC,QAAD,EAAyB;AACzD;AACA;AACA,UAAMwC,MAAM,GAAGxC,QAAQ,CAACyC,IAAT,CAAc,UAACC,CAAD,EAAIC,CAAJ,EAAK;;;AACjC,YAAMC,QAAQ,SAAGF,CAAC,CAACG,QAAL,MAAa,IAAb,IAAa1E,aAAb,GAAa,MAAb,GAAaA,GAAE2E,OAA7B;AACA,YAAMC,QAAQ,SAAGJ,CAAC,CAACE,QAAL,MAAa,IAAb,IAAaG,aAAb,GAAa,MAAb,GAAaA,GAAEF,OAA7B,CAFiC,CAGjC;;AACA,YAAIF,QAAQ,KAAKG,QAAjB,EAA2B;AAC1B,iBAAO,CAAP;AACA,SANgC,CAOjC;;;AACA,YAAIH,QAAQ,IAAI,CAACG,QAAjB,EAA2B;AAC1B,iBAAO,CAAC,CAAR;AACA,SAVgC,CAWjC;;;AACA,YAAI,CAACH,QAAD,IAAaG,QAAjB,EAA2B;AAC1B,iBAAO,CAAP;AACA,SAdgC,CAejC;;;AACA,eAAO,IAAIE,IAAJ,CAASL,QAAT,IAAqB,IAAIK,IAAJ,CAASF,QAAT,CAArB,GAA0C,CAAC,CAA3C,GAA+C,CAAtD;AACA,OAjBc,CAAf,CAHyD,CAqBzD;;AACA,aAAOP,MAAM,CAAC,CAAD,CAAb;AACA,KAvBO;;AAxQP,SAAKpE,MAAL,GAAc;AACbqD,aAAO,EAAE,IAAI9D,aAAJ,GAAoBuF,UAApB;AADI,KAAd;AAGA,SAAKC,kBAAL,CAAwB,KAAKC,sBAA7B;AACA;AA8BD;;;;;;AAIAC;AACC,WAAO,gBAAP;AACA,GAFD;;AA0PD;AAAC,CAxSD","names":["ConsoleLogger","Logger","Hub","StorageHelper","flatten","AWSPinpointProvider","addMessageInteractionEventListener","notifyMessageInteractionEventListeners","InAppMessageInteractionEvent","STORAGE_KEY_SUFFIX","logger","_a","config","_this","__assign","debug","pluggables","forEach","pluggable","configure","getProviderName","length","addPluggable","listenForAnalyticsEvents","listeningForAnalyticEvents","listen","analyticsListener","providerName","find","getCategory","getSubCategory","getPluggable","Error","push","index","findIndex","splice","all","map","getInAppMessages","messages","key","setMessages","error","err_1","removeMessages","event","Promise","getMessages","processInAppMessages","flattenedMessages","conflictHandler","MESSAGE_RECEIVED","userId","userInfo","identifyUser","err_2","handler","MESSAGE_DISPLAYED","MESSAGE_DISMISSED","MESSAGE_ACTION_TAKEN","message","payload","data","dispatchEvent","storage","sync","storageSynced","err_3","syncStorage","storedMessages","getItem","JSON","parse","err_4","setItem","stringify","err_5","removeItem","err_6","sorted","sort","a","b","endDateA","metadata","endDate","endDateB","_b","Date","getStorage","setConflictHandler","defaultConflictHandler","InAppMessaging"],"sources":["/home/dalienst/node_modules/@aws-amplify/notifications/src/InAppMessaging/InAppMessaging.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tConsoleLogger as Logger,\n\tHubCallback,\n\tHubCapsule,\n\tHub,\n\tStorageHelper,\n} from '@aws-amplify/core';\nimport flatten from 'lodash/flatten';\nimport { AWSPinpointProvider } from './Providers';\nimport {\n\taddMessageInteractionEventListener,\n\tnotifyMessageInteractionEventListeners,\n} from './eventListeners';\nimport {\n\tInAppMessage,\n\tInAppMessageInteractionEvent,\n\tInAppMessagingConfig,\n\tInAppMessageConflictHandler,\n\tInAppMessagingEvent,\n\tInAppMessagingProvider,\n\tNotificationsSubcategory,\n\tOnMessageInteractionEventHandler,\n\tOnMessageInteractionEventListener,\n\tUserInfo,\n} from './types';\n\nconst STORAGE_KEY_SUFFIX = '_inAppMessages';\n\nconst logger = new Logger('Notifications.InAppMessaging');\n\nexport default class InAppMessaging {\n\tprivate config: Record<string, any> = {};\n\tprivate conflictHandler: InAppMessageConflictHandler;\n\tprivate listeningForAnalyticEvents = false;\n\tprivate pluggables: InAppMessagingProvider[] = [];\n\tprivate storageSynced = false;\n\n\tconstructor() {\n\t\tthis.config = {\n\t\t\tstorage: new StorageHelper().getStorage(),\n\t\t};\n\t\tthis.setConflictHandler(this.defaultConflictHandler);\n\t}\n\n\t/**\n\t * Configure InAppMessaging\n\t * @param {Object} config - InAppMessaging configuration object\n\t */\n\tconfigure = ({\n\t\tlistenForAnalyticsEvents = true,\n\t\t...config\n\t}: InAppMessagingConfig = {}): InAppMessagingConfig => {\n\t\tthis.config = { ...this.config, ...config };\n\n\t\tlogger.debug('configure InAppMessaging', this.config);\n\n\t\tthis.pluggables.forEach(pluggable => {\n\t\t\tpluggable.configure(this.config[pluggable.getProviderName()]);\n\t\t});\n\n\t\tif (this.pluggables.length === 0) {\n\t\t\tthis.addPluggable(new AWSPinpointProvider());\n\t\t}\n\n\t\tif (listenForAnalyticsEvents && !this.listeningForAnalyticEvents) {\n\t\t\tHub.listen('analytics', this.analyticsListener);\n\t\t\tthis.listeningForAnalyticEvents = true;\n\t\t}\n\n\t\treturn this.config;\n\t};\n\n\t/**\n\t * Get the name of this module\n\t * @returns {string} name of this module\n\t */\n\tgetModuleName(): NotificationsSubcategory {\n\t\treturn 'InAppMessaging';\n\t}\n\n\t/**\n\t * Get a plugin from added plugins\n\t * @param {string} providerName - the name of the plugin to get\n\t */\n\tgetPluggable = (providerName: string): InAppMessagingProvider => {\n\t\tconst pluggable =\n\t\t\tthis.pluggables.find(\n\t\t\t\tpluggable => pluggable.getProviderName() === providerName\n\t\t\t) ?? null;\n\n\t\tif (!pluggable) {\n\t\t\tlogger.debug(`No plugin found with name ${providerName}`);\n\t\t}\n\n\t\treturn pluggable;\n\t};\n\n\t/**\n\t * Add plugin into InAppMessaging\n\t * @param {InAppMessagingProvider} pluggable - an instance of the plugin\n\t */\n\taddPluggable = (pluggable: InAppMessagingProvider): void => {\n\t\tif (\n\t\t\tpluggable &&\n\t\t\tpluggable.getCategory() === 'Notifications' &&\n\t\t\tpluggable.getSubCategory() === 'InAppMessaging'\n\t\t) {\n\t\t\tif (this.getPluggable(pluggable.getProviderName())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Pluggable ${pluggable.getProviderName()} has already been added.`\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.pluggables.push(pluggable);\n\t\t\tpluggable.configure(this.config[pluggable.getProviderName()]);\n\t\t}\n\t};\n\n\t/**\n\t * Remove a plugin from added plugins\n\t * @param {string} providerName - the name of the plugin to remove\n\t */\n\tremovePluggable = (providerName: string): void => {\n\t\tconst index = this.pluggables.findIndex(\n\t\t\tpluggable => pluggable.getProviderName() === providerName\n\t\t);\n\t\tif (index === -1) {\n\t\t\tlogger.debug(`No plugin found with name ${providerName}`);\n\t\t} else {\n\t\t\tthis.pluggables.splice(index, 1);\n\t\t}\n\t};\n\n\t/**\n\t * Get the map resources that are currently available through the provider\n\t * @param {string} provider\n\t * @returns - Array of available map resources\n\t */\n\tsyncMessages = (): Promise<void[]> =>\n\t\tPromise.all<void>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\ttry {\n\t\t\t\t\tconst messages = await pluggable.getInAppMessages();\n\t\t\t\t\tconst key = `${pluggable.getProviderName()}${STORAGE_KEY_SUFFIX}`;\n\t\t\t\t\tawait this.setMessages(key, messages);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error('Failed to sync messages', err);\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\tclearMessages = (): Promise<void[]> =>\n\t\tPromise.all<void>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\tconst key = `${pluggable.getProviderName()}${STORAGE_KEY_SUFFIX}`;\n\t\t\t\tawait this.removeMessages(key);\n\t\t\t})\n\t\t);\n\n\tdispatchEvent = async (event: InAppMessagingEvent): Promise<void> => {\n\t\tconst messages: InAppMessage[][] = await Promise.all<InAppMessage[]>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\tconst key = `${pluggable.getProviderName()}${STORAGE_KEY_SUFFIX}`;\n\t\t\t\tconst messages = await this.getMessages(key);\n\t\t\t\treturn pluggable.processInAppMessages(messages, event);\n\t\t\t})\n\t\t);\n\n\t\tconst flattenedMessages = flatten(messages);\n\n\t\tif (flattenedMessages.length) {\n\t\t\tnotifyMessageInteractionEventListeners(\n\t\t\t\tthis.conflictHandler(flattenedMessages),\n\t\t\t\tInAppMessageInteractionEvent.MESSAGE_RECEIVED\n\t\t\t);\n\t\t}\n\t};\n\n\tidentifyUser = (userId: string, userInfo: UserInfo): Promise<void[]> =>\n\t\tPromise.all<void>(\n\t\t\tthis.pluggables.map(async pluggable => {\n\t\t\t\ttry {\n\t\t\t\t\tawait pluggable.identifyUser(userId, userInfo);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.error('Failed to identify user', err);\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\tonMessageReceived = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): OnMessageInteractionEventListener =>\n\t\taddMessageInteractionEventListener(\n\t\t\thandler,\n\t\t\tInAppMessageInteractionEvent.MESSAGE_RECEIVED\n\t\t);\n\n\tonMessageDisplayed = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): OnMessageInteractionEventListener =>\n\t\taddMessageInteractionEventListener(\n\t\t\thandler,\n\t\t\tInAppMessageInteractionEvent.MESSAGE_DISPLAYED\n\t\t);\n\n\tonMessageDismissed = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): OnMessageInteractionEventListener =>\n\t\taddMessageInteractionEventListener(\n\t\t\thandler,\n\t\t\tInAppMessageInteractionEvent.MESSAGE_DISMISSED\n\t\t);\n\n\tonMessageActionTaken = (\n\t\thandler: OnMessageInteractionEventHandler\n\t): OnMessageInteractionEventListener =>\n\t\taddMessageInteractionEventListener(\n\t\t\thandler,\n\t\t\tInAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN\n\t\t);\n\n\tnotifyMessageInteraction = (\n\t\tmessage: InAppMessage,\n\t\tevent: InAppMessageInteractionEvent\n\t): void => {\n\t\tnotifyMessageInteractionEventListeners(message, event);\n\t};\n\n\tsetConflictHandler = (handler: InAppMessageConflictHandler): void => {\n\t\tthis.conflictHandler = handler;\n\t};\n\n\tprivate analyticsListener: HubCallback = ({ payload }: HubCapsule) => {\n\t\tconst { event, data } = payload;\n\t\tswitch (event) {\n\t\t\tcase 'record': {\n\t\t\t\tthis.dispatchEvent(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\tprivate syncStorage = async (): Promise<void> => {\n\t\tconst { storage } = this.config;\n\t\ttry {\n\t\t\t// Only run sync() if it's available (i.e. React Native)\n\t\t\tif (typeof storage.sync === 'function') {\n\t\t\t\tawait storage.sync();\n\t\t\t}\n\t\t\tthis.storageSynced = true;\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to sync storage', err);\n\t\t}\n\t};\n\n\tprivate getMessages = async (key: string): Promise<any> => {\n\t\ttry {\n\t\t\tif (!this.storageSynced) {\n\t\t\t\tawait this.syncStorage();\n\t\t\t}\n\t\t\tconst { storage } = this.config;\n\t\t\tconst storedMessages = storage.getItem(key);\n\t\t\treturn storedMessages ? JSON.parse(storedMessages) : [];\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to retrieve in-app messages from storage', err);\n\t\t}\n\t};\n\n\tprivate setMessages = async (\n\t\tkey: string,\n\t\tmessages: InAppMessage[]\n\t): Promise<void> => {\n\t\tif (!messages) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (!this.storageSynced) {\n\t\t\t\tawait this.syncStorage();\n\t\t\t}\n\t\t\tconst { storage } = this.config;\n\t\t\tstorage.setItem(key, JSON.stringify(messages));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to store in-app messages', err);\n\t\t}\n\t};\n\n\tprivate removeMessages = async (key: string): Promise<void> => {\n\t\ttry {\n\t\t\tif (!this.storageSynced) {\n\t\t\t\tawait this.syncStorage();\n\t\t\t}\n\t\t\tconst { storage } = this.config;\n\t\t\tstorage.removeItem(key);\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to remove in-app messages from storage', err);\n\t\t}\n\t};\n\n\tprivate defaultConflictHandler = (messages: InAppMessage[]): InAppMessage => {\n\t\t// default behavior is to return the message closest to expiry\n\t\t// this function assumes that messages processed by providers already filters out expired messages\n\t\tconst sorted = messages.sort((a, b) => {\n\t\t\tconst endDateA = a.metadata?.endDate;\n\t\t\tconst endDateB = b.metadata?.endDate;\n\t\t\t// if both message end dates are falsy or have the same date string, treat them as equal\n\t\t\tif (endDateA === endDateB) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t// if only message A has an end date, treat it as closer to expiry\n\t\t\tif (endDateA && !endDateB) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// if only message B has an end date, treat it as closer to expiry\n\t\t\tif (!endDateA && endDateB) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t// otherwise, compare them\n\t\t\treturn new Date(endDateA) < new Date(endDateB) ? -1 : 1;\n\t\t});\n\t\t// always return the top sorted\n\t\treturn sorted[0];\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}