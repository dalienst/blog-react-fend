{"ast":null,"code":"import { RECONNECT_DELAY, RECONNECT_INTERVAL } from '../Providers/constants';\nexport var ReconnectEvent;\n\n(function (ReconnectEvent) {\n  ReconnectEvent[\"START_RECONNECT\"] = \"START_RECONNECT\";\n  ReconnectEvent[\"HALT_RECONNECT\"] = \"HALT_RECONNECT\";\n})(ReconnectEvent || (ReconnectEvent = {}));\n/**\n * Captures the reconnect event logic used to determine when to reconnect to PubSub providers.\n *   Reconnnect attempts are delayed by 5 seconds to let the interface settle.\n *   Attempting to reconnect only once creates unrecoverable states when the network state isn't\n *   supported by the browser, so this keeps retrying every minute until halted.\n */\n\n\nvar ReconnectionMonitor =\n/** @class */\nfunction () {\n  function ReconnectionMonitor() {\n    this.reconnectObservers = [];\n  }\n  /**\n   * Add reconnect observer to the list of observers to alert on reconnect\n   */\n\n\n  ReconnectionMonitor.prototype.addObserver = function (reconnectObserver) {\n    this.reconnectObservers.push(reconnectObserver);\n  };\n  /**\n   * Given a reconnect event, start the appropriate behavior\n   */\n\n\n  ReconnectionMonitor.prototype.record = function (event) {\n    var _this = this;\n\n    if (event === ReconnectEvent.START_RECONNECT) {\n      // If the reconnection hasn't been started\n      if (this.reconnectSetTimeoutId === undefined && this.reconnectIntervalId === undefined) {\n        this.reconnectSetTimeoutId = setTimeout(function () {\n          // Reconnect now\n          _this._triggerReconnect(); // Retry reconnect every periodically until it works\n\n\n          _this.reconnectIntervalId = setInterval(function () {\n            _this._triggerReconnect();\n          }, RECONNECT_INTERVAL);\n        }, RECONNECT_DELAY);\n      }\n    }\n\n    if (event === ReconnectEvent.HALT_RECONNECT) {\n      if (this.reconnectIntervalId) {\n        clearInterval(this.reconnectIntervalId);\n        this.reconnectIntervalId = undefined;\n      }\n\n      if (this.reconnectSetTimeoutId) {\n        clearTimeout(this.reconnectSetTimeoutId);\n        this.reconnectSetTimeoutId = undefined;\n      }\n    }\n  };\n  /**\n   * Complete all reconnect observers\n   */\n\n\n  ReconnectionMonitor.prototype.close = function () {\n    this.reconnectObservers.forEach(function (reconnectObserver) {\n      var _a;\n\n      (_a = reconnectObserver.complete) === null || _a === void 0 ? void 0 : _a.call(reconnectObserver);\n    });\n  };\n\n  ReconnectionMonitor.prototype._triggerReconnect = function () {\n    this.reconnectObservers.forEach(function (reconnectObserver) {\n      var _a;\n\n      (_a = reconnectObserver.next) === null || _a === void 0 ? void 0 : _a.call(reconnectObserver);\n    });\n  };\n\n  return ReconnectionMonitor;\n}();\n\nexport { ReconnectionMonitor };","map":{"version":3,"mappings":"AACA,SAASA,eAAT,EAA0BC,kBAA1B,QAAoD,wBAApD;AAEA,WAAYC,cAAZ;;AAAA,WAAYA,cAAZ,EAA0B;AACzBA;AACAA;AACA,CAHD,EAAYA,cAAc,KAAdA,cAAc,MAA1B;AAKA;;;;;;;;AAMA;AAAA;AAAA;AAAA;AACS,8BAAuC,EAAvC;AA0DR;AAtDA;;;;;AAGAC,wDAAYC,iBAAZ,EAA6C;AAC5C,SAAKC,kBAAL,CAAwBC,IAAxB,CAA6BF,iBAA7B;AACA,GAFD;AAIA;;;;;AAGAD,mDAAOI,KAAP,EAA4B;AAA5B;;AACC,QAAIA,KAAK,KAAKL,cAAc,CAACM,eAA7B,EAA8C;AAC7C;AACA,UACC,KAAKC,qBAAL,KAA+BC,SAA/B,IACA,KAAKC,mBAAL,KAA6BD,SAF9B,EAGE;AACD,aAAKD,qBAAL,GAA6BG,UAAU,CAAC;AACvC;AACAC,eAAI,CAACC,iBAAL,GAFuC,CAGvC;;;AACAD,eAAI,CAACF,mBAAL,GAA2BI,WAAW,CAAC;AACtCF,iBAAI,CAACC,iBAAL;AACA,WAFqC,EAEnCb,kBAFmC,CAAtC;AAGA,SAPsC,EAOpCD,eAPoC,CAAvC;AAQA;AACD;;AAED,QAAIO,KAAK,KAAKL,cAAc,CAACc,cAA7B,EAA6C;AAC5C,UAAI,KAAKL,mBAAT,EAA8B;AAC7BM,qBAAa,CAAC,KAAKN,mBAAN,CAAb;AACA,aAAKA,mBAAL,GAA2BD,SAA3B;AACA;;AACD,UAAI,KAAKD,qBAAT,EAAgC;AAC/BS,oBAAY,CAAC,KAAKT,qBAAN,CAAZ;AACA,aAAKA,qBAAL,GAA6BC,SAA7B;AACA;AACD;AACD,GA5BD;AA8BA;;;;;AAGAP;AACC,SAAKE,kBAAL,CAAwBc,OAAxB,CAAgC,6BAAiB;;;AAChD,6BAAiB,CAACC,QAAlB,MAA0B,IAA1B,IAA0BC,aAA1B,GAA0B,MAA1B,GAA0BA,QAA1BjB,iBAA0B,CAA1B;AACA,KAFD;AAGA,GAJD;;AAMQD,oDAAR;AACC,SAAKE,kBAAL,CAAwBc,OAAxB,CAAgC,6BAAiB;;;AAChD,6BAAiB,CAACG,IAAlB,MAAsB,IAAtB,IAAsBD,aAAtB,GAAsB,MAAtB,GAAsBA,QAAtBjB,iBAAsB,CAAtB;AACA,KAFD;AAGA,GAJO;;AAKT;AAAC,CA3DD","names":["RECONNECT_DELAY","RECONNECT_INTERVAL","ReconnectEvent","ReconnectionMonitor","reconnectObserver","reconnectObservers","push","event","START_RECONNECT","reconnectSetTimeoutId","undefined","reconnectIntervalId","setTimeout","_this","_triggerReconnect","setInterval","HALT_RECONNECT","clearInterval","clearTimeout","forEach","complete","_a","next"],"sources":["/home/dalienst/node_modules/@aws-amplify/pubsub/src/utils/ReconnectionMonitor.ts"],"sourcesContent":["import { Observer } from 'zen-observable-ts';\nimport { RECONNECT_DELAY, RECONNECT_INTERVAL } from '../Providers/constants';\n\nexport enum ReconnectEvent {\n\tSTART_RECONNECT = 'START_RECONNECT',\n\tHALT_RECONNECT = 'HALT_RECONNECT',\n}\n\n/**\n * Captures the reconnect event logic used to determine when to reconnect to PubSub providers.\n *   Reconnnect attempts are delayed by 5 seconds to let the interface settle.\n *   Attempting to reconnect only once creates unrecoverable states when the network state isn't\n *   supported by the browser, so this keeps retrying every minute until halted.\n */\nexport class ReconnectionMonitor {\n\tprivate reconnectObservers: Observer<void>[] = [];\n\tprivate reconnectIntervalId?: ReturnType<typeof setInterval>;\n\tprivate reconnectSetTimeoutId?: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * Add reconnect observer to the list of observers to alert on reconnect\n\t */\n\taddObserver(reconnectObserver: Observer<void>) {\n\t\tthis.reconnectObservers.push(reconnectObserver);\n\t}\n\n\t/**\n\t * Given a reconnect event, start the appropriate behavior\n\t */\n\trecord(event: ReconnectEvent) {\n\t\tif (event === ReconnectEvent.START_RECONNECT) {\n\t\t\t// If the reconnection hasn't been started\n\t\t\tif (\n\t\t\t\tthis.reconnectSetTimeoutId === undefined &&\n\t\t\t\tthis.reconnectIntervalId === undefined\n\t\t\t) {\n\t\t\t\tthis.reconnectSetTimeoutId = setTimeout(() => {\n\t\t\t\t\t// Reconnect now\n\t\t\t\t\tthis._triggerReconnect();\n\t\t\t\t\t// Retry reconnect every periodically until it works\n\t\t\t\t\tthis.reconnectIntervalId = setInterval(() => {\n\t\t\t\t\t\tthis._triggerReconnect();\n\t\t\t\t\t}, RECONNECT_INTERVAL);\n\t\t\t\t}, RECONNECT_DELAY);\n\t\t\t}\n\t\t}\n\n\t\tif (event === ReconnectEvent.HALT_RECONNECT) {\n\t\t\tif (this.reconnectIntervalId) {\n\t\t\t\tclearInterval(this.reconnectIntervalId);\n\t\t\t\tthis.reconnectIntervalId = undefined;\n\t\t\t}\n\t\t\tif (this.reconnectSetTimeoutId) {\n\t\t\t\tclearTimeout(this.reconnectSetTimeoutId);\n\t\t\t\tthis.reconnectSetTimeoutId = undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Complete all reconnect observers\n\t */\n\tclose() {\n\t\tthis.reconnectObservers.forEach(reconnectObserver => {\n\t\t\treconnectObserver.complete?.();\n\t\t});\n\t}\n\n\tprivate _triggerReconnect() {\n\t\tthis.reconnectObservers.forEach(reconnectObserver => {\n\t\t\treconnectObserver.next?.();\n\t\t});\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}