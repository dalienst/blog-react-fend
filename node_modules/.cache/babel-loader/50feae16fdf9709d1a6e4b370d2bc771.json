{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator, __read } from \"tslib\";\nimport { isUsernamePasswordOpts, isCognitoHostedOpts, isFederatedSignInOptions, isFederatedSignInOptionsCustom, hasCustomState } from './types';\nimport { Amplify, ConsoleLogger as Logger, Credentials, Hub, StorageHelper, browserOrNode, parseAWSExports, UniversalStorage, urlSafeDecode } from '@aws-amplify/core';\nimport { CookieStorage, CognitoUserPool, AuthenticationDetails, CognitoUser, CognitoUserSession, CognitoUserAttribute, CognitoIdToken, CognitoRefreshToken, CognitoAccessToken } from 'amazon-cognito-identity-js';\nimport { parse } from 'url';\nimport OAuth from './OAuth/OAuth';\nimport { default as urlListener } from './urlListener';\nimport { AuthError, NoUserPoolError } from './Errors';\nimport { AuthErrorTypes, CognitoHostedUIIdentityProvider } from './types/Auth';\nvar logger = new Logger('AuthClass');\nvar USER_ADMIN_SCOPE = 'aws.cognito.signin.user.admin'; // 10 sec, following this guide https://www.nngroup.com/articles/response-times-3-important-limits/\n\nvar OAUTH_FLOW_MS_TIMEOUT = 10 * 1000;\nvar AMPLIFY_SYMBOL = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function' ? Symbol.for('amplify_default') : '@@amplify_default';\n\nvar dispatchAuthEvent = function (event, data, message) {\n  Hub.dispatch('auth', {\n    event: event,\n    data: data,\n    message: message\n  }, 'Auth', AMPLIFY_SYMBOL);\n}; // Cognito Documentation for max device\n// tslint:disable-next-line:max-line-length\n// https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_ListDevices.html#API_ListDevices_RequestSyntax\n\n\nvar MAX_DEVICES = 60;\nvar MAX_AUTOSIGNIN_POLLING_MS = 3 * 60 * 1000;\n/**\n * Provide authentication steps\n */\n\nvar AuthClass =\n/** @class */\nfunction () {\n  /**\n   * Initialize Auth with AWS configurations\n   * @param {Object} config - Configuration of the Auth\n   */\n  function AuthClass(config) {\n    var _this = this;\n\n    this.userPool = null;\n    this.user = null;\n    this.oAuthFlowInProgress = false;\n    this.autoSignInInitiated = false;\n    this.inflightSessionPromise = null;\n    this.inflightSessionPromiseCounter = 0;\n    this.Credentials = Credentials;\n\n    this.wrapRefreshSessionCallback = function (callback) {\n      var wrapped = function (error, data) {\n        if (data) {\n          dispatchAuthEvent('tokenRefresh', undefined, \"New token retrieved\");\n        } else {\n          dispatchAuthEvent('tokenRefresh_failure', error, \"Failed to retrieve new token\");\n        }\n\n        return callback(error, data);\n      };\n\n      return wrapped;\n    }; // prettier-ignore\n\n\n    this.configure(config);\n    this.currentCredentials = this.currentCredentials.bind(this);\n    this.currentUserCredentials = this.currentUserCredentials.bind(this);\n    Hub.listen('auth', function (_a) {\n      var payload = _a.payload;\n      var event = payload.event;\n\n      switch (event) {\n        case 'signIn':\n          _this._storage.setItem('amplify-signin-with-hostedUI', 'false');\n\n          break;\n\n        case 'signOut':\n          _this._storage.removeItem('amplify-signin-with-hostedUI');\n\n          break;\n\n        case 'cognitoHostedUI':\n          _this._storage.setItem('amplify-signin-with-hostedUI', 'true');\n\n          break;\n      }\n    });\n  }\n\n  AuthClass.prototype.getModuleName = function () {\n    return 'Auth';\n  };\n\n  AuthClass.prototype.configure = function (config) {\n    var _this = this;\n\n    if (!config) return this._config || {};\n    logger.debug('configure Auth');\n    var conf = Object.assign({}, this._config, parseAWSExports(config).Auth, config);\n    this._config = conf;\n    var _a = this._config,\n        userPoolId = _a.userPoolId,\n        userPoolWebClientId = _a.userPoolWebClientId,\n        cookieStorage = _a.cookieStorage,\n        oauth = _a.oauth,\n        region = _a.region,\n        identityPoolId = _a.identityPoolId,\n        mandatorySignIn = _a.mandatorySignIn,\n        refreshHandlers = _a.refreshHandlers,\n        identityPoolRegion = _a.identityPoolRegion,\n        clientMetadata = _a.clientMetadata,\n        endpoint = _a.endpoint;\n\n    if (!this._config.storage) {\n      // backward compatability\n      if (cookieStorage) this._storage = new CookieStorage(cookieStorage);else {\n        this._storage = config.ssr ? new UniversalStorage() : new StorageHelper().getStorage();\n      }\n    } else {\n      if (!this._isValidAuthStorage(this._config.storage)) {\n        logger.error('The storage in the Auth config is not valid!');\n        throw new Error('Empty storage object');\n      }\n\n      this._storage = this._config.storage;\n    }\n\n    this._storageSync = Promise.resolve();\n\n    if (typeof this._storage['sync'] === 'function') {\n      this._storageSync = this._storage['sync']();\n    }\n\n    if (userPoolId) {\n      var userPoolData = {\n        UserPoolId: userPoolId,\n        ClientId: userPoolWebClientId,\n        endpoint: endpoint\n      };\n      userPoolData.Storage = this._storage;\n      this.userPool = new CognitoUserPool(userPoolData, this.wrapRefreshSessionCallback);\n    }\n\n    this.Credentials.configure({\n      mandatorySignIn: mandatorySignIn,\n      region: identityPoolRegion || region,\n      userPoolId: userPoolId,\n      identityPoolId: identityPoolId,\n      refreshHandlers: refreshHandlers,\n      storage: this._storage\n    }); // initialize cognitoauth client if hosted ui options provided\n    // to keep backward compatibility:\n\n    var cognitoHostedUIConfig = oauth ? isCognitoHostedOpts(this._config.oauth) ? oauth : oauth.awsCognito : undefined;\n\n    if (cognitoHostedUIConfig) {\n      var cognitoAuthParams = Object.assign({\n        cognitoClientId: userPoolWebClientId,\n        UserPoolId: userPoolId,\n        domain: cognitoHostedUIConfig['domain'],\n        scopes: cognitoHostedUIConfig['scope'],\n        redirectSignIn: cognitoHostedUIConfig['redirectSignIn'],\n        redirectSignOut: cognitoHostedUIConfig['redirectSignOut'],\n        responseType: cognitoHostedUIConfig['responseType'],\n        Storage: this._storage,\n        urlOpener: cognitoHostedUIConfig['urlOpener'],\n        clientMetadata: clientMetadata\n      }, cognitoHostedUIConfig['options']);\n      this._oAuthHandler = new OAuth({\n        scopes: cognitoAuthParams.scopes,\n        config: cognitoAuthParams,\n        cognitoClientId: cognitoAuthParams.cognitoClientId\n      }); // **NOTE** - Remove this in a future major release as it is a breaking change\n      // Prevents _handleAuthResponse from being called multiple times in Expo\n      // See https://github.com/aws-amplify/amplify-js/issues/4388\n\n      var usedResponseUrls_1 = {};\n      urlListener(function (_a) {\n        var url = _a.url;\n\n        if (usedResponseUrls_1[url]) {\n          return;\n        }\n\n        usedResponseUrls_1[url] = true;\n\n        _this._handleAuthResponse(url);\n      });\n    }\n\n    dispatchAuthEvent('configured', null, \"The Auth category has been configured successfully\");\n\n    if (!this.autoSignInInitiated && typeof this._storage['getItem'] === 'function') {\n      var pollingInitiated = this.isTrueStorageValue('amplify-polling-started');\n\n      if (pollingInitiated) {\n        dispatchAuthEvent('autoSignIn_failure', null, AuthErrorTypes.AutoSignInError);\n\n        this._storage.removeItem('amplify-auto-sign-in');\n      }\n\n      this._storage.removeItem('amplify-polling-started');\n    }\n\n    return this._config;\n  };\n  /**\n   * Sign up with username, password and other attributes like phone, email\n   * @param {String | object} params - The user attributes used for signin\n   * @param {String[]} restOfAttrs - for the backward compatability\n   * @return - A promise resolves callback data if success\n   */\n\n\n  AuthClass.prototype.signUp = function (params) {\n    var _this = this;\n\n    var restOfAttrs = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      restOfAttrs[_i - 1] = arguments[_i];\n    }\n\n    var _a, _b, _c;\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    var username = null;\n    var password = null;\n    var attributes = [];\n    var validationData = null;\n    var clientMetadata;\n    var autoSignIn = {\n      enabled: false\n    };\n    var autoSignInValidationData = {};\n    var autoSignInClientMetaData = {};\n\n    if (params && typeof params === 'string') {\n      username = params;\n      password = restOfAttrs ? restOfAttrs[0] : null;\n      var email = restOfAttrs ? restOfAttrs[1] : null;\n      var phone_number = restOfAttrs ? restOfAttrs[2] : null;\n      if (email) attributes.push(new CognitoUserAttribute({\n        Name: 'email',\n        Value: email\n      }));\n      if (phone_number) attributes.push(new CognitoUserAttribute({\n        Name: 'phone_number',\n        Value: phone_number\n      }));\n    } else if (params && typeof params === 'object') {\n      username = params['username'];\n      password = params['password'];\n\n      if (params && params.clientMetadata) {\n        clientMetadata = params.clientMetadata;\n      } else if (this._config.clientMetadata) {\n        clientMetadata = this._config.clientMetadata;\n      }\n\n      var attrs_1 = params['attributes'];\n\n      if (attrs_1) {\n        Object.keys(attrs_1).map(function (key) {\n          attributes.push(new CognitoUserAttribute({\n            Name: key,\n            Value: attrs_1[key]\n          }));\n        });\n      }\n\n      var validationDataObject_1 = params['validationData'];\n\n      if (validationDataObject_1) {\n        validationData = [];\n        Object.keys(validationDataObject_1).map(function (key) {\n          validationData.push(new CognitoUserAttribute({\n            Name: key,\n            Value: validationDataObject_1[key]\n          }));\n        });\n      }\n\n      autoSignIn = (_a = params.autoSignIn) !== null && _a !== void 0 ? _a : {\n        enabled: false\n      };\n\n      if (autoSignIn.enabled) {\n        this._storage.setItem('amplify-auto-sign-in', 'true');\n\n        autoSignInValidationData = (_b = autoSignIn.validationData) !== null && _b !== void 0 ? _b : {};\n        autoSignInClientMetaData = (_c = autoSignIn.clientMetaData) !== null && _c !== void 0 ? _c : {};\n      }\n    } else {\n      return this.rejectAuthError(AuthErrorTypes.SignUpError);\n    }\n\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n\n    if (!password) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n    }\n\n    logger.debug('signUp attrs:', attributes);\n    logger.debug('signUp validation data:', validationData);\n    return new Promise(function (resolve, reject) {\n      _this.userPool.signUp(username, password, attributes, validationData, function (err, data) {\n        if (err) {\n          dispatchAuthEvent('signUp_failure', err, username + \" failed to signup\");\n          reject(err);\n        } else {\n          dispatchAuthEvent('signUp', data, username + \" has signed up successfully\");\n\n          if (autoSignIn.enabled) {\n            _this.handleAutoSignIn(username, password, autoSignInValidationData, autoSignInClientMetaData, data);\n          }\n\n          resolve(data);\n        }\n      }, clientMetadata);\n    });\n  };\n\n  AuthClass.prototype.handleAutoSignIn = function (username, password, validationData, clientMetadata, data) {\n    this.autoSignInInitiated = true;\n    var authDetails = new AuthenticationDetails({\n      Username: username,\n      Password: password,\n      ValidationData: validationData,\n      ClientMetadata: clientMetadata\n    });\n\n    if (data.userConfirmed) {\n      this.signInAfterUserConfirmed(authDetails);\n    } else if (this._config.signUpVerificationMethod === 'link') {\n      this.handleLinkAutoSignIn(authDetails);\n    } else {\n      this.handleCodeAutoSignIn(authDetails);\n    }\n  };\n\n  AuthClass.prototype.handleCodeAutoSignIn = function (authDetails) {\n    var _this = this;\n\n    var listenEvent = function (_a) {\n      var payload = _a.payload;\n\n      if (payload.event === 'confirmSignUp') {\n        _this.signInAfterUserConfirmed(authDetails, listenEvent);\n      }\n    };\n\n    Hub.listen('auth', listenEvent);\n  };\n\n  AuthClass.prototype.handleLinkAutoSignIn = function (authDetails) {\n    var _this = this;\n\n    this._storage.setItem('amplify-polling-started', 'true');\n\n    var start = Date.now();\n    var autoSignInPollingIntervalId = setInterval(function () {\n      if (Date.now() - start > MAX_AUTOSIGNIN_POLLING_MS) {\n        clearInterval(autoSignInPollingIntervalId);\n        dispatchAuthEvent('autoSignIn_failure', null, 'Please confirm your account and use your credentials to sign in.');\n\n        _this._storage.removeItem('amplify-auto-sign-in');\n      } else {\n        _this.signInAfterUserConfirmed(authDetails, null, autoSignInPollingIntervalId);\n      }\n    }, 5000);\n  };\n\n  AuthClass.prototype.signInAfterUserConfirmed = function (authDetails, listenEvent, autoSignInPollingIntervalId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var user, error_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            user = this.createCognitoUser(authDetails.getUsername());\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , user.authenticateUser(authDetails, this.authCallbacks(user, function (value) {\n              dispatchAuthEvent('autoSignIn', value, authDetails.getUsername() + \" has signed in successfully\");\n\n              if (listenEvent) {\n                Hub.remove('auth', listenEvent);\n              }\n\n              if (autoSignInPollingIntervalId) {\n                clearInterval(autoSignInPollingIntervalId);\n\n                _this._storage.removeItem('amplify-polling-started');\n              }\n\n              _this._storage.removeItem('amplify-auto-sign-in');\n            }, function (error) {\n              logger.error(error);\n\n              _this._storage.removeItem('amplify-auto-sign-in');\n            }))];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_1 = _a.sent();\n            logger.error(error_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Send the verification code to confirm sign up\n   * @param {String} username - The username to be confirmed\n   * @param {String} code - The verification code\n   * @param {ConfirmSignUpOptions} options - other options for confirm signup\n   * @return - A promise resolves callback data if success\n   */\n\n\n  AuthClass.prototype.confirmSignUp = function (username, code, options) {\n    var _this = this;\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n\n    var user = this.createCognitoUser(username);\n    var forceAliasCreation = options && typeof options.forceAliasCreation === 'boolean' ? options.forceAliasCreation : true;\n    var clientMetadata;\n\n    if (options && options.clientMetadata) {\n      clientMetadata = options.clientMetadata;\n    } else if (this._config.clientMetadata) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    return new Promise(function (resolve, reject) {\n      user.confirmRegistration(code, forceAliasCreation, function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          dispatchAuthEvent('confirmSignUp', data, username + \" has been confirmed successfully\");\n\n          var autoSignIn = _this.isTrueStorageValue('amplify-auto-sign-in');\n\n          if (autoSignIn && !_this.autoSignInInitiated) {\n            dispatchAuthEvent('autoSignIn_failure', null, AuthErrorTypes.AutoSignInError);\n\n            _this._storage.removeItem('amplify-auto-sign-in');\n          }\n\n          resolve(data);\n        }\n      }, clientMetadata);\n    });\n  };\n\n  AuthClass.prototype.isTrueStorageValue = function (value) {\n    var item = this._storage.getItem(value);\n\n    return item ? item === 'true' : false;\n  };\n  /**\n   * Resend the verification code\n   * @param {String} username - The username to be confirmed\n   * @param {ClientMetadata} clientMetadata - Metadata to be passed to Cognito Lambda triggers\n   * @return - A promise resolves code delivery details if successful\n   */\n\n\n  AuthClass.prototype.resendSignUp = function (username, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n\n    var user = this.createCognitoUser(username);\n    return new Promise(function (resolve, reject) {\n      user.resendConfirmationCode(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Sign in\n   * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n   * @param {String} pw - The password of the username\n   * @param {ClientMetaData} clientMetadata - Client metadata for custom workflows\n   * @return - A promise resolves the CognitoUser\n   */\n\n\n  AuthClass.prototype.signIn = function (usernameOrSignInOpts, pw, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    var username = null;\n    var password = null;\n    var validationData = {}; // for backward compatibility\n\n    if (typeof usernameOrSignInOpts === 'string') {\n      username = usernameOrSignInOpts;\n      password = pw;\n    } else if (isUsernamePasswordOpts(usernameOrSignInOpts)) {\n      if (typeof pw !== 'undefined') {\n        logger.warn('The password should be defined under the first parameter object!');\n      }\n\n      username = usernameOrSignInOpts.username;\n      password = usernameOrSignInOpts.password;\n      validationData = usernameOrSignInOpts.validationData;\n    } else {\n      return this.rejectAuthError(AuthErrorTypes.InvalidUsername);\n    }\n\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n\n    var authDetails = new AuthenticationDetails({\n      Username: username,\n      Password: password,\n      ValidationData: validationData,\n      ClientMetadata: clientMetadata\n    });\n\n    if (password) {\n      return this.signInWithPassword(authDetails);\n    } else {\n      return this.signInWithoutPassword(authDetails);\n    }\n  };\n  /**\n   * Return an object with the authentication callbacks\n   * @param {CognitoUser} user - the cognito user object\n   * @param {} resolve - function called when resolving the current step\n   * @param {} reject - function called when rejecting the current step\n   * @return - an object with the callback methods for user authentication\n   */\n\n\n  AuthClass.prototype.authCallbacks = function (user, resolve, reject) {\n    var _this = this;\n\n    var that = this;\n    return {\n      onSuccess: function (session) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var cred, e_1, currentUser, e_2;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                logger.debug(session);\n                delete user['challengeName'];\n                delete user['challengeParam'];\n                _a.label = 1;\n\n              case 1:\n                _a.trys.push([1, 4, 5, 9]);\n\n                return [4\n                /*yield*/\n                , this.Credentials.clear()];\n\n              case 2:\n                _a.sent();\n\n                return [4\n                /*yield*/\n                , this.Credentials.set(session, 'session')];\n\n              case 3:\n                cred = _a.sent();\n                logger.debug('succeed to get cognito credentials', cred);\n                return [3\n                /*break*/\n                , 9];\n\n              case 4:\n                e_1 = _a.sent();\n                logger.debug('cannot get cognito credentials', e_1);\n                return [3\n                /*break*/\n                , 9];\n\n              case 5:\n                _a.trys.push([5, 7,, 8]);\n\n                return [4\n                /*yield*/\n                , this.currentUserPoolUser()];\n\n              case 6:\n                currentUser = _a.sent();\n                that.user = currentUser;\n                dispatchAuthEvent('signIn', currentUser, \"A user \" + user.getUsername() + \" has been signed in\");\n                resolve(currentUser);\n                return [3\n                /*break*/\n                , 8];\n\n              case 7:\n                e_2 = _a.sent();\n                logger.error('Failed to get the signed in user', e_2);\n                reject(e_2);\n                return [3\n                /*break*/\n                , 8];\n\n              case 8:\n                return [7\n                /*endfinally*/\n                ];\n\n              case 9:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      },\n      onFailure: function (err) {\n        logger.debug('signIn failure', err);\n        dispatchAuthEvent('signIn_failure', err, user.getUsername() + \" failed to signin\");\n        reject(err);\n      },\n      customChallenge: function (challengeParam) {\n        logger.debug('signIn custom challenge answer required');\n        user['challengeName'] = 'CUSTOM_CHALLENGE';\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      mfaRequired: function (challengeName, challengeParam) {\n        logger.debug('signIn MFA required');\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      mfaSetup: function (challengeName, challengeParam) {\n        logger.debug('signIn mfa setup', challengeName);\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      newPasswordRequired: function (userAttributes, requiredAttributes) {\n        logger.debug('signIn new password');\n        user['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n        user['challengeParam'] = {\n          userAttributes: userAttributes,\n          requiredAttributes: requiredAttributes\n        };\n        resolve(user);\n      },\n      totpRequired: function (challengeName, challengeParam) {\n        logger.debug('signIn totpRequired');\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      },\n      selectMFAType: function (challengeName, challengeParam) {\n        logger.debug('signIn selectMFAType', challengeName);\n        user['challengeName'] = challengeName;\n        user['challengeParam'] = challengeParam;\n        resolve(user);\n      }\n    };\n  };\n  /**\n   * Sign in with a password\n   * @private\n   * @param {AuthenticationDetails} authDetails - the user sign in data\n   * @return - A promise resolves the CognitoUser object if success or mfa required\n   */\n\n\n  AuthClass.prototype.signInWithPassword = function (authDetails) {\n    var _this = this;\n\n    if (this.pendingSignIn) {\n      throw new Error('Pending sign-in attempt already in progress');\n    }\n\n    var user = this.createCognitoUser(authDetails.getUsername());\n    this.pendingSignIn = new Promise(function (resolve, reject) {\n      user.authenticateUser(authDetails, _this.authCallbacks(user, function (value) {\n        _this.pendingSignIn = null;\n        resolve(value);\n      }, function (error) {\n        _this.pendingSignIn = null;\n        reject(error);\n      }));\n    });\n    return this.pendingSignIn;\n  };\n  /**\n   * Sign in without a password\n   * @private\n   * @param {AuthenticationDetails} authDetails - the user sign in data\n   * @return - A promise resolves the CognitoUser object if success or mfa required\n   */\n\n\n  AuthClass.prototype.signInWithoutPassword = function (authDetails) {\n    var _this = this;\n\n    var user = this.createCognitoUser(authDetails.getUsername());\n    user.setAuthenticationFlowType('CUSTOM_AUTH');\n    return new Promise(function (resolve, reject) {\n      user.initiateAuth(authDetails, _this.authCallbacks(user, resolve, reject));\n    });\n  };\n  /**\n   * This was previously used by an authenticated user to get MFAOptions,\n   * but no longer returns a meaningful response. Refer to the documentation for\n   * how to setup and use MFA: https://docs.amplify.aws/lib/auth/mfa/q/platform/js\n   * @deprecated\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves the current preferred mfa option if success\n   */\n\n\n  AuthClass.prototype.getMFAOptions = function (user) {\n    return new Promise(function (res, rej) {\n      user.getMFAOptions(function (err, mfaOptions) {\n        if (err) {\n          logger.debug('get MFA Options failed', err);\n          rej(err);\n          return;\n        }\n\n        logger.debug('get MFA options success', mfaOptions);\n        res(mfaOptions);\n        return;\n      });\n    });\n  };\n  /**\n   * get preferred mfa method\n   * @param {CognitoUser} user - the current cognito user\n   * @param {GetPreferredMFAOpts} params - options for getting the current user preferred MFA\n   */\n\n\n  AuthClass.prototype.getPreferredMFA = function (user, params) {\n    var _this = this;\n\n    var that = this;\n    return new Promise(function (res, rej) {\n      var clientMetadata = _this._config.clientMetadata; // TODO: verify behavior if this is override during signIn\n\n      var bypassCache = params ? params.bypassCache : false;\n      user.getUserData(function (err, data) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var cleanUpError_1, mfaType;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!err) return [3\n                /*break*/\n                , 5];\n                logger.debug('getting preferred mfa failed', err);\n                if (!this.isSessionInvalid(err)) return [3\n                /*break*/\n                , 4];\n                _a.label = 1;\n\n              case 1:\n                _a.trys.push([1, 3,, 4]);\n\n                return [4\n                /*yield*/\n                , this.cleanUpInvalidSession(user)];\n\n              case 2:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 4];\n\n              case 3:\n                cleanUpError_1 = _a.sent();\n                rej(new Error(\"Session is invalid due to: \" + err.message + \" and failed to clean up invalid session: \" + cleanUpError_1.message));\n                return [2\n                /*return*/\n                ];\n\n              case 4:\n                rej(err);\n                return [2\n                /*return*/\n                ];\n\n              case 5:\n                mfaType = that._getMfaTypeFromUserData(data);\n\n                if (!mfaType) {\n                  rej('invalid MFA Type');\n                  return [2\n                  /*return*/\n                  ];\n                } else {\n                  res(mfaType);\n                  return [2\n                  /*return*/\n                  ];\n                }\n\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }, {\n        bypassCache: bypassCache,\n        clientMetadata: clientMetadata\n      });\n    });\n  };\n\n  AuthClass.prototype._getMfaTypeFromUserData = function (data) {\n    var ret = null;\n    var preferredMFA = data.PreferredMfaSetting; // if the user has used Auth.setPreferredMFA() to setup the mfa type\n    // then the \"PreferredMfaSetting\" would exist in the response\n\n    if (preferredMFA) {\n      ret = preferredMFA;\n    } else {\n      // if mfaList exists but empty, then its noMFA\n      var mfaList = data.UserMFASettingList;\n\n      if (!mfaList) {\n        // if SMS was enabled by using Auth.enableSMS(),\n        // the response would contain MFAOptions\n        // as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n        // if it does not exist, then it should be NOMFA\n        var MFAOptions = data.MFAOptions;\n\n        if (MFAOptions) {\n          ret = 'SMS_MFA';\n        } else {\n          ret = 'NOMFA';\n        }\n      } else if (mfaList.length === 0) {\n        ret = 'NOMFA';\n      } else {\n        logger.debug('invalid case for getPreferredMFA', data);\n      }\n    }\n\n    return ret;\n  };\n\n  AuthClass.prototype._getUserData = function (user, params) {\n    var _this = this;\n\n    return new Promise(function (res, rej) {\n      user.getUserData(function (err, data) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var cleanUpError_2;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!err) return [3\n                /*break*/\n                , 5];\n                logger.debug('getting user data failed', err);\n                if (!this.isSessionInvalid(err)) return [3\n                /*break*/\n                , 4];\n                _a.label = 1;\n\n              case 1:\n                _a.trys.push([1, 3,, 4]);\n\n                return [4\n                /*yield*/\n                , this.cleanUpInvalidSession(user)];\n\n              case 2:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 4];\n\n              case 3:\n                cleanUpError_2 = _a.sent();\n                rej(new Error(\"Session is invalid due to: \" + err.message + \" and failed to clean up invalid session: \" + cleanUpError_2.message));\n                return [2\n                /*return*/\n                ];\n\n              case 4:\n                rej(err);\n                return [2\n                /*return*/\n                ];\n\n              case 5:\n                res(data);\n                _a.label = 6;\n\n              case 6:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }, params);\n    });\n  };\n  /**\n   * set preferred MFA method\n   * @param {CognitoUser} user - the current Cognito user\n   * @param {string} mfaMethod - preferred mfa method\n   * @return - A promise resolve if success\n   */\n\n\n  AuthClass.prototype.setPreferredMFA = function (user, mfaMethod) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientMetadata, userData, smsMfaSettings, totpMfaSettings, _a, mfaList, currentMFAType, that;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            clientMetadata = this._config.clientMetadata;\n            return [4\n            /*yield*/\n            , this._getUserData(user, {\n              bypassCache: true,\n              clientMetadata: clientMetadata\n            })];\n\n          case 1:\n            userData = _b.sent();\n            smsMfaSettings = null;\n            totpMfaSettings = null;\n            _a = mfaMethod;\n\n            switch (_a) {\n              case 'TOTP':\n                return [3\n                /*break*/\n                , 2];\n\n              case 'SOFTWARE_TOKEN_MFA':\n                return [3\n                /*break*/\n                , 2];\n\n              case 'SMS':\n                return [3\n                /*break*/\n                , 3];\n\n              case 'SMS_MFA':\n                return [3\n                /*break*/\n                , 3];\n\n              case 'NOMFA':\n                return [3\n                /*break*/\n                , 4];\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 2:\n            totpMfaSettings = {\n              PreferredMfa: true,\n              Enabled: true\n            };\n            return [3\n            /*break*/\n            , 7];\n\n          case 3:\n            smsMfaSettings = {\n              PreferredMfa: true,\n              Enabled: true\n            };\n            return [3\n            /*break*/\n            , 7];\n\n          case 4:\n            mfaList = userData['UserMFASettingList'];\n            return [4\n            /*yield*/\n            , this._getMfaTypeFromUserData(userData)];\n\n          case 5:\n            currentMFAType = _b.sent();\n\n            if (currentMFAType === 'NOMFA') {\n              return [2\n              /*return*/\n              , Promise.resolve('No change for mfa type')];\n            } else if (currentMFAType === 'SMS_MFA') {\n              smsMfaSettings = {\n                PreferredMfa: false,\n                Enabled: false\n              };\n            } else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n              totpMfaSettings = {\n                PreferredMfa: false,\n                Enabled: false\n              };\n            } else {\n              return [2\n              /*return*/\n              , this.rejectAuthError(AuthErrorTypes.InvalidMFA)];\n            } // if there is a UserMFASettingList in the response\n            // we need to disable every mfa type in that list\n\n\n            if (mfaList && mfaList.length !== 0) {\n              // to disable SMS or TOTP if exists in that list\n              mfaList.forEach(function (mfaType) {\n                if (mfaType === 'SMS_MFA') {\n                  smsMfaSettings = {\n                    PreferredMfa: false,\n                    Enabled: false\n                  };\n                } else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n                  totpMfaSettings = {\n                    PreferredMfa: false,\n                    Enabled: false\n                  };\n                }\n              });\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            logger.debug('no validmfa method provided');\n            return [2\n            /*return*/\n            , this.rejectAuthError(AuthErrorTypes.NoMFA)];\n\n          case 7:\n            that = this;\n            return [2\n            /*return*/\n            , new Promise(function (res, rej) {\n              user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, function (err, result) {\n                if (err) {\n                  logger.debug('Set user mfa preference error', err);\n                  return rej(err);\n                }\n\n                logger.debug('Set user mfa success', result);\n                logger.debug('Caching the latest user data into local'); // cache the latest result into user data\n\n                user.getUserData(function (err, data) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var cleanUpError_3;\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          if (!err) return [3\n                          /*break*/\n                          , 5];\n                          logger.debug('getting user data failed', err);\n                          if (!this.isSessionInvalid(err)) return [3\n                          /*break*/\n                          , 4];\n                          _a.label = 1;\n\n                        case 1:\n                          _a.trys.push([1, 3,, 4]);\n\n                          return [4\n                          /*yield*/\n                          , this.cleanUpInvalidSession(user)];\n\n                        case 2:\n                          _a.sent();\n\n                          return [3\n                          /*break*/\n                          , 4];\n\n                        case 3:\n                          cleanUpError_3 = _a.sent();\n                          rej(new Error(\"Session is invalid due to: \" + err.message + \" and failed to clean up invalid session: \" + cleanUpError_3.message));\n                          return [2\n                          /*return*/\n                          ];\n\n                        case 4:\n                          return [2\n                          /*return*/\n                          , rej(err)];\n\n                        case 5:\n                          return [2\n                          /*return*/\n                          , res(result)];\n                      }\n                    });\n                  });\n                }, {\n                  bypassCache: true,\n                  clientMetadata: clientMetadata\n                });\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * disable SMS\n   * @deprecated\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves is success\n   */\n\n\n  AuthClass.prototype.disableSMS = function (user) {\n    return new Promise(function (res, rej) {\n      user.disableMFA(function (err, data) {\n        if (err) {\n          logger.debug('disable mfa failed', err);\n          rej(err);\n          return;\n        }\n\n        logger.debug('disable mfa succeed', data);\n        res(data);\n        return;\n      });\n    });\n  };\n  /**\n   * enable SMS\n   * @deprecated\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves is success\n   */\n\n\n  AuthClass.prototype.enableSMS = function (user) {\n    return new Promise(function (res, rej) {\n      user.enableMFA(function (err, data) {\n        if (err) {\n          logger.debug('enable mfa failed', err);\n          rej(err);\n          return;\n        }\n\n        logger.debug('enable mfa succeed', data);\n        res(data);\n        return;\n      });\n    });\n  };\n  /**\n   * Setup TOTP\n   * @param {CognitoUser} user - the current user\n   * @return - A promise resolves with the secret code if success\n   */\n\n\n  AuthClass.prototype.setupTOTP = function (user) {\n    return new Promise(function (res, rej) {\n      user.associateSoftwareToken({\n        onFailure: function (err) {\n          logger.debug('associateSoftwareToken failed', err);\n          rej(err);\n          return;\n        },\n        associateSecretCode: function (secretCode) {\n          logger.debug('associateSoftwareToken sucess', secretCode);\n          res(secretCode);\n          return;\n        }\n      });\n    });\n  };\n  /**\n   * verify TOTP setup\n   * @param {CognitoUser} user - the current user\n   * @param {string} challengeAnswer - challenge answer\n   * @return - A promise resolves is success\n   */\n\n\n  AuthClass.prototype.verifyTotpToken = function (user, challengeAnswer) {\n    logger.debug('verification totp token', user, challengeAnswer);\n    return new Promise(function (res, rej) {\n      user.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n        onFailure: function (err) {\n          logger.debug('verifyTotpToken failed', err);\n          rej(err);\n          return;\n        },\n        onSuccess: function (data) {\n          dispatchAuthEvent('signIn', user, \"A user \" + user.getUsername() + \" has been signed in\");\n          logger.debug('verifyTotpToken success', data);\n          res(data);\n          return;\n        }\n      });\n    });\n  };\n  /**\n   * Send MFA code to confirm sign in\n   * @param {Object} user - The CognitoUser object\n   * @param {String} code - The confirmation code\n   */\n\n\n  AuthClass.prototype.confirmSignIn = function (user, code, mfaType, clientMetadata) {\n    var _this = this;\n\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      user.sendMFACode(code, {\n        onSuccess: function (session) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var cred, e_3;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  logger.debug(session);\n                  _a.label = 1;\n\n                case 1:\n                  _a.trys.push([1, 4, 5, 6]);\n\n                  return [4\n                  /*yield*/\n                  , this.Credentials.clear()];\n\n                case 2:\n                  _a.sent();\n\n                  return [4\n                  /*yield*/\n                  , this.Credentials.set(session, 'session')];\n\n                case 3:\n                  cred = _a.sent();\n                  logger.debug('succeed to get cognito credentials', cred);\n                  return [3\n                  /*break*/\n                  , 6];\n\n                case 4:\n                  e_3 = _a.sent();\n                  logger.debug('cannot get cognito credentials', e_3);\n                  return [3\n                  /*break*/\n                  , 6];\n\n                case 5:\n                  that.user = user;\n                  dispatchAuthEvent('signIn', user, \"A user \" + user.getUsername() + \" has been signed in\");\n                  resolve(user);\n                  return [7\n                  /*endfinally*/\n                  ];\n\n                case 6:\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        },\n        onFailure: function (err) {\n          logger.debug('confirm signIn failure', err);\n          reject(err);\n        }\n      }, mfaType, clientMetadata);\n    });\n  };\n\n  AuthClass.prototype.completeNewPassword = function (user, password, requiredAttributes, clientMetadata) {\n    var _this = this;\n\n    if (requiredAttributes === void 0) {\n      requiredAttributes = {};\n    }\n\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    if (!password) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n    }\n\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      user.completeNewPasswordChallenge(password, requiredAttributes, {\n        onSuccess: function (session) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var cred, e_4;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  logger.debug(session);\n                  _a.label = 1;\n\n                case 1:\n                  _a.trys.push([1, 4, 5, 6]);\n\n                  return [4\n                  /*yield*/\n                  , this.Credentials.clear()];\n\n                case 2:\n                  _a.sent();\n\n                  return [4\n                  /*yield*/\n                  , this.Credentials.set(session, 'session')];\n\n                case 3:\n                  cred = _a.sent();\n                  logger.debug('succeed to get cognito credentials', cred);\n                  return [3\n                  /*break*/\n                  , 6];\n\n                case 4:\n                  e_4 = _a.sent();\n                  logger.debug('cannot get cognito credentials', e_4);\n                  return [3\n                  /*break*/\n                  , 6];\n\n                case 5:\n                  that.user = user;\n                  dispatchAuthEvent('signIn', user, \"A user \" + user.getUsername() + \" has been signed in\");\n                  resolve(user);\n                  return [7\n                  /*endfinally*/\n                  ];\n\n                case 6:\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        },\n        onFailure: function (err) {\n          logger.debug('completeNewPassword failure', err);\n          dispatchAuthEvent('completeNewPassword_failure', err, _this.user + \" failed to complete the new password flow\");\n          reject(err);\n        },\n        mfaRequired: function (challengeName, challengeParam) {\n          logger.debug('signIn MFA required');\n          user['challengeName'] = challengeName;\n          user['challengeParam'] = challengeParam;\n          resolve(user);\n        },\n        mfaSetup: function (challengeName, challengeParam) {\n          logger.debug('signIn mfa setup', challengeName);\n          user['challengeName'] = challengeName;\n          user['challengeParam'] = challengeParam;\n          resolve(user);\n        },\n        totpRequired: function (challengeName, challengeParam) {\n          logger.debug('signIn mfa setup', challengeName);\n          user['challengeName'] = challengeName;\n          user['challengeParam'] = challengeParam;\n          resolve(user);\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Send the answer to a custom challenge\n   * @param {CognitoUser} user - The CognitoUser object\n   * @param {String} challengeResponses - The confirmation code\n   */\n\n\n  AuthClass.prototype.sendCustomChallengeAnswer = function (user, challengeResponses, clientMetadata) {\n    var _this = this;\n\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    if (!challengeResponses) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyChallengeResponse);\n    }\n\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      user.sendCustomChallengeAnswer(challengeResponses, _this.authCallbacks(user, resolve, reject), clientMetadata);\n    });\n  };\n  /**\n   * Delete an authenticated users' attributes\n   * @param {CognitoUser} - The currently logged in user object\n   * @return {Promise}\n   **/\n\n\n  AuthClass.prototype.deleteUserAttributes = function (user, attributeNames) {\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      that.userSession(user).then(function (session) {\n        user.deleteAttributes(attributeNames, function (err, result) {\n          if (err) {\n            return reject(err);\n          } else {\n            return resolve(result);\n          }\n        });\n      });\n    });\n  };\n  /**\n   * Delete the current authenticated user\n   * @return {Promise}\n   **/\n  // TODO: Check return type void\n\n\n  AuthClass.prototype.deleteUser = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_5, isSignedInHostedUI;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this._storageSync];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            e_5 = _a.sent();\n            logger.debug('Failed to sync cache info into memory', e_5);\n            throw new Error(e_5);\n\n          case 3:\n            isSignedInHostedUI = this._oAuthHandler && this._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n            return [2\n            /*return*/\n            , new Promise(function (res, rej) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var user_1;\n\n                var _this = this;\n\n                return __generator(this, function (_a) {\n                  if (this.userPool) {\n                    user_1 = this.userPool.getCurrentUser();\n\n                    if (!user_1) {\n                      logger.debug('Failed to get user from user pool');\n                      return [2\n                      /*return*/\n                      , rej(new Error('No current user.'))];\n                    } else {\n                      user_1.getSession(function (err, session) {\n                        return __awaiter(_this, void 0, void 0, function () {\n                          var cleanUpError_4;\n\n                          var _this = this;\n\n                          return __generator(this, function (_a) {\n                            switch (_a.label) {\n                              case 0:\n                                if (!err) return [3\n                                /*break*/\n                                , 5];\n                                logger.debug('Failed to get the user session', err);\n                                if (!this.isSessionInvalid(err)) return [3\n                                /*break*/\n                                , 4];\n                                _a.label = 1;\n\n                              case 1:\n                                _a.trys.push([1, 3,, 4]);\n\n                                return [4\n                                /*yield*/\n                                , this.cleanUpInvalidSession(user_1)];\n\n                              case 2:\n                                _a.sent();\n\n                                return [3\n                                /*break*/\n                                , 4];\n\n                              case 3:\n                                cleanUpError_4 = _a.sent();\n                                rej(new Error(\"Session is invalid due to: \" + err.message + \" and failed to clean up invalid session: \" + cleanUpError_4.message));\n                                return [2\n                                /*return*/\n                                ];\n\n                              case 4:\n                                return [2\n                                /*return*/\n                                , rej(err)];\n\n                              case 5:\n                                user_1.deleteUser(function (err, result) {\n                                  if (err) {\n                                    rej(err);\n                                  } else {\n                                    dispatchAuthEvent('userDeleted', result, 'The authenticated user has been deleted.');\n                                    user_1.signOut();\n                                    _this.user = null;\n\n                                    try {\n                                      _this.cleanCachedItems(); // clean aws credentials\n\n                                    } catch (e) {\n                                      // TODO: change to rejects in refactor\n                                      logger.debug('failed to clear cached items');\n                                    }\n\n                                    if (isSignedInHostedUI) {\n                                      _this.oAuthSignOutRedirect(res, rej);\n                                    } else {\n                                      dispatchAuthEvent('signOut', _this.user, \"A user has been signed out\");\n                                      res(result);\n                                    }\n                                  }\n                                });\n                                _a.label = 6;\n\n                              case 6:\n                                return [2\n                                /*return*/\n                                ];\n                            }\n                          });\n                        });\n                      });\n                    }\n                  } else {\n                    logger.debug('no Congito User pool');\n                    rej(new Error('Cognito User pool does not exist'));\n                  }\n\n                  return [2\n                  /*return*/\n                  ];\n                });\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\n   * Update an authenticated users' attributes\n   * @param {CognitoUser} - The currently logged in user object\n   * @return {Promise}\n   **/\n\n\n  AuthClass.prototype.updateUserAttributes = function (user, attributes, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    var attributeList = [];\n    var that = this;\n    return new Promise(function (resolve, reject) {\n      that.userSession(user).then(function (session) {\n        for (var key in attributes) {\n          if (key !== 'sub' && key.indexOf('_verified') < 0) {\n            var attr = {\n              Name: key,\n              Value: attributes[key]\n            };\n            attributeList.push(attr);\n          }\n        }\n\n        user.updateAttributes(attributeList, function (err, result) {\n          if (err) {\n            return reject(err);\n          } else {\n            return resolve(result);\n          }\n        }, clientMetadata);\n      });\n    });\n  };\n  /**\n   * Return user attributes\n   * @param {Object} user - The CognitoUser object\n   * @return - A promise resolves to user attributes if success\n   */\n\n\n  AuthClass.prototype.userAttributes = function (user) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.userSession(user).then(function (session) {\n        user.getUserAttributes(function (err, attributes) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(attributes);\n          }\n        });\n      });\n    });\n  };\n\n  AuthClass.prototype.verifiedContact = function (user) {\n    var that = this;\n    return this.userAttributes(user).then(function (attributes) {\n      var attrs = that.attributesToObject(attributes);\n      var unverified = {};\n      var verified = {};\n\n      if (attrs['email']) {\n        if (attrs['email_verified']) {\n          verified['email'] = attrs['email'];\n        } else {\n          unverified['email'] = attrs['email'];\n        }\n      }\n\n      if (attrs['phone_number']) {\n        if (attrs['phone_number_verified']) {\n          verified['phone_number'] = attrs['phone_number'];\n        } else {\n          unverified['phone_number'] = attrs['phone_number'];\n        }\n      }\n\n      return {\n        verified: verified,\n        unverified: unverified\n      };\n    });\n  };\n\n  AuthClass.prototype.isErrorWithMessage = function (err) {\n    return typeof err === 'object' && Object.prototype.hasOwnProperty.call(err, 'message');\n  }; // Session revoked by another app\n\n\n  AuthClass.prototype.isTokenRevokedError = function (err) {\n    return this.isErrorWithMessage(err) && err.message === 'Access Token has been revoked';\n  };\n\n  AuthClass.prototype.isRefreshTokenRevokedError = function (err) {\n    return this.isErrorWithMessage(err) && err.message === 'Refresh Token has been revoked';\n  };\n\n  AuthClass.prototype.isUserDisabledError = function (err) {\n    return this.isErrorWithMessage(err) && err.message === 'User is disabled.';\n  };\n\n  AuthClass.prototype.isUserDoesNotExistError = function (err) {\n    return this.isErrorWithMessage(err) && err.message === 'User does not exist.';\n  };\n\n  AuthClass.prototype.isRefreshTokenExpiredError = function (err) {\n    return this.isErrorWithMessage(err) && err.message === 'Refresh Token has expired';\n  };\n\n  AuthClass.prototype.isSignedInHostedUI = function () {\n    return this._oAuthHandler && this._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n  };\n\n  AuthClass.prototype.isSessionInvalid = function (err) {\n    return this.isUserDisabledError(err) || this.isUserDoesNotExistError(err) || this.isTokenRevokedError(err) || this.isRefreshTokenRevokedError(err) || this.isRefreshTokenExpiredError(err);\n  };\n\n  AuthClass.prototype.cleanUpInvalidSession = function (user) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_6;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            user.signOut();\n            this.user = null;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.cleanCachedItems()];\n\n          case 2:\n            _a.sent(); // clean aws credentials\n\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_6 = _a.sent();\n            logger.debug('failed to clear cached items');\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (this.isSignedInHostedUI()) {\n              return [2\n              /*return*/\n              , new Promise(function (res, rej) {\n                _this.oAuthSignOutRedirect(res, rej);\n              })];\n            } else {\n              dispatchAuthEvent('signOut', this.user, \"A user has been signed out\");\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Get current authenticated user\n   * @return - A promise resolves to current authenticated CognitoUser if success\n   */\n\n\n  AuthClass.prototype.currentUserPoolUser = function (params) {\n    var _this = this;\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    return new Promise(function (res, rej) {\n      _this._storageSync.then(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var user, session, bypassCache, clientMetadata, _a, scope, err_1;\n\n          var _this = this;\n\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                if (!this.isOAuthInProgress()) return [3\n                /*break*/\n                , 2];\n                logger.debug('OAuth signIn in progress, waiting for resolution...');\n                return [4\n                /*yield*/\n                , new Promise(function (res) {\n                  var timeoutId = setTimeout(function () {\n                    logger.debug('OAuth signIn in progress timeout');\n                    Hub.remove('auth', hostedUISignCallback);\n                    res();\n                  }, OAUTH_FLOW_MS_TIMEOUT);\n                  Hub.listen('auth', hostedUISignCallback);\n\n                  function hostedUISignCallback(_a) {\n                    var payload = _a.payload;\n                    var event = payload.event;\n\n                    if (event === 'cognitoHostedUI' || event === 'cognitoHostedUI_failure') {\n                      logger.debug(\"OAuth signIn resolved: \" + event);\n                      clearTimeout(timeoutId);\n                      Hub.remove('auth', hostedUISignCallback);\n                      res();\n                    }\n                  }\n                })];\n\n              case 1:\n                _b.sent();\n\n                _b.label = 2;\n\n              case 2:\n                user = this.userPool.getCurrentUser();\n\n                if (!user) {\n                  logger.debug('Failed to get user from user pool');\n                  rej('No current user');\n                  return [2\n                  /*return*/\n                  ];\n                }\n\n                _b.label = 3;\n\n              case 3:\n                _b.trys.push([3, 7,, 8]);\n\n                return [4\n                /*yield*/\n                , this._userSession(user)];\n\n              case 4:\n                session = _b.sent();\n                bypassCache = params ? params.bypassCache : false;\n                if (!bypassCache) return [3\n                /*break*/\n                , 6];\n                return [4\n                /*yield*/\n                , this.Credentials.clear()];\n\n              case 5:\n                _b.sent();\n\n                _b.label = 6;\n\n              case 6:\n                clientMetadata = this._config.clientMetadata;\n                _a = session.getAccessToken().decodePayload().scope, scope = _a === void 0 ? '' : _a;\n\n                if (scope.split(' ').includes(USER_ADMIN_SCOPE)) {\n                  user.getUserData(function (err, data) {\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var cleanUpError_5, preferredMFA, attributeList, i, attribute, userAttribute, attributes;\n                      return __generator(this, function (_a) {\n                        switch (_a.label) {\n                          case 0:\n                            if (!err) return [3\n                            /*break*/\n                            , 7];\n                            logger.debug('getting user data failed', err);\n                            if (!this.isSessionInvalid(err)) return [3\n                            /*break*/\n                            , 5];\n                            _a.label = 1;\n\n                          case 1:\n                            _a.trys.push([1, 3,, 4]);\n\n                            return [4\n                            /*yield*/\n                            , this.cleanUpInvalidSession(user)];\n\n                          case 2:\n                            _a.sent();\n\n                            return [3\n                            /*break*/\n                            , 4];\n\n                          case 3:\n                            cleanUpError_5 = _a.sent();\n                            rej(new Error(\"Session is invalid due to: \" + err.message + \" and failed to clean up invalid session: \" + cleanUpError_5.message));\n                            return [2\n                            /*return*/\n                            ];\n\n                          case 4:\n                            rej(err);\n                            return [3\n                            /*break*/\n                            , 6];\n\n                          case 5:\n                            res(user);\n                            _a.label = 6;\n\n                          case 6:\n                            return [2\n                            /*return*/\n                            ];\n\n                          case 7:\n                            preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n                            attributeList = [];\n\n                            for (i = 0; i < data.UserAttributes.length; i++) {\n                              attribute = {\n                                Name: data.UserAttributes[i].Name,\n                                Value: data.UserAttributes[i].Value\n                              };\n                              userAttribute = new CognitoUserAttribute(attribute);\n                              attributeList.push(userAttribute);\n                            }\n\n                            attributes = this.attributesToObject(attributeList);\n                            Object.assign(user, {\n                              attributes: attributes,\n                              preferredMFA: preferredMFA\n                            });\n                            return [2\n                            /*return*/\n                            , res(user)];\n                        }\n                      });\n                    });\n                  }, {\n                    bypassCache: bypassCache,\n                    clientMetadata: clientMetadata\n                  });\n                } else {\n                  logger.debug(\"Unable to get the user data because the \" + USER_ADMIN_SCOPE + \" \" + \"is not in the scopes of the access token\");\n                  return [2\n                  /*return*/\n                  , res(user)];\n                }\n\n                return [3\n                /*break*/\n                , 8];\n\n              case 7:\n                err_1 = _b.sent();\n                rej(err_1);\n                return [3\n                /*break*/\n                , 8];\n\n              case 8:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }).catch(function (e) {\n        logger.debug('Failed to sync cache info into memory', e);\n        return rej(e);\n      });\n    });\n  };\n\n  AuthClass.prototype.isOAuthInProgress = function () {\n    return this.oAuthFlowInProgress;\n  };\n  /**\n   * Get current authenticated user\n   * @param {CurrentUserOpts} - options for getting the current user\n   * @return - A promise resolves to current authenticated CognitoUser if success\n   */\n\n\n  AuthClass.prototype.currentAuthenticatedUser = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var federatedUser, e_7, federatedInfo, user, e_8;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('getting current authenticated user');\n            federatedUser = null;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this._storageSync];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_7 = _a.sent();\n            logger.debug('Failed to sync cache info into memory', e_7);\n            throw e_7;\n\n          case 4:\n            try {\n              federatedInfo = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo'));\n\n              if (federatedInfo) {\n                federatedUser = __assign(__assign({}, federatedInfo.user), {\n                  token: federatedInfo.token\n                });\n              }\n            } catch (e) {\n              logger.debug('cannot load federated user from auth storage');\n            }\n\n            if (!federatedUser) return [3\n            /*break*/\n            , 5];\n            this.user = federatedUser;\n            logger.debug('get current authenticated federated user', this.user);\n            return [2\n            /*return*/\n            , this.user];\n\n          case 5:\n            logger.debug('get current authenticated userpool user');\n            user = null;\n            _a.label = 6;\n\n          case 6:\n            _a.trys.push([6, 8,, 9]);\n\n            return [4\n            /*yield*/\n            , this.currentUserPoolUser(params)];\n\n          case 7:\n            user = _a.sent();\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            e_8 = _a.sent();\n\n            if (e_8 === 'No userPool') {\n              logger.error('Cannot get the current user because the user pool is missing. ' + 'Please make sure the Auth module is configured with a valid Cognito User Pool ID');\n            }\n\n            logger.debug('The user is not authenticated by the error', e_8);\n            return [2\n            /*return*/\n            , Promise.reject('The user is not authenticated')];\n\n          case 9:\n            this.user = user;\n            return [2\n            /*return*/\n            , this.user];\n        }\n      });\n    });\n  };\n  /**\n   * Get current user's session\n   * @return - A promise resolves to session object if success\n   */\n\n\n  AuthClass.prototype.currentSession = function () {\n    var that = this;\n    logger.debug('Getting current session'); // Purposely not calling the reject method here because we don't need a console error\n\n    if (!this.userPool) {\n      return Promise.reject(new Error('No User Pool in the configuration.'));\n    }\n\n    return new Promise(function (res, rej) {\n      that.currentUserPoolUser().then(function (user) {\n        that.userSession(user).then(function (session) {\n          res(session);\n          return;\n        }).catch(function (e) {\n          logger.debug('Failed to get the current session', e);\n          rej(e);\n          return;\n        });\n      }).catch(function (e) {\n        logger.debug('Failed to get the current user', e);\n        rej(e);\n        return;\n      });\n    });\n  };\n\n  AuthClass.prototype._userSession = function (user) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientMetadata, userSession;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!user) {\n              logger.debug('the user is null');\n              return [2\n              /*return*/\n              , this.rejectAuthError(AuthErrorTypes.NoUserSession)];\n            }\n\n            clientMetadata = this._config.clientMetadata; // Debouncing the concurrent userSession calls by caching the promise.\n            // This solution assumes users will always call this function with the same CognitoUser instance.\n\n            if (this.inflightSessionPromiseCounter === 0) {\n              this.inflightSessionPromise = new Promise(function (res, rej) {\n                user.getSession(function (err, session) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var cleanUpError_6;\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          if (!err) return [3\n                          /*break*/\n                          , 5];\n                          logger.debug('Failed to get the session from user', user);\n                          if (!this.isSessionInvalid(err)) return [3\n                          /*break*/\n                          , 4];\n                          _a.label = 1;\n\n                        case 1:\n                          _a.trys.push([1, 3,, 4]);\n\n                          return [4\n                          /*yield*/\n                          , this.cleanUpInvalidSession(user)];\n\n                        case 2:\n                          _a.sent();\n\n                          return [3\n                          /*break*/\n                          , 4];\n\n                        case 3:\n                          cleanUpError_6 = _a.sent();\n                          rej(new Error(\"Session is invalid due to: \" + err.message + \" and failed to clean up invalid session: \" + cleanUpError_6.message));\n                          return [2\n                          /*return*/\n                          ];\n\n                        case 4:\n                          rej(err);\n                          return [2\n                          /*return*/\n                          ];\n\n                        case 5:\n                          logger.debug('Succeed to get the user session', session);\n                          res(session);\n                          return [2\n                          /*return*/\n                          ];\n                      }\n                    });\n                  });\n                }, {\n                  clientMetadata: clientMetadata\n                });\n              });\n            }\n\n            this.inflightSessionPromiseCounter++;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 3, 4]);\n\n            return [4\n            /*yield*/\n            , this.inflightSessionPromise];\n\n          case 2:\n            userSession = _a.sent(); // Set private member. Avoid user.setSignInUserSession() to prevent excessive localstorage refresh.\n            // @ts-ignore\n\n            user.signInUserSession = userSession;\n            return [2\n            /*return*/\n            , userSession];\n\n          case 3:\n            this.inflightSessionPromiseCounter--;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Get the corresponding user session\n   * @param {Object} user - The CognitoUser object\n   * @return - A promise resolves to the session\n   */\n\n\n  AuthClass.prototype.userSession = function (user) {\n    return this._userSession(user);\n  };\n  /**\n   * Get authenticated credentials of current user.\n   * @return - A promise resolves to be current user's credentials\n   */\n\n\n  AuthClass.prototype.currentUserCredentials = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_9, federatedInfo;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug('Getting current user credentials');\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this._storageSync];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_9 = _a.sent();\n            logger.debug('Failed to sync cache info into memory', e_9);\n            throw e_9;\n\n          case 4:\n            federatedInfo = null;\n\n            try {\n              federatedInfo = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo'));\n            } catch (e) {\n              logger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n            }\n\n            if (federatedInfo) {\n              // refresh the jwt token here if necessary\n              return [2\n              /*return*/\n              , this.Credentials.refreshFederatedToken(federatedInfo)];\n            } else {\n              return [2\n              /*return*/\n              , this.currentSession().then(function (session) {\n                logger.debug('getting session success', session);\n                return _this.Credentials.set(session, 'session');\n              }).catch(function () {\n                logger.debug('getting guest credentials');\n                return _this.Credentials.set(null, 'guest');\n              })];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.currentCredentials = function () {\n    logger.debug('getting current credentials');\n    return this.Credentials.get();\n  };\n  /**\n   * Initiate an attribute confirmation request\n   * @param {Object} user - The CognitoUser\n   * @param {Object} attr - The attributes to be verified\n   * @return - A promise resolves to callback data if success\n   */\n\n\n  AuthClass.prototype.verifyUserAttribute = function (user, attr, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    return new Promise(function (resolve, reject) {\n      user.getAttributeVerificationCode(attr, {\n        onSuccess: function (success) {\n          return resolve(success);\n        },\n        onFailure: function (err) {\n          return reject(err);\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Confirm an attribute using a confirmation code\n   * @param {Object} user - The CognitoUser\n   * @param {Object} attr - The attribute to be verified\n   * @param {String} code - The confirmation code\n   * @return - A promise resolves to callback data if success\n   */\n\n\n  AuthClass.prototype.verifyUserAttributeSubmit = function (user, attr, code) {\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n\n    return new Promise(function (resolve, reject) {\n      user.verifyAttribute(attr, code, {\n        onSuccess: function (data) {\n          resolve(data);\n          return;\n        },\n        onFailure: function (err) {\n          reject(err);\n          return;\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.verifyCurrentUserAttribute = function (attr) {\n    var that = this;\n    return that.currentUserPoolUser().then(function (user) {\n      return that.verifyUserAttribute(user, attr);\n    });\n  };\n  /**\n   * Confirm current user's attribute using a confirmation code\n   * @param {Object} attr - The attribute to be verified\n   * @param {String} code - The confirmation code\n   * @return - A promise resolves to callback data if success\n   */\n\n\n  AuthClass.prototype.verifyCurrentUserAttributeSubmit = function (attr, code) {\n    var that = this;\n    return that.currentUserPoolUser().then(function (user) {\n      return that.verifyUserAttributeSubmit(user, attr, code);\n    });\n  };\n\n  AuthClass.prototype.cognitoIdentitySignOut = function (opts, user) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_10, isSignedInHostedUI;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this._storageSync];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            e_10 = _a.sent();\n            logger.debug('Failed to sync cache info into memory', e_10);\n            throw e_10;\n\n          case 3:\n            isSignedInHostedUI = this._oAuthHandler && this._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n            return [2\n            /*return*/\n            , new Promise(function (res, rej) {\n              if (opts && opts.global) {\n                logger.debug('user global sign out', user); // in order to use global signout\n                // we must validate the user as an authenticated user by using getSession\n\n                var clientMetadata = _this._config.clientMetadata; // TODO: verify behavior if this is override during signIn\n\n                user.getSession(function (err, result) {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var cleanUpError_7;\n\n                    var _this = this;\n\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          if (!err) return [3\n                          /*break*/\n                          , 5];\n                          logger.debug('failed to get the user session', err);\n                          if (!this.isSessionInvalid(err)) return [3\n                          /*break*/\n                          , 4];\n                          _a.label = 1;\n\n                        case 1:\n                          _a.trys.push([1, 3,, 4]);\n\n                          return [4\n                          /*yield*/\n                          , this.cleanUpInvalidSession(user)];\n\n                        case 2:\n                          _a.sent();\n\n                          return [3\n                          /*break*/\n                          , 4];\n\n                        case 3:\n                          cleanUpError_7 = _a.sent();\n                          rej(new Error(\"Session is invalid due to: \" + err.message + \" and failed to clean up invalid session: \" + cleanUpError_7.message));\n                          return [2\n                          /*return*/\n                          ];\n\n                        case 4:\n                          return [2\n                          /*return*/\n                          , rej(err)];\n\n                        case 5:\n                          user.globalSignOut({\n                            onSuccess: function (data) {\n                              logger.debug('global sign out success');\n\n                              if (isSignedInHostedUI) {\n                                _this.oAuthSignOutRedirect(res, rej);\n                              } else {\n                                return res();\n                              }\n                            },\n                            onFailure: function (err) {\n                              logger.debug('global sign out failed', err);\n                              return rej(err);\n                            }\n                          });\n                          return [2\n                          /*return*/\n                          ];\n                      }\n                    });\n                  });\n                }, {\n                  clientMetadata: clientMetadata\n                });\n              } else {\n                logger.debug('user sign out', user);\n                user.signOut(function () {\n                  if (isSignedInHostedUI) {\n                    _this.oAuthSignOutRedirect(res, rej);\n                  } else {\n                    return res();\n                  }\n                });\n              }\n            })];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.oAuthSignOutRedirect = function (resolve, reject) {\n    var isBrowser = browserOrNode().isBrowser;\n\n    if (isBrowser) {\n      this.oAuthSignOutRedirectOrReject(reject);\n    } else {\n      this.oAuthSignOutAndResolve(resolve);\n    }\n  };\n\n  AuthClass.prototype.oAuthSignOutAndResolve = function (resolve) {\n    this._oAuthHandler.signOut();\n\n    resolve();\n  };\n\n  AuthClass.prototype.oAuthSignOutRedirectOrReject = function (reject) {\n    this._oAuthHandler.signOut(); // this method redirects url\n    // App should be redirected to another url otherwise it will reject\n\n\n    setTimeout(function () {\n      return reject(Error('Signout timeout fail'));\n    }, 3000);\n  };\n  /**\n   * Sign out method\n   * @\n   * @return - A promise resolved if success\n   */\n\n\n  AuthClass.prototype.signOut = function (opts) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_11, user;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.cleanCachedItems()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            e_11 = _a.sent();\n            logger.debug('failed to clear cached items');\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            if (!this.userPool) return [3\n            /*break*/\n            , 7];\n            user = this.userPool.getCurrentUser();\n            if (!user) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.cognitoIdentitySignOut(opts, user)];\n\n          case 4:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            logger.debug('no current Cognito user');\n            _a.label = 6;\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            logger.debug('no Cognito User pool');\n            _a.label = 8;\n\n          case 8:\n            /**\n             * Note for future refactor - no reliable way to get username with\n             * Cognito User Pools vs Identity when federating with Social Providers\n             * This is why we need a well structured session object that can be inspected\n             * and information passed back in the message below for Hub dispatch\n             */\n            dispatchAuthEvent('signOut', this.user, \"A user has been signed out\");\n            this.user = null;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.cleanCachedItems = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // clear cognito cached item\n            return [4\n            /*yield*/\n            , this.Credentials.clear()];\n\n          case 1:\n            // clear cognito cached item\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Change a password for an authenticated user\n   * @param {Object} user - The CognitoUser object\n   * @param {String} oldPassword - the current password\n   * @param {String} newPassword - the requested new password\n   * @return - A promise resolves if success\n   */\n\n\n  AuthClass.prototype.changePassword = function (user, oldPassword, newPassword, clientMetadata) {\n    var _this = this;\n\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    return new Promise(function (resolve, reject) {\n      _this.userSession(user).then(function (session) {\n        user.changePassword(oldPassword, newPassword, function (err, data) {\n          if (err) {\n            logger.debug('change password failure', err);\n            return reject(err);\n          } else {\n            return resolve(data);\n          }\n        }, clientMetadata);\n      });\n    });\n  };\n  /**\n   * Initiate a forgot password request\n   * @param {String} username - the username to change password\n   * @return - A promise resolves if success\n   */\n\n\n  AuthClass.prototype.forgotPassword = function (username, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n\n    var user = this.createCognitoUser(username);\n    return new Promise(function (resolve, reject) {\n      user.forgotPassword({\n        onSuccess: function () {\n          resolve();\n          return;\n        },\n        onFailure: function (err) {\n          logger.debug('forgot password failure', err);\n          dispatchAuthEvent('forgotPassword_failure', err, username + \" forgotPassword failed\");\n          reject(err);\n          return;\n        },\n        inputVerificationCode: function (data) {\n          dispatchAuthEvent('forgotPassword', user, username + \" has initiated forgot password flow\");\n          resolve(data);\n          return;\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Confirm a new password using a confirmation Code\n   * @param {String} username - The username\n   * @param {String} code - The confirmation code\n   * @param {String} password - The new password\n   * @return - A promise that resolves if success\n   */\n\n\n  AuthClass.prototype.forgotPasswordSubmit = function (username, code, password, clientMetadata) {\n    if (clientMetadata === void 0) {\n      clientMetadata = this._config.clientMetadata;\n    }\n\n    if (!this.userPool) {\n      return this.rejectNoUserPool();\n    }\n\n    if (!username) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n    }\n\n    if (!code) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyCode);\n    }\n\n    if (!password) {\n      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n    }\n\n    var user = this.createCognitoUser(username);\n    return new Promise(function (resolve, reject) {\n      user.confirmPassword(code, password, {\n        onSuccess: function (success) {\n          dispatchAuthEvent('forgotPasswordSubmit', user, username + \" forgotPasswordSubmit successful\");\n          resolve(success);\n          return;\n        },\n        onFailure: function (err) {\n          dispatchAuthEvent('forgotPasswordSubmit_failure', err, username + \" forgotPasswordSubmit failed\");\n          reject(err);\n          return;\n        }\n      }, clientMetadata);\n    });\n  };\n  /**\n   * Get user information\n   * @async\n   * @return {Object }- current User's information\n   */\n\n\n  AuthClass.prototype.currentUserInfo = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var source, user, attributes, userAttrs, credentials, e_12, info, err_2, user;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            source = this.Credentials.getCredSource();\n            if (!(!source || source === 'aws' || source === 'userPool')) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , this.currentUserPoolUser().catch(function (err) {\n              return logger.error(err);\n            })];\n\n          case 1:\n            user = _a.sent();\n\n            if (!user) {\n              return [2\n              /*return*/\n              , null];\n            }\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 8,, 9]);\n\n            return [4\n            /*yield*/\n            , this.userAttributes(user)];\n\n          case 3:\n            attributes = _a.sent();\n            userAttrs = this.attributesToObject(attributes);\n            credentials = null;\n            _a.label = 4;\n\n          case 4:\n            _a.trys.push([4, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this.currentCredentials()];\n\n          case 5:\n            credentials = _a.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            e_12 = _a.sent();\n            logger.debug('Failed to retrieve credentials while getting current user info', e_12);\n            return [3\n            /*break*/\n            , 7];\n\n          case 7:\n            info = {\n              id: credentials ? credentials.identityId : undefined,\n              username: user.getUsername(),\n              attributes: userAttrs\n            };\n            return [2\n            /*return*/\n            , info];\n\n          case 8:\n            err_2 = _a.sent();\n            logger.error('currentUserInfo error', err_2);\n            return [2\n            /*return*/\n            , {}];\n\n          case 9:\n            if (source === 'federated') {\n              user = this.user;\n              return [2\n              /*return*/\n              , user ? user : {}];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.federatedSignIn = function (providerOrOptions, response, user) {\n    return __awaiter(this, void 0, void 0, function () {\n      var options, provider, customState, client_id, redirect_uri, provider, loggedInUser, token, identity_id, expires_at, credentials, currentUser;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._config.identityPoolId && !this._config.userPoolId) {\n              throw new Error(\"Federation requires either a User Pool or Identity Pool in config\");\n            } // Ensure backwards compatability\n\n\n            if (typeof providerOrOptions === 'undefined') {\n              if (this._config.identityPoolId && !this._config.userPoolId) {\n                throw new Error(\"Federation with Identity Pools requires tokens passed as arguments\");\n              }\n            }\n\n            if (!(isFederatedSignInOptions(providerOrOptions) || isFederatedSignInOptionsCustom(providerOrOptions) || hasCustomState(providerOrOptions) || typeof providerOrOptions === 'undefined')) return [3\n            /*break*/\n            , 1];\n            options = providerOrOptions || {\n              provider: CognitoHostedUIIdentityProvider.Cognito\n            };\n            provider = isFederatedSignInOptions(options) ? options.provider : options.customProvider;\n            customState = isFederatedSignInOptions(options) ? options.customState : options.customState;\n\n            if (this._config.userPoolId) {\n              client_id = isCognitoHostedOpts(this._config.oauth) ? this._config.userPoolWebClientId : this._config.oauth.clientID;\n              redirect_uri = isCognitoHostedOpts(this._config.oauth) ? this._config.oauth.redirectSignIn : this._config.oauth.redirectUri;\n\n              this._oAuthHandler.oauthSignIn(this._config.oauth.responseType, this._config.oauth.domain, redirect_uri, client_id, provider, customState);\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 1:\n            provider = providerOrOptions; // To check if the user is already logged in\n\n            try {\n              loggedInUser = JSON.stringify(JSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user);\n\n              if (loggedInUser) {\n                logger.warn(\"There is already a signed in user: \" + loggedInUser + \" in your app.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tYou should not call Auth.federatedSignIn method again as it may cause unexpected behavior.\");\n              }\n            } catch (e) {}\n\n            token = response.token, identity_id = response.identity_id, expires_at = response.expires_at;\n            return [4\n            /*yield*/\n            , this.Credentials.set({\n              provider: provider,\n              token: token,\n              identity_id: identity_id,\n              user: user,\n              expires_at: expires_at\n            }, 'federation')];\n\n          case 2:\n            credentials = _a.sent();\n            return [4\n            /*yield*/\n            , this.currentAuthenticatedUser()];\n\n          case 3:\n            currentUser = _a.sent();\n            dispatchAuthEvent('signIn', currentUser, \"A user \" + currentUser.username + \" has been signed in\");\n            logger.debug('federated sign in credentials', credentials);\n            return [2\n            /*return*/\n            , credentials];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Used to complete the OAuth flow with or without the Cognito Hosted UI\n   * @param {String} URL - optional parameter for customers to pass in the response URL\n   */\n\n\n  AuthClass.prototype._handleAuthResponse = function (URL) {\n    return __awaiter(this, void 0, void 0, function () {\n      var currentUrl, hasCodeOrError, hasTokenOrError, _a, accessToken, idToken, refreshToken, state, session, credentials, isCustomStateIncluded, currentUser, customState, err_3;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (this.oAuthFlowInProgress) {\n              logger.debug(\"Skipping URL \" + URL + \" current flow in progress\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 8, 9]);\n\n            this.oAuthFlowInProgress = true;\n\n            if (!this._config.userPoolId) {\n              throw new Error(\"OAuth responses require a User Pool defined in config\");\n            }\n\n            dispatchAuthEvent('parsingCallbackUrl', {\n              url: URL\n            }, \"The callback url is being parsed\");\n            currentUrl = URL || (browserOrNode().isBrowser ? window.location.href : '');\n            hasCodeOrError = !!(parse(currentUrl).query || '').split('&').map(function (entry) {\n              return entry.split('=');\n            }).find(function (_a) {\n              var _b = __read(_a, 1),\n                  k = _b[0];\n\n              return k === 'code' || k === 'error';\n            });\n            hasTokenOrError = !!(parse(currentUrl).hash || '#').substr(1).split('&').map(function (entry) {\n              return entry.split('=');\n            }).find(function (_a) {\n              var _b = __read(_a, 1),\n                  k = _b[0];\n\n              return k === 'access_token' || k === 'error';\n            });\n            if (!(hasCodeOrError || hasTokenOrError)) return [3\n            /*break*/\n            , 7];\n\n            this._storage.setItem('amplify-redirected-from-hosted-ui', 'true');\n\n            _b.label = 2;\n\n          case 2:\n            _b.trys.push([2, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this._oAuthHandler.handleAuthResponse(currentUrl)];\n\n          case 3:\n            _a = _b.sent(), accessToken = _a.accessToken, idToken = _a.idToken, refreshToken = _a.refreshToken, state = _a.state;\n            session = new CognitoUserSession({\n              IdToken: new CognitoIdToken({\n                IdToken: idToken\n              }),\n              RefreshToken: new CognitoRefreshToken({\n                RefreshToken: refreshToken\n              }),\n              AccessToken: new CognitoAccessToken({\n                AccessToken: accessToken\n              })\n            });\n            credentials = void 0;\n            if (!this._config.identityPoolId) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.Credentials.set(session, 'session')];\n\n          case 4:\n            credentials = _b.sent();\n            logger.debug('AWS credentials', credentials);\n            _b.label = 5;\n\n          case 5:\n            isCustomStateIncluded = /-/.test(state);\n            currentUser = this.createCognitoUser(session.getIdToken().decodePayload()['cognito:username']); // This calls cacheTokens() in Cognito SDK\n\n            currentUser.setSignInUserSession(session);\n\n            if (window && typeof window.history !== 'undefined') {\n              window.history.replaceState({}, null, this._config.oauth.redirectSignIn);\n            }\n\n            dispatchAuthEvent('signIn', currentUser, \"A user \" + currentUser.getUsername() + \" has been signed in\");\n            dispatchAuthEvent('cognitoHostedUI', currentUser, \"A user \" + currentUser.getUsername() + \" has been signed in via Cognito Hosted UI\");\n\n            if (isCustomStateIncluded) {\n              customState = state.split('-').splice(1).join('-');\n              dispatchAuthEvent('customOAuthState', urlSafeDecode(customState), \"State for user \" + currentUser.getUsername());\n            } //#endregion\n\n\n            return [2\n            /*return*/\n            , credentials];\n\n          case 6:\n            err_3 = _b.sent();\n            logger.debug('Error in cognito hosted auth response', err_3); // Just like a successful handling of `?code`, replace the window history to \"dispose\" of the `code`.\n            // Otherwise, reloading the page will throw errors as the `code` has already been spent.\n\n            if (window && typeof window.history !== 'undefined') {\n              window.history.replaceState({}, null, this._config.oauth.redirectSignIn);\n            }\n\n            dispatchAuthEvent('signIn_failure', err_3, \"The OAuth response flow failed\");\n            dispatchAuthEvent('cognitoHostedUI_failure', err_3, \"A failure occurred when returning to the Cognito Hosted UI\");\n            dispatchAuthEvent('customState_failure', err_3, \"A failure occurred when returning state\");\n            return [3\n            /*break*/\n            , 7];\n\n          case 7:\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            this.oAuthFlowInProgress = false;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Compact version of credentials\n   * @param {Object} credentials\n   * @return {Object} - Credentials\n   */\n\n\n  AuthClass.prototype.essentialCredentials = function (credentials) {\n    return {\n      accessKeyId: credentials.accessKeyId,\n      sessionToken: credentials.sessionToken,\n      secretAccessKey: credentials.secretAccessKey,\n      identityId: credentials.identityId,\n      authenticated: credentials.authenticated\n    };\n  };\n\n  AuthClass.prototype.attributesToObject = function (attributes) {\n    var _this = this;\n\n    var obj = {};\n\n    if (attributes) {\n      attributes.map(function (attribute) {\n        if (attribute.Name === 'email_verified' || attribute.Name === 'phone_number_verified') {\n          obj[attribute.Name] = _this.isTruthyString(attribute.Value) || attribute.Value === true;\n        } else {\n          obj[attribute.Name] = attribute.Value;\n        }\n      });\n    }\n\n    return obj;\n  };\n\n  AuthClass.prototype.isTruthyString = function (value) {\n    return typeof value.toLowerCase === 'function' && value.toLowerCase() === 'true';\n  };\n\n  AuthClass.prototype.createCognitoUser = function (username) {\n    var userData = {\n      Username: username,\n      Pool: this.userPool\n    };\n    userData.Storage = this._storage;\n    var authenticationFlowType = this._config.authenticationFlowType;\n    var user = new CognitoUser(userData);\n\n    if (authenticationFlowType) {\n      user.setAuthenticationFlowType(authenticationFlowType);\n    }\n\n    return user;\n  };\n\n  AuthClass.prototype._isValidAuthStorage = function (obj) {\n    // We need to check if the obj has the functions of Storage\n    return !!obj && typeof obj.getItem === 'function' && typeof obj.setItem === 'function' && typeof obj.removeItem === 'function' && typeof obj.clear === 'function';\n  };\n\n  AuthClass.prototype.noUserPoolErrorHandler = function (config) {\n    if (config) {\n      if (!config.userPoolId || !config.identityPoolId) {\n        return AuthErrorTypes.MissingAuthConfig;\n      }\n    }\n\n    return AuthErrorTypes.NoConfig;\n  };\n\n  AuthClass.prototype.rejectAuthError = function (type) {\n    return Promise.reject(new AuthError(type));\n  };\n\n  AuthClass.prototype.rejectNoUserPool = function () {\n    var type = this.noUserPoolErrorHandler(this._config);\n    return Promise.reject(new NoUserPoolError(type));\n  };\n\n  AuthClass.prototype.rememberDevice = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var currUser, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.currentUserPoolUser()];\n\n          case 1:\n            currUser = _a.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_2 = _a.sent();\n            logger.debug('The user is not authenticated by the error', error_2);\n            return [2\n            /*return*/\n            , Promise.reject('The user is not authenticated')];\n\n          case 3:\n            currUser.getCachedDeviceKeyAndPassword();\n            return [2\n            /*return*/\n            , new Promise(function (res, rej) {\n              currUser.setDeviceStatusRemembered({\n                onSuccess: function (data) {\n                  res(data);\n                },\n                onFailure: function (err) {\n                  if (err.code === 'InvalidParameterException') {\n                    rej(new AuthError(AuthErrorTypes.DeviceConfig));\n                  } else if (err.code === 'NetworkError') {\n                    rej(new AuthError(AuthErrorTypes.NetworkError));\n                  } else {\n                    rej(err);\n                  }\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.forgetDevice = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var currUser, error_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.currentUserPoolUser()];\n\n          case 1:\n            currUser = _a.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_3 = _a.sent();\n            logger.debug('The user is not authenticated by the error', error_3);\n            return [2\n            /*return*/\n            , Promise.reject('The user is not authenticated')];\n\n          case 3:\n            currUser.getCachedDeviceKeyAndPassword();\n            return [2\n            /*return*/\n            , new Promise(function (res, rej) {\n              currUser.forgetDevice({\n                onSuccess: function (data) {\n                  res(data);\n                },\n                onFailure: function (err) {\n                  if (err.code === 'InvalidParameterException') {\n                    rej(new AuthError(AuthErrorTypes.DeviceConfig));\n                  } else if (err.code === 'NetworkError') {\n                    rej(new AuthError(AuthErrorTypes.NetworkError));\n                  } else {\n                    rej(err);\n                  }\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  AuthClass.prototype.fetchDevices = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var currUser, error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.currentUserPoolUser()];\n\n          case 1:\n            currUser = _a.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            error_4 = _a.sent();\n            logger.debug('The user is not authenticated by the error', error_4);\n            throw new Error('The user is not authenticated');\n\n          case 3:\n            currUser.getCachedDeviceKeyAndPassword();\n            return [2\n            /*return*/\n            , new Promise(function (res, rej) {\n              var cb = {\n                onSuccess: function (data) {\n                  var deviceList = data.Devices.map(function (device) {\n                    var deviceName = device.DeviceAttributes.find(function (_a) {\n                      var Name = _a.Name;\n                      return Name === 'device_name';\n                    }) || {};\n                    var deviceInfo = {\n                      id: device.DeviceKey,\n                      name: deviceName.Value\n                    };\n                    return deviceInfo;\n                  });\n                  res(deviceList);\n                },\n                onFailure: function (err) {\n                  if (err.code === 'InvalidParameterException') {\n                    rej(new AuthError(AuthErrorTypes.DeviceConfig));\n                  } else if (err.code === 'NetworkError') {\n                    rej(new AuthError(AuthErrorTypes.NetworkError));\n                  } else {\n                    rej(err);\n                  }\n                }\n              };\n              currUser.listDevices(MAX_DEVICES, null, cb);\n            })];\n        }\n      });\n    });\n  };\n\n  return AuthClass;\n}();\n\nexport { AuthClass };\nexport var Auth = new AuthClass(null);\nAmplify.register(Auth);","map":{"version":3,"mappings":"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","names":["isUsernamePasswordOpts","isCognitoHostedOpts","isFederatedSignInOptions","isFederatedSignInOptionsCustom","hasCustomState","Amplify","ConsoleLogger","Logger","Credentials","Hub","StorageHelper","browserOrNode","parseAWSExports","UniversalStorage","urlSafeDecode","CookieStorage","CognitoUserPool","AuthenticationDetails","CognitoUser","CognitoUserSession","CognitoUserAttribute","CognitoIdToken","CognitoRefreshToken","CognitoAccessToken","parse","OAuth","default","urlListener","AuthError","NoUserPoolError","AuthErrorTypes","CognitoHostedUIIdentityProvider","logger","USER_ADMIN_SCOPE","OAUTH_FLOW_MS_TIMEOUT","AMPLIFY_SYMBOL","Symbol","for","dispatchAuthEvent","event","data","message","dispatch","MAX_DEVICES","MAX_AUTOSIGNIN_POLLING_MS","config","callback","wrapped","error","undefined","configure","currentCredentials","bind","currentUserCredentials","listen","_a","payload","_this","_storage","setItem","removeItem","AuthClass","_config","debug","conf","Object","assign","Auth","userPoolId","userPoolWebClientId","cookieStorage","oauth","region","identityPoolId","mandatorySignIn","refreshHandlers","identityPoolRegion","clientMetadata","endpoint","storage","ssr","getStorage","_isValidAuthStorage","Error","_storageSync","Promise","resolve","userPoolData","UserPoolId","ClientId","Storage","userPool","wrapRefreshSessionCallback","cognitoHostedUIConfig","awsCognito","cognitoAuthParams","cognitoClientId","domain","scopes","redirectSignIn","redirectSignOut","responseType","urlOpener","_oAuthHandler","usedResponseUrls_1","url","_handleAuthResponse","autoSignInInitiated","pollingInitiated","isTrueStorageValue","AutoSignInError","params","restOfAttrs","rejectNoUserPool","username","password","attributes","validationData","autoSignIn","enabled","autoSignInValidationData","autoSignInClientMetaData","email","phone_number","push","Name","Value","attrs_1","keys","map","key","validationDataObject_1","_b","clientMetaData","_c","rejectAuthError","SignUpError","EmptyUsername","EmptyPassword","reject","signUp","err","handleAutoSignIn","authDetails","Username","Password","ValidationData","ClientMetadata","userConfirmed","signInAfterUserConfirmed","signUpVerificationMethod","handleLinkAutoSignIn","handleCodeAutoSignIn","listenEvent","start","Date","now","autoSignInPollingIntervalId","setInterval","clearInterval","user","createCognitoUser","getUsername","authenticateUser","authCallbacks","value","remove","error_1","code","options","EmptyCode","forceAliasCreation","confirmRegistration","item","getItem","resendConfirmationCode","usernameOrSignInOpts","pw","warn","InvalidUsername","signInWithPassword","signInWithoutPassword","that","onSuccess","session","clear","set","cred","e_1","currentUserPoolUser","currentUser","e_2","onFailure","customChallenge","challengeParam","mfaRequired","challengeName","mfaSetup","newPasswordRequired","userAttributes","requiredAttributes","totpRequired","selectMFAType","pendingSignIn","setAuthenticationFlowType","initiateAuth","res","rej","getMFAOptions","mfaOptions","bypassCache","getUserData","isSessionInvalid","cleanUpInvalidSession","cleanUpError_1","mfaType","_getMfaTypeFromUserData","ret","preferredMFA","PreferredMfaSetting","mfaList","UserMFASettingList","MFAOptions","length","cleanUpError_2","mfaMethod","_getUserData","userData","smsMfaSettings","totpMfaSettings","PreferredMfa","Enabled","currentMFAType","InvalidMFA","forEach","NoMFA","setUserMfaPreference","result","cleanUpError_3","disableMFA","enableMFA","associateSoftwareToken","associateSecretCode","secretCode","challengeAnswer","verifySoftwareToken","sendMFACode","e_3","completeNewPasswordChallenge","e_4","challengeResponses","EmptyChallengeResponse","sendCustomChallengeAnswer","attributeNames","userSession","then","deleteAttributes","e_5","isSignedInHostedUI","user_1","getCurrentUser","getSession","cleanUpError_4","deleteUser","signOut","cleanCachedItems","e","oAuthSignOutRedirect","attributeList","indexOf","attr","updateAttributes","getUserAttributes","attrs","attributesToObject","unverified","verified","prototype","hasOwnProperty","call","isErrorWithMessage","isUserDisabledError","isUserDoesNotExistError","isTokenRevokedError","isRefreshTokenRevokedError","isRefreshTokenExpiredError","isOAuthInProgress","timeoutId","setTimeout","hostedUISignCallback","clearTimeout","_userSession","getAccessToken","decodePayload","scope","split","includes","cleanUpError_5","i","UserAttributes","attribute","userAttribute","err_1","catch","oAuthFlowInProgress","federatedUser","e_7","federatedInfo","JSON","token","e_8","NoUserSession","inflightSessionPromiseCounter","inflightSessionPromise","cleanUpError_6","signInUserSession","e_9","refreshFederatedToken","currentSession","get","getAttributeVerificationCode","success","verifyAttribute","verifyUserAttribute","verifyUserAttributeSubmit","opts","e_10","global","cleanUpError_7","globalSignOut","isBrowser","oAuthSignOutRedirectOrReject","oAuthSignOutAndResolve","cognitoIdentitySignOut","oldPassword","newPassword","changePassword","forgotPassword","inputVerificationCode","confirmPassword","source","getCredSource","userAttrs","credentials","e_12","info","id","identityId","err_2","providerOrOptions","response","provider","Cognito","customProvider","customState","client_id","clientID","redirect_uri","redirectUri","oauthSignIn","loggedInUser","stringify","identity_id","expires_at","currentAuthenticatedUser","URL","currentUrl","window","location","href","hasCodeOrError","query","find","k","hasTokenOrError","hash","substr","handleAuthResponse","accessToken","idToken","refreshToken","state","IdToken","RefreshToken","AccessToken","isCustomStateIncluded","test","getIdToken","setSignInUserSession","history","replaceState","splice","join","err_3","accessKeyId","sessionToken","secretAccessKey","authenticated","obj","isTruthyString","toLowerCase","Pool","authenticationFlowType","MissingAuthConfig","NoConfig","type","noUserPoolErrorHandler","currUser","error_2","getCachedDeviceKeyAndPassword","setDeviceStatusRemembered","DeviceConfig","NetworkError","error_3","forgetDevice","error_4","cb","deviceList","Devices","deviceName","device","DeviceAttributes","deviceInfo","DeviceKey","name","listDevices","register"],"sources":["/home/dalienst/node_modules/@aws-amplify/auth/src/Auth.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tAuthOptions,\n\tFederatedResponse,\n\tSignUpParams,\n\tFederatedUser,\n\tConfirmSignUpOptions,\n\tSignOutOpts,\n\tCurrentUserOpts,\n\tGetPreferredMFAOpts,\n\tSignInOpts,\n\tisUsernamePasswordOpts,\n\tisCognitoHostedOpts,\n\tisFederatedSignInOptions,\n\tisFederatedSignInOptionsCustom,\n\thasCustomState,\n\tFederatedSignInOptionsCustom,\n\tLegacyProvider,\n\tFederatedSignInOptions,\n\tAwsCognitoOAuthOpts,\n\tClientMetaData,\n} from './types';\n\nimport {\n\tAmplify,\n\tConsoleLogger as Logger,\n\tCredentials,\n\tHub,\n\tStorageHelper,\n\tICredentials,\n\tbrowserOrNode,\n\tparseAWSExports,\n\tUniversalStorage,\n\turlSafeDecode,\n\tHubCallback,\n} from '@aws-amplify/core';\nimport {\n\tCookieStorage,\n\tCognitoUserPool,\n\tAuthenticationDetails,\n\tICognitoUserPoolData,\n\tICognitoUserData,\n\tISignUpResult,\n\tCognitoUser,\n\tMFAOption,\n\tCognitoUserSession,\n\tIAuthenticationCallback,\n\tICognitoUserAttributeData,\n\tCognitoUserAttribute,\n\tCognitoIdToken,\n\tCognitoRefreshToken,\n\tCognitoAccessToken,\n\tNodeCallback,\n} from 'amazon-cognito-identity-js';\n\nimport { parse } from 'url';\nimport OAuth from './OAuth/OAuth';\nimport { default as urlListener } from './urlListener';\nimport { AuthError, NoUserPoolError } from './Errors';\nimport {\n\tAuthErrorTypes,\n\tAutoSignInOptions,\n\tCognitoHostedUIIdentityProvider,\n\tIAuthDevice,\n} from './types/Auth';\n\nconst logger = new Logger('AuthClass');\nconst USER_ADMIN_SCOPE = 'aws.cognito.signin.user.admin';\n\n// 10 sec, following this guide https://www.nngroup.com/articles/response-times-3-important-limits/\nconst OAUTH_FLOW_MS_TIMEOUT = 10 * 1000;\n\nconst AMPLIFY_SYMBOL = (\n\ttypeof Symbol !== 'undefined' && typeof Symbol.for === 'function'\n\t\t? Symbol.for('amplify_default')\n\t\t: '@@amplify_default'\n) as Symbol;\n\nconst dispatchAuthEvent = (event: string, data: any, message: string) => {\n\tHub.dispatch('auth', { event, data, message }, 'Auth', AMPLIFY_SYMBOL);\n};\n\n// Cognito Documentation for max device\n// tslint:disable-next-line:max-line-length\n// https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_ListDevices.html#API_ListDevices_RequestSyntax\nconst MAX_DEVICES = 60;\n\nconst MAX_AUTOSIGNIN_POLLING_MS = 3 * 60 * 1000;\n\n/**\n * Provide authentication steps\n */\nexport class AuthClass {\n\tprivate _config: AuthOptions;\n\tprivate userPool: CognitoUserPool = null;\n\tprivate user: any = null;\n\tprivate _oAuthHandler: OAuth;\n\tprivate _storage;\n\tprivate _storageSync;\n\tprivate oAuthFlowInProgress: boolean = false;\n\tprivate pendingSignIn: ReturnType<AuthClass['signInWithPassword']> | null;\n\tprivate autoSignInInitiated: boolean = false;\n\tprivate inflightSessionPromise: Promise<CognitoUserSession> | null = null;\n\tprivate inflightSessionPromiseCounter: number = 0;\n\tCredentials = Credentials;\n\n\t/**\n\t * Initialize Auth with AWS configurations\n\t * @param {Object} config - Configuration of the Auth\n\t */\n\tconstructor(config: AuthOptions) {\n\t\tthis.configure(config);\n\t\tthis.currentCredentials = this.currentCredentials.bind(this);\n\t\tthis.currentUserCredentials = this.currentUserCredentials.bind(this);\n\n\t\tHub.listen('auth', ({ payload }) => {\n\t\t\tconst { event } = payload;\n\t\t\tswitch (event) {\n\t\t\t\tcase 'signIn':\n\t\t\t\t\tthis._storage.setItem('amplify-signin-with-hostedUI', 'false');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'signOut':\n\t\t\t\t\tthis._storage.removeItem('amplify-signin-with-hostedUI');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cognitoHostedUI':\n\t\t\t\t\tthis._storage.setItem('amplify-signin-with-hostedUI', 'true');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic getModuleName() {\n\t\treturn 'Auth';\n\t}\n\n\tconfigure(config?) {\n\t\tif (!config) return this._config || {};\n\t\tlogger.debug('configure Auth');\n\t\tconst conf = Object.assign(\n\t\t\t{},\n\t\t\tthis._config,\n\t\t\tparseAWSExports(config).Auth,\n\t\t\tconfig\n\t\t);\n\t\tthis._config = conf;\n\t\tconst {\n\t\t\tuserPoolId,\n\t\t\tuserPoolWebClientId,\n\t\t\tcookieStorage,\n\t\t\toauth,\n\t\t\tregion,\n\t\t\tidentityPoolId,\n\t\t\tmandatorySignIn,\n\t\t\trefreshHandlers,\n\t\t\tidentityPoolRegion,\n\t\t\tclientMetadata,\n\t\t\tendpoint,\n\t\t} = this._config;\n\n\t\tif (!this._config.storage) {\n\t\t\t// backward compatability\n\t\t\tif (cookieStorage) this._storage = new CookieStorage(cookieStorage);\n\t\t\telse {\n\t\t\t\tthis._storage = config.ssr\n\t\t\t\t\t? new UniversalStorage()\n\t\t\t\t\t: new StorageHelper().getStorage();\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this._isValidAuthStorage(this._config.storage)) {\n\t\t\t\tlogger.error('The storage in the Auth config is not valid!');\n\t\t\t\tthrow new Error('Empty storage object');\n\t\t\t}\n\t\t\tthis._storage = this._config.storage;\n\t\t}\n\n\t\tthis._storageSync = Promise.resolve();\n\t\tif (typeof this._storage['sync'] === 'function') {\n\t\t\tthis._storageSync = this._storage['sync']();\n\t\t}\n\n\t\tif (userPoolId) {\n\t\t\tconst userPoolData: ICognitoUserPoolData = {\n\t\t\t\tUserPoolId: userPoolId,\n\t\t\t\tClientId: userPoolWebClientId,\n\t\t\t\tendpoint,\n\t\t\t};\n\t\t\tuserPoolData.Storage = this._storage;\n\n\t\t\tthis.userPool = new CognitoUserPool(\n\t\t\t\tuserPoolData,\n\t\t\t\tthis.wrapRefreshSessionCallback\n\t\t\t);\n\t\t}\n\n\t\tthis.Credentials.configure({\n\t\t\tmandatorySignIn,\n\t\t\tregion: identityPoolRegion || region,\n\t\t\tuserPoolId,\n\t\t\tidentityPoolId,\n\t\t\trefreshHandlers,\n\t\t\tstorage: this._storage,\n\t\t});\n\n\t\t// initialize cognitoauth client if hosted ui options provided\n\t\t// to keep backward compatibility:\n\t\tconst cognitoHostedUIConfig = oauth\n\t\t\t? isCognitoHostedOpts(this._config.oauth)\n\t\t\t\t? oauth\n\t\t\t\t: (<any>oauth).awsCognito\n\t\t\t: undefined;\n\n\t\tif (cognitoHostedUIConfig) {\n\t\t\tconst cognitoAuthParams = Object.assign(\n\t\t\t\t{\n\t\t\t\t\tcognitoClientId: userPoolWebClientId,\n\t\t\t\t\tUserPoolId: userPoolId,\n\t\t\t\t\tdomain: cognitoHostedUIConfig['domain'],\n\t\t\t\t\tscopes: cognitoHostedUIConfig['scope'],\n\t\t\t\t\tredirectSignIn: cognitoHostedUIConfig['redirectSignIn'],\n\t\t\t\t\tredirectSignOut: cognitoHostedUIConfig['redirectSignOut'],\n\t\t\t\t\tresponseType: cognitoHostedUIConfig['responseType'],\n\t\t\t\t\tStorage: this._storage,\n\t\t\t\t\turlOpener: cognitoHostedUIConfig['urlOpener'],\n\t\t\t\t\tclientMetadata,\n\t\t\t\t},\n\t\t\t\tcognitoHostedUIConfig['options']\n\t\t\t);\n\n\t\t\tthis._oAuthHandler = new OAuth({\n\t\t\t\tscopes: cognitoAuthParams.scopes,\n\t\t\t\tconfig: cognitoAuthParams,\n\t\t\t\tcognitoClientId: cognitoAuthParams.cognitoClientId,\n\t\t\t});\n\n\t\t\t// **NOTE** - Remove this in a future major release as it is a breaking change\n\t\t\t// Prevents _handleAuthResponse from being called multiple times in Expo\n\t\t\t// See https://github.com/aws-amplify/amplify-js/issues/4388\n\t\t\tconst usedResponseUrls = {};\n\t\t\turlListener(({ url }) => {\n\t\t\t\tif (usedResponseUrls[url]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tusedResponseUrls[url] = true;\n\t\t\t\tthis._handleAuthResponse(url);\n\t\t\t});\n\t\t}\n\n\t\tdispatchAuthEvent(\n\t\t\t'configured',\n\t\t\tnull,\n\t\t\t`The Auth category has been configured successfully`\n\t\t);\n\n\t\tif (\n\t\t\t!this.autoSignInInitiated &&\n\t\t\ttypeof this._storage['getItem'] === 'function'\n\t\t) {\n\t\t\tconst pollingInitiated = this.isTrueStorageValue(\n\t\t\t\t'amplify-polling-started'\n\t\t\t);\n\t\t\tif (pollingInitiated) {\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'autoSignIn_failure',\n\t\t\t\t\tnull,\n\t\t\t\t\tAuthErrorTypes.AutoSignInError\n\t\t\t\t);\n\t\t\t\tthis._storage.removeItem('amplify-auto-sign-in');\n\t\t\t}\n\t\t\tthis._storage.removeItem('amplify-polling-started');\n\t\t}\n\t\treturn this._config;\n\t}\n\n\twrapRefreshSessionCallback = (callback: NodeCallback.Any) => {\n\t\tconst wrapped: NodeCallback.Any = (error, data) => {\n\t\t\tif (data) {\n\t\t\t\tdispatchAuthEvent('tokenRefresh', undefined, `New token retrieved`);\n\t\t\t} else {\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'tokenRefresh_failure',\n\t\t\t\t\terror,\n\t\t\t\t\t`Failed to retrieve new token`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn callback(error, data);\n\t\t};\n\t\treturn wrapped;\n\t} // prettier-ignore\n\n\t/**\n\t * Sign up with username, password and other attributes like phone, email\n\t * @param {String | object} params - The user attributes used for signin\n\t * @param {String[]} restOfAttrs - for the backward compatability\n\t * @return - A promise resolves callback data if success\n\t */\n\tpublic signUp(\n\t\tparams: string | SignUpParams,\n\t\t...restOfAttrs: string[]\n\t): Promise<ISignUpResult> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\n\t\tlet username: string = null;\n\t\tlet password: string = null;\n\t\tconst attributes: CognitoUserAttribute[] = [];\n\t\tlet validationData: CognitoUserAttribute[] = null;\n\t\tlet clientMetadata;\n\t\tlet autoSignIn: AutoSignInOptions = { enabled: false };\n\t\tlet autoSignInValidationData = {};\n\t\tlet autoSignInClientMetaData: ClientMetaData = {};\n\n\t\tif (params && typeof params === 'string') {\n\t\t\tusername = params;\n\t\t\tpassword = restOfAttrs ? restOfAttrs[0] : null;\n\t\t\tconst email: string = restOfAttrs ? restOfAttrs[1] : null;\n\t\t\tconst phone_number: string = restOfAttrs ? restOfAttrs[2] : null;\n\n\t\t\tif (email)\n\t\t\t\tattributes.push(\n\t\t\t\t\tnew CognitoUserAttribute({ Name: 'email', Value: email })\n\t\t\t\t);\n\n\t\t\tif (phone_number)\n\t\t\t\tattributes.push(\n\t\t\t\t\tnew CognitoUserAttribute({\n\t\t\t\t\t\tName: 'phone_number',\n\t\t\t\t\t\tValue: phone_number,\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t} else if (params && typeof params === 'object') {\n\t\t\tusername = params['username'];\n\t\t\tpassword = params['password'];\n\n\t\t\tif (params && params.clientMetadata) {\n\t\t\t\tclientMetadata = params.clientMetadata;\n\t\t\t} else if (this._config.clientMetadata) {\n\t\t\t\tclientMetadata = this._config.clientMetadata;\n\t\t\t}\n\n\t\t\tconst attrs = params['attributes'];\n\t\t\tif (attrs) {\n\t\t\t\tObject.keys(attrs).map(key => {\n\t\t\t\t\tattributes.push(\n\t\t\t\t\t\tnew CognitoUserAttribute({ Name: key, Value: attrs[key] })\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst validationDataObject = params['validationData'];\n\t\t\tif (validationDataObject) {\n\t\t\t\tvalidationData = [];\n\t\t\t\tObject.keys(validationDataObject).map(key => {\n\t\t\t\t\tvalidationData.push(\n\t\t\t\t\t\tnew CognitoUserAttribute({\n\t\t\t\t\t\t\tName: key,\n\t\t\t\t\t\t\tValue: validationDataObject[key],\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tautoSignIn = params.autoSignIn ?? { enabled: false };\n\t\t\tif (autoSignIn.enabled) {\n\t\t\t\tthis._storage.setItem('amplify-auto-sign-in', 'true');\n\t\t\t\tautoSignInValidationData = autoSignIn.validationData ?? {};\n\t\t\t\tautoSignInClientMetaData = autoSignIn.clientMetaData ?? {};\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.SignUpError);\n\t\t}\n\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tif (!password) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n\t\t}\n\n\t\tlogger.debug('signUp attrs:', attributes);\n\t\tlogger.debug('signUp validation data:', validationData);\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.userPool.signUp(\n\t\t\t\tusername,\n\t\t\t\tpassword,\n\t\t\t\tattributes,\n\t\t\t\tvalidationData,\n\t\t\t\t(err, data) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'signUp_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${username} failed to signup`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'signUp',\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t`${username} has signed up successfully`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (autoSignIn.enabled) {\n\t\t\t\t\t\t\tthis.handleAutoSignIn(\n\t\t\t\t\t\t\t\tusername,\n\t\t\t\t\t\t\t\tpassword,\n\t\t\t\t\t\t\t\tautoSignInValidationData,\n\t\t\t\t\t\t\t\tautoSignInClientMetaData,\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate handleAutoSignIn(\n\t\tusername: string,\n\t\tpassword: string,\n\t\tvalidationData: {},\n\t\tclientMetadata: any,\n\t\tdata: any\n\t) {\n\t\tthis.autoSignInInitiated = true;\n\t\tconst authDetails = new AuthenticationDetails({\n\t\t\tUsername: username,\n\t\t\tPassword: password,\n\t\t\tValidationData: validationData,\n\t\t\tClientMetadata: clientMetadata,\n\t\t});\n\t\tif (data.userConfirmed) {\n\t\t\tthis.signInAfterUserConfirmed(authDetails);\n\t\t} else if (this._config.signUpVerificationMethod === 'link') {\n\t\t\tthis.handleLinkAutoSignIn(authDetails);\n\t\t} else {\n\t\t\tthis.handleCodeAutoSignIn(authDetails);\n\t\t}\n\t}\n\n\tprivate handleCodeAutoSignIn(authDetails: AuthenticationDetails) {\n\t\tconst listenEvent = ({ payload }) => {\n\t\t\tif (payload.event === 'confirmSignUp') {\n\t\t\t\tthis.signInAfterUserConfirmed(authDetails, listenEvent);\n\t\t\t}\n\t\t};\n\t\tHub.listen('auth', listenEvent);\n\t}\n\n\tprivate handleLinkAutoSignIn(authDetails: AuthenticationDetails) {\n\t\tthis._storage.setItem('amplify-polling-started', 'true');\n\t\tconst start = Date.now();\n\t\tconst autoSignInPollingIntervalId = setInterval(() => {\n\t\t\tif (Date.now() - start > MAX_AUTOSIGNIN_POLLING_MS) {\n\t\t\t\tclearInterval(autoSignInPollingIntervalId);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'autoSignIn_failure',\n\t\t\t\t\tnull,\n\t\t\t\t\t'Please confirm your account and use your credentials to sign in.'\n\t\t\t\t);\n\t\t\t\tthis._storage.removeItem('amplify-auto-sign-in');\n\t\t\t} else {\n\t\t\t\tthis.signInAfterUserConfirmed(\n\t\t\t\t\tauthDetails,\n\t\t\t\t\tnull,\n\t\t\t\t\tautoSignInPollingIntervalId\n\t\t\t\t);\n\t\t\t}\n\t\t}, 5000);\n\t}\n\n\tprivate async signInAfterUserConfirmed(\n\t\tauthDetails: AuthenticationDetails,\n\t\tlistenEvent?: HubCallback,\n\t\tautoSignInPollingIntervalId?: ReturnType<typeof setInterval>\n\t) {\n\t\tconst user = this.createCognitoUser(authDetails.getUsername());\n\t\ttry {\n\t\t\tawait user.authenticateUser(\n\t\t\t\tauthDetails,\n\t\t\t\tthis.authCallbacks(\n\t\t\t\t\tuser,\n\t\t\t\t\tvalue => {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'autoSignIn',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t`${authDetails.getUsername()} has signed in successfully`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (listenEvent) {\n\t\t\t\t\t\t\tHub.remove('auth', listenEvent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (autoSignInPollingIntervalId) {\n\t\t\t\t\t\t\tclearInterval(autoSignInPollingIntervalId);\n\t\t\t\t\t\t\tthis._storage.removeItem('amplify-polling-started');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._storage.removeItem('amplify-auto-sign-in');\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tlogger.error(error);\n\t\t\t\t\t\tthis._storage.removeItem('amplify-auto-sign-in');\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.error(error);\n\t\t}\n\t}\n\n\t/**\n\t * Send the verification code to confirm sign up\n\t * @param {String} username - The username to be confirmed\n\t * @param {String} code - The verification code\n\t * @param {ConfirmSignUpOptions} options - other options for confirm signup\n\t * @return - A promise resolves callback data if success\n\t */\n\tpublic confirmSignUp(\n\t\tusername: string,\n\t\tcode: string,\n\t\toptions?: ConfirmSignUpOptions\n\t): Promise<any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\tconst forceAliasCreation =\n\t\t\toptions && typeof options.forceAliasCreation === 'boolean'\n\t\t\t\t? options.forceAliasCreation\n\t\t\t\t: true;\n\n\t\tlet clientMetadata;\n\t\tif (options && options.clientMetadata) {\n\t\t\tclientMetadata = options.clientMetadata;\n\t\t} else if (this._config.clientMetadata) {\n\t\t\tclientMetadata = this._config.clientMetadata;\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.confirmRegistration(\n\t\t\t\tcode,\n\t\t\t\tforceAliasCreation,\n\t\t\t\t(err, data) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'confirmSignUp',\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t`${username} has been confirmed successfully`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst autoSignIn = this.isTrueStorageValue('amplify-auto-sign-in');\n\t\t\t\t\t\tif (autoSignIn && !this.autoSignInInitiated) {\n\t\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t\t'autoSignIn_failure',\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tAuthErrorTypes.AutoSignInError\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis._storage.removeItem('amplify-auto-sign-in');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate isTrueStorageValue(value: string) {\n\t\tconst item = this._storage.getItem(value);\n\t\treturn item ? item === 'true' : false;\n\t}\n\n\t/**\n\t * Resend the verification code\n\t * @param {String} username - The username to be confirmed\n\t * @param {ClientMetadata} clientMetadata - Metadata to be passed to Cognito Lambda triggers\n\t * @return - A promise resolves code delivery details if successful\n\t */\n\tpublic resendSignUp(\n\t\tusername: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.resendConfirmationCode((err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t}, clientMetadata);\n\t\t});\n\t}\n\n\t/**\n\t * Sign in\n\t * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n\t * @param {String} pw - The password of the username\n\t * @param {ClientMetaData} clientMetadata - Client metadata for custom workflows\n\t * @return - A promise resolves the CognitoUser\n\t */\n\tpublic signIn(\n\t\tusernameOrSignInOpts: string | SignInOpts,\n\t\tpw?: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\n\t\tlet username = null;\n\t\tlet password = null;\n\t\tlet validationData = {};\n\n\t\t// for backward compatibility\n\t\tif (typeof usernameOrSignInOpts === 'string') {\n\t\t\tusername = usernameOrSignInOpts;\n\t\t\tpassword = pw;\n\t\t} else if (isUsernamePasswordOpts(usernameOrSignInOpts)) {\n\t\t\tif (typeof pw !== 'undefined') {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'The password should be defined under the first parameter object!'\n\t\t\t\t);\n\t\t\t}\n\t\t\tusername = usernameOrSignInOpts.username;\n\t\t\tpassword = usernameOrSignInOpts.password;\n\t\t\tvalidationData = usernameOrSignInOpts.validationData;\n\t\t} else {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.InvalidUsername);\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tconst authDetails = new AuthenticationDetails({\n\t\t\tUsername: username,\n\t\t\tPassword: password,\n\t\t\tValidationData: validationData,\n\t\t\tClientMetadata: clientMetadata,\n\t\t});\n\t\tif (password) {\n\t\t\treturn this.signInWithPassword(authDetails);\n\t\t} else {\n\t\t\treturn this.signInWithoutPassword(authDetails);\n\t\t}\n\t}\n\n\t/**\n\t * Return an object with the authentication callbacks\n\t * @param {CognitoUser} user - the cognito user object\n\t * @param {} resolve - function called when resolving the current step\n\t * @param {} reject - function called when rejecting the current step\n\t * @return - an object with the callback methods for user authentication\n\t */\n\tprivate authCallbacks(\n\t\tuser: CognitoUser,\n\t\tresolve: (value?: CognitoUser | any) => void,\n\t\treject: (value?: any) => void\n\t): IAuthenticationCallback {\n\t\tconst that = this;\n\t\treturn {\n\t\t\tonSuccess: async session => {\n\t\t\t\tlogger.debug(session);\n\t\t\t\tdelete user['challengeName'];\n\t\t\t\tdelete user['challengeParam'];\n\t\t\t\ttry {\n\t\t\t\t\tawait this.Credentials.clear();\n\t\t\t\t\tconst cred = await this.Credentials.set(session, 'session');\n\t\t\t\t\tlogger.debug('succeed to get cognito credentials', cred);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogger.debug('cannot get cognito credentials', e);\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// In order to get user attributes and MFA methods\n\t\t\t\t\t\t// We need to trigger currentUserPoolUser again\n\t\t\t\t\t\tconst currentUser = await this.currentUserPoolUser();\n\t\t\t\t\t\tthat.user = currentUser;\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'signIn',\n\t\t\t\t\t\t\tcurrentUser,\n\t\t\t\t\t\t\t`A user ${user.getUsername()} has been signed in`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve(currentUser);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tlogger.error('Failed to get the signed in user', e);\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonFailure: err => {\n\t\t\t\tlogger.debug('signIn failure', err);\n\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t'signIn_failure',\n\t\t\t\t\terr,\n\t\t\t\t\t`${user.getUsername()} failed to signin`\n\t\t\t\t);\n\t\t\t\treject(err);\n\t\t\t},\n\t\t\tcustomChallenge: challengeParam => {\n\t\t\t\tlogger.debug('signIn custom challenge answer required');\n\t\t\t\tuser['challengeName'] = 'CUSTOM_CHALLENGE';\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tmfaRequired: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn MFA required');\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tmfaSetup: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn mfa setup', challengeName);\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tnewPasswordRequired: (userAttributes, requiredAttributes) => {\n\t\t\t\tlogger.debug('signIn new password');\n\t\t\t\tuser['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n\t\t\t\tuser['challengeParam'] = {\n\t\t\t\t\tuserAttributes,\n\t\t\t\t\trequiredAttributes,\n\t\t\t\t};\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\ttotpRequired: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn totpRequired');\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t\tselectMFAType: (challengeName, challengeParam) => {\n\t\t\t\tlogger.debug('signIn selectMFAType', challengeName);\n\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\tresolve(user);\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Sign in with a password\n\t * @private\n\t * @param {AuthenticationDetails} authDetails - the user sign in data\n\t * @return - A promise resolves the CognitoUser object if success or mfa required\n\t */\n\tprivate signInWithPassword(\n\t\tauthDetails: AuthenticationDetails\n\t): Promise<CognitoUser | any> {\n\t\tif (this.pendingSignIn) {\n\t\t\tthrow new Error('Pending sign-in attempt already in progress');\n\t\t}\n\n\t\tconst user = this.createCognitoUser(authDetails.getUsername());\n\n\t\tthis.pendingSignIn = new Promise((resolve, reject) => {\n\t\t\tuser.authenticateUser(\n\t\t\t\tauthDetails,\n\t\t\t\tthis.authCallbacks(\n\t\t\t\t\tuser,\n\t\t\t\t\tvalue => {\n\t\t\t\t\t\tthis.pendingSignIn = null;\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tthis.pendingSignIn = null;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t);\n\t\t});\n\n\t\treturn this.pendingSignIn;\n\t}\n\n\t/**\n\t * Sign in without a password\n\t * @private\n\t * @param {AuthenticationDetails} authDetails - the user sign in data\n\t * @return - A promise resolves the CognitoUser object if success or mfa required\n\t */\n\tprivate signInWithoutPassword(\n\t\tauthDetails: AuthenticationDetails\n\t): Promise<CognitoUser | any> {\n\t\tconst user = this.createCognitoUser(authDetails.getUsername());\n\t\tuser.setAuthenticationFlowType('CUSTOM_AUTH');\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.initiateAuth(authDetails, this.authCallbacks(user, resolve, reject));\n\t\t});\n\t}\n\n\t/**\n\t * This was previously used by an authenticated user to get MFAOptions,\n\t * but no longer returns a meaningful response. Refer to the documentation for\n\t * how to setup and use MFA: https://docs.amplify.aws/lib/auth/mfa/q/platform/js\n\t * @deprecated\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves the current preferred mfa option if success\n\t */\n\tpublic getMFAOptions(user: CognitoUser | any): Promise<MFAOption[]> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.getMFAOptions((err, mfaOptions) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('get MFA Options failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlogger.debug('get MFA options success', mfaOptions);\n\t\t\t\tres(mfaOptions);\n\t\t\t\treturn;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * get preferred mfa method\n\t * @param {CognitoUser} user - the current cognito user\n\t * @param {GetPreferredMFAOpts} params - options for getting the current user preferred MFA\n\t */\n\tpublic getPreferredMFA(\n\t\tuser: CognitoUser | any,\n\t\tparams?: GetPreferredMFAOpts\n\t): Promise<string> {\n\t\tconst that = this;\n\t\treturn new Promise((res, rej) => {\n\t\t\tconst clientMetadata = this._config.clientMetadata; // TODO: verify behavior if this is override during signIn\n\n\t\t\tconst bypassCache = params ? params.bypassCache : false;\n\t\t\tuser.getUserData(\n\t\t\t\tasync (err, data) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tlogger.debug('getting preferred mfa failed', err);\n\t\t\t\t\t\tif (this.isSessionInvalid(err)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait this.cleanUpInvalidSession(user);\n\t\t\t\t\t\t\t} catch (cleanUpError) {\n\t\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t`Session is invalid due to: ${err.message} and failed to clean up invalid session: ${cleanUpError.message}`\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mfaType = that._getMfaTypeFromUserData(data);\n\t\t\t\t\tif (!mfaType) {\n\t\t\t\t\t\trej('invalid MFA Type');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(mfaType);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ bypassCache, clientMetadata }\n\t\t\t);\n\t\t});\n\t}\n\n\tprivate _getMfaTypeFromUserData(data) {\n\t\tlet ret = null;\n\t\tconst preferredMFA = data.PreferredMfaSetting;\n\t\t// if the user has used Auth.setPreferredMFA() to setup the mfa type\n\t\t// then the \"PreferredMfaSetting\" would exist in the response\n\t\tif (preferredMFA) {\n\t\t\tret = preferredMFA;\n\t\t} else {\n\t\t\t// if mfaList exists but empty, then its noMFA\n\t\t\tconst mfaList = data.UserMFASettingList;\n\t\t\tif (!mfaList) {\n\t\t\t\t// if SMS was enabled by using Auth.enableSMS(),\n\t\t\t\t// the response would contain MFAOptions\n\t\t\t\t// as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n\t\t\t\t// if it does not exist, then it should be NOMFA\n\t\t\t\tconst MFAOptions = data.MFAOptions;\n\t\t\t\tif (MFAOptions) {\n\t\t\t\t\tret = 'SMS_MFA';\n\t\t\t\t} else {\n\t\t\t\t\tret = 'NOMFA';\n\t\t\t\t}\n\t\t\t} else if (mfaList.length === 0) {\n\t\t\t\tret = 'NOMFA';\n\t\t\t} else {\n\t\t\t\tlogger.debug('invalid case for getPreferredMFA', data);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate _getUserData(user, params) {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.getUserData(async (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('getting user data failed', err);\n\t\t\t\t\tif (this.isSessionInvalid(err)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.cleanUpInvalidSession(user);\n\t\t\t\t\t\t} catch (cleanUpError) {\n\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`Session is invalid due to: ${err.message} and failed to clean up invalid session: ${cleanUpError.message}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tres(data);\n\t\t\t\t}\n\t\t\t}, params);\n\t\t});\n\t}\n\n\t/**\n\t * set preferred MFA method\n\t * @param {CognitoUser} user - the current Cognito user\n\t * @param {string} mfaMethod - preferred mfa method\n\t * @return - A promise resolve if success\n\t */\n\tpublic async setPreferredMFA(\n\t\tuser: CognitoUser | any,\n\t\tmfaMethod: 'TOTP' | 'SMS' | 'NOMFA' | 'SMS_MFA' | 'SOFTWARE_TOKEN_MFA'\n\t): Promise<string> {\n\t\tconst clientMetadata = this._config.clientMetadata; // TODO: verify behavior if this is override during signIn\n\n\t\tconst userData = await this._getUserData(user, {\n\t\t\tbypassCache: true,\n\t\t\tclientMetadata,\n\t\t});\n\t\tlet smsMfaSettings = null;\n\t\tlet totpMfaSettings = null;\n\n\t\tswitch (mfaMethod) {\n\t\t\tcase 'TOTP':\n\t\t\tcase 'SOFTWARE_TOKEN_MFA':\n\t\t\t\ttotpMfaSettings = {\n\t\t\t\t\tPreferredMfa: true,\n\t\t\t\t\tEnabled: true,\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'SMS':\n\t\t\tcase 'SMS_MFA':\n\t\t\t\tsmsMfaSettings = {\n\t\t\t\t\tPreferredMfa: true,\n\t\t\t\t\tEnabled: true,\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'NOMFA':\n\t\t\t\tconst mfaList = userData['UserMFASettingList'];\n\t\t\t\tconst currentMFAType = await this._getMfaTypeFromUserData(userData);\n\t\t\t\tif (currentMFAType === 'NOMFA') {\n\t\t\t\t\treturn Promise.resolve('No change for mfa type');\n\t\t\t\t} else if (currentMFAType === 'SMS_MFA') {\n\t\t\t\t\tsmsMfaSettings = {\n\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t};\n\t\t\t\t} else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n\t\t\t\t\ttotpMfaSettings = {\n\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn this.rejectAuthError(AuthErrorTypes.InvalidMFA);\n\t\t\t\t}\n\t\t\t\t// if there is a UserMFASettingList in the response\n\t\t\t\t// we need to disable every mfa type in that list\n\t\t\t\tif (mfaList && mfaList.length !== 0) {\n\t\t\t\t\t// to disable SMS or TOTP if exists in that list\n\t\t\t\t\tmfaList.forEach(mfaType => {\n\t\t\t\t\t\tif (mfaType === 'SMS_MFA') {\n\t\t\t\t\t\t\tsmsMfaSettings = {\n\t\t\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n\t\t\t\t\t\t\ttotpMfaSettings = {\n\t\t\t\t\t\t\t\tPreferredMfa: false,\n\t\t\t\t\t\t\t\tEnabled: false,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger.debug('no validmfa method provided');\n\t\t\t\treturn this.rejectAuthError(AuthErrorTypes.NoMFA);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise<string>((res, rej) => {\n\t\t\tuser.setUserMfaPreference(\n\t\t\t\tsmsMfaSettings,\n\t\t\t\ttotpMfaSettings,\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tlogger.debug('Set user mfa preference error', err);\n\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.debug('Set user mfa success', result);\n\t\t\t\t\tlogger.debug('Caching the latest user data into local');\n\t\t\t\t\t// cache the latest result into user data\n\t\t\t\t\tuser.getUserData(\n\t\t\t\t\t\tasync (err, data) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tlogger.debug('getting user data failed', err);\n\t\t\t\t\t\t\t\tif (this.isSessionInvalid(err)) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tawait this.cleanUpInvalidSession(user);\n\t\t\t\t\t\t\t\t\t} catch (cleanUpError) {\n\t\t\t\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`Session is invalid due to: ${err.message} and failed to clean up invalid session: ${cleanUpError.message}`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn res(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbypassCache: true,\n\t\t\t\t\t\t\tclientMetadata,\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * disable SMS\n\t * @deprecated\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves is success\n\t */\n\tpublic disableSMS(user: CognitoUser): Promise<string> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.disableMFA((err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('disable mfa failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlogger.debug('disable mfa succeed', data);\n\t\t\t\tres(data);\n\t\t\t\treturn;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * enable SMS\n\t * @deprecated\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves is success\n\t */\n\tpublic enableSMS(user: CognitoUser): Promise<string> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.enableMFA((err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tlogger.debug('enable mfa failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlogger.debug('enable mfa succeed', data);\n\t\t\t\tres(data);\n\t\t\t\treturn;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Setup TOTP\n\t * @param {CognitoUser} user - the current user\n\t * @return - A promise resolves with the secret code if success\n\t */\n\tpublic setupTOTP(user: CognitoUser | any): Promise<string> {\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.associateSoftwareToken({\n\t\t\t\tonFailure: err => {\n\t\t\t\t\tlogger.debug('associateSoftwareToken failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t\tassociateSecretCode: secretCode => {\n\t\t\t\t\tlogger.debug('associateSoftwareToken sucess', secretCode);\n\t\t\t\t\tres(secretCode);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * verify TOTP setup\n\t * @param {CognitoUser} user - the current user\n\t * @param {string} challengeAnswer - challenge answer\n\t * @return - A promise resolves is success\n\t */\n\tpublic verifyTotpToken(\n\t\tuser: CognitoUser | any,\n\t\tchallengeAnswer: string\n\t): Promise<CognitoUserSession> {\n\t\tlogger.debug('verification totp token', user, challengeAnswer);\n\t\treturn new Promise((res, rej) => {\n\t\t\tuser.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n\t\t\t\tonFailure: err => {\n\t\t\t\t\tlogger.debug('verifyTotpToken failed', err);\n\t\t\t\t\trej(err);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t\tonSuccess: data => {\n\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t'signIn',\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\t`A user ${user.getUsername()} has been signed in`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug('verifyTotpToken success', data);\n\t\t\t\t\tres(data);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Send MFA code to confirm sign in\n\t * @param {Object} user - The CognitoUser object\n\t * @param {String} code - The confirmation code\n\t */\n\tpublic confirmSignIn(\n\t\tuser: CognitoUser | any,\n\t\tcode: string,\n\t\tmfaType?: 'SMS_MFA' | 'SOFTWARE_TOKEN_MFA' | null,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.sendMFACode(\n\t\t\t\tcode,\n\t\t\t\t{\n\t\t\t\t\tonSuccess: async session => {\n\t\t\t\t\t\tlogger.debug(session);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.Credentials.clear();\n\t\t\t\t\t\t\tconst cred = await this.Credentials.set(session, 'session');\n\t\t\t\t\t\t\tlogger.debug('succeed to get cognito credentials', cred);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tlogger.debug('cannot get cognito credentials', e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tthat.user = user;\n\n\t\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t\t'signIn',\n\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t`A user ${user.getUsername()} has been signed in`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tlogger.debug('confirm signIn failure', err);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tmfaType,\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\tpublic completeNewPassword(\n\t\tuser: CognitoUser | any,\n\t\tpassword: string,\n\t\trequiredAttributes: any = {},\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!password) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.completeNewPasswordChallenge(\n\t\t\t\tpassword,\n\t\t\t\trequiredAttributes,\n\t\t\t\t{\n\t\t\t\t\tonSuccess: async session => {\n\t\t\t\t\t\tlogger.debug(session);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.Credentials.clear();\n\t\t\t\t\t\t\tconst cred = await this.Credentials.set(session, 'session');\n\t\t\t\t\t\t\tlogger.debug('succeed to get cognito credentials', cred);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tlogger.debug('cannot get cognito credentials', e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tthat.user = user;\n\t\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t\t'signIn',\n\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t`A user ${user.getUsername()} has been signed in`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tlogger.debug('completeNewPassword failure', err);\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'completeNewPassword_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${this.user} failed to complete the new password flow`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t},\n\t\t\t\t\tmfaRequired: (challengeName, challengeParam) => {\n\t\t\t\t\t\tlogger.debug('signIn MFA required');\n\t\t\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t},\n\t\t\t\t\tmfaSetup: (challengeName, challengeParam) => {\n\t\t\t\t\t\tlogger.debug('signIn mfa setup', challengeName);\n\t\t\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t},\n\t\t\t\t\ttotpRequired: (challengeName, challengeParam) => {\n\t\t\t\t\t\tlogger.debug('signIn mfa setup', challengeName);\n\t\t\t\t\t\tuser['challengeName'] = challengeName;\n\t\t\t\t\t\tuser['challengeParam'] = challengeParam;\n\t\t\t\t\t\tresolve(user);\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Send the answer to a custom challenge\n\t * @param {CognitoUser} user - The CognitoUser object\n\t * @param {String} challengeResponses - The confirmation code\n\t */\n\tpublic sendCustomChallengeAnswer(\n\t\tuser: CognitoUser | any,\n\t\tchallengeResponses: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<CognitoUser | any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!challengeResponses) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyChallengeResponse);\n\t\t}\n\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.sendCustomChallengeAnswer(\n\t\t\t\tchallengeResponses,\n\t\t\t\tthis.authCallbacks(user, resolve, reject),\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Delete an authenticated users' attributes\n\t * @param {CognitoUser} - The currently logged in user object\n\t * @return {Promise}\n\t **/\n\tpublic deleteUserAttributes(\n\t\tuser: CognitoUser | any,\n\t\tattributeNames: string[]\n\t) {\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthat.userSession(user).then(session => {\n\t\t\t\tuser.deleteAttributes(attributeNames, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn resolve(result);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Delete the current authenticated user\n\t * @return {Promise}\n\t **/\n\t// TODO: Check return type void\n\tpublic async deleteUser(): Promise<string | void> {\n\t\ttry {\n\t\t\tawait this._storageSync;\n\t\t} catch (e) {\n\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\tthrow new Error(e);\n\t\t}\n\n\t\tconst isSignedInHostedUI =\n\t\t\tthis._oAuthHandler &&\n\t\t\tthis._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n\n\t\treturn new Promise(async (res, rej) => {\n\t\t\tif (this.userPool) {\n\t\t\t\tconst user = this.userPool.getCurrentUser();\n\n\t\t\t\tif (!user) {\n\t\t\t\t\tlogger.debug('Failed to get user from user pool');\n\t\t\t\t\treturn rej(new Error('No current user.'));\n\t\t\t\t} else {\n\t\t\t\t\tuser.getSession(async (err, session) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tlogger.debug('Failed to get the user session', err);\n\t\t\t\t\t\t\tif (this.isSessionInvalid(err)) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait this.cleanUpInvalidSession(user);\n\t\t\t\t\t\t\t\t} catch (cleanUpError) {\n\t\t\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t`Session is invalid due to: ${err.message} and failed to clean up invalid session: ${cleanUpError.message}`\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuser.deleteUser((err, result: string) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\trej(err);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t\t\t\t'userDeleted',\n\t\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\t\t'The authenticated user has been deleted.'\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tuser.signOut();\n\t\t\t\t\t\t\t\t\tthis.user = null;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tthis.cleanCachedItems(); // clean aws credentials\n\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t// TODO: change to rejects in refactor\n\t\t\t\t\t\t\t\t\t\tlogger.debug('failed to clear cached items');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (isSignedInHostedUI) {\n\t\t\t\t\t\t\t\t\t\tthis.oAuthSignOutRedirect(res, rej);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t\t\t\t\t'signOut',\n\t\t\t\t\t\t\t\t\t\t\tthis.user,\n\t\t\t\t\t\t\t\t\t\t\t`A user has been signed out`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tres(result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.debug('no Congito User pool');\n\t\t\t\trej(new Error('Cognito User pool does not exist'));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Update an authenticated users' attributes\n\t * @param {CognitoUser} - The currently logged in user object\n\t * @return {Promise}\n\t **/\n\tpublic updateUserAttributes(\n\t\tuser: CognitoUser | any,\n\t\tattributes: object,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<string> {\n\t\tconst attributeList: ICognitoUserAttributeData[] = [];\n\t\tconst that = this;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthat.userSession(user).then(session => {\n\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\tif (key !== 'sub' && key.indexOf('_verified') < 0) {\n\t\t\t\t\t\tconst attr: ICognitoUserAttributeData = {\n\t\t\t\t\t\t\tName: key,\n\t\t\t\t\t\t\tValue: attributes[key],\n\t\t\t\t\t\t};\n\t\t\t\t\t\tattributeList.push(attr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuser.updateAttributes(\n\t\t\t\t\tattributeList,\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn resolve(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tclientMetadata\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\t/**\n\t * Return user attributes\n\t * @param {Object} user - The CognitoUser object\n\t * @return - A promise resolves to user attributes if success\n\t */\n\tpublic userAttributes(\n\t\tuser: CognitoUser | any\n\t): Promise<CognitoUserAttribute[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.userSession(user).then(session => {\n\t\t\t\tuser.getUserAttributes((err, attributes) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(attributes);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic verifiedContact(user: CognitoUser | any) {\n\t\tconst that = this;\n\t\treturn this.userAttributes(user).then(attributes => {\n\t\t\tconst attrs = that.attributesToObject(attributes);\n\t\t\tconst unverified = {};\n\t\t\tconst verified = {};\n\t\t\tif (attrs['email']) {\n\t\t\t\tif (attrs['email_verified']) {\n\t\t\t\t\tverified['email'] = attrs['email'];\n\t\t\t\t} else {\n\t\t\t\t\tunverified['email'] = attrs['email'];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (attrs['phone_number']) {\n\t\t\t\tif (attrs['phone_number_verified']) {\n\t\t\t\t\tverified['phone_number'] = attrs['phone_number'];\n\t\t\t\t} else {\n\t\t\t\t\tunverified['phone_number'] = attrs['phone_number'];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tverified,\n\t\t\t\tunverified,\n\t\t\t};\n\t\t});\n\t}\n\n\tprivate isErrorWithMessage(err: any): err is { message: string } {\n\t\treturn (\n\t\t\ttypeof err === 'object' &&\n\t\t\tObject.prototype.hasOwnProperty.call(err, 'message')\n\t\t);\n\t}\n\n\t// Session revoked by another app\n\tprivate isTokenRevokedError(\n\t\terr: any\n\t): err is { message: 'Access Token has been revoked' } {\n\t\treturn (\n\t\t\tthis.isErrorWithMessage(err) &&\n\t\t\terr.message === 'Access Token has been revoked'\n\t\t);\n\t}\n\n\tprivate isRefreshTokenRevokedError(\n\t\terr: any\n\t): err is { message: 'Refresh Token has been revoked' } {\n\t\treturn (\n\t\t\tthis.isErrorWithMessage(err) &&\n\t\t\terr.message === 'Refresh Token has been revoked'\n\t\t);\n\t}\n\n\tprivate isUserDisabledError(\n\t\terr: any\n\t): err is { message: 'User is disabled.' } {\n\t\treturn this.isErrorWithMessage(err) && err.message === 'User is disabled.';\n\t}\n\n\tprivate isUserDoesNotExistError(\n\t\terr: any\n\t): err is { message: 'User does not exist.' } {\n\t\treturn (\n\t\t\tthis.isErrorWithMessage(err) && err.message === 'User does not exist.'\n\t\t);\n\t}\n\n\tprivate isRefreshTokenExpiredError(\n\t\terr: any\n\t): err is { message: 'Refresh Token has expired' } {\n\t\treturn (\n\t\t\tthis.isErrorWithMessage(err) &&\n\t\t\terr.message === 'Refresh Token has expired'\n\t\t);\n\t}\n\n\tprivate isSignedInHostedUI() {\n\t\treturn (\n\t\t\tthis._oAuthHandler &&\n\t\t\tthis._storage.getItem('amplify-signin-with-hostedUI') === 'true'\n\t\t);\n\t}\n\n\tprivate isSessionInvalid(err: any) {\n\t\treturn (\n\t\t\tthis.isUserDisabledError(err) ||\n\t\t\tthis.isUserDoesNotExistError(err) ||\n\t\t\tthis.isTokenRevokedError(err) ||\n\t\t\tthis.isRefreshTokenRevokedError(err) ||\n\t\t\tthis.isRefreshTokenExpiredError(err)\n\t\t);\n\t}\n\n\tprivate async cleanUpInvalidSession(user: CognitoUser) {\n\t\tuser.signOut();\n\t\tthis.user = null;\n\t\ttry {\n\t\t\tawait this.cleanCachedItems(); // clean aws credentials\n\t\t} catch (e) {\n\t\t\tlogger.debug('failed to clear cached items');\n\t\t}\n\t\tif (this.isSignedInHostedUI()) {\n\t\t\treturn new Promise((res, rej) => {\n\t\t\t\tthis.oAuthSignOutRedirect(res, rej);\n\t\t\t});\n\t\t} else {\n\t\t\tdispatchAuthEvent('signOut', this.user, `A user has been signed out`);\n\t\t}\n\t}\n\n\t/**\n\t * Get current authenticated user\n\t * @return - A promise resolves to current authenticated CognitoUser if success\n\t */\n\tpublic currentUserPoolUser(\n\t\tparams?: CurrentUserOpts\n\t): Promise<CognitoUser | any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\n\t\treturn new Promise((res, rej) => {\n\t\t\tthis._storageSync\n\t\t\t\t.then(async () => {\n\t\t\t\t\tif (this.isOAuthInProgress()) {\n\t\t\t\t\t\tlogger.debug('OAuth signIn in progress, waiting for resolution...');\n\n\t\t\t\t\t\tawait new Promise(res => {\n\t\t\t\t\t\t\tconst timeoutId = setTimeout(() => {\n\t\t\t\t\t\t\t\tlogger.debug('OAuth signIn in progress timeout');\n\n\t\t\t\t\t\t\t\tHub.remove('auth', hostedUISignCallback);\n\n\t\t\t\t\t\t\t\tres();\n\t\t\t\t\t\t\t}, OAUTH_FLOW_MS_TIMEOUT);\n\n\t\t\t\t\t\t\tHub.listen('auth', hostedUISignCallback);\n\n\t\t\t\t\t\t\tfunction hostedUISignCallback({ payload }) {\n\t\t\t\t\t\t\t\tconst { event } = payload;\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tevent === 'cognitoHostedUI' ||\n\t\t\t\t\t\t\t\t\tevent === 'cognitoHostedUI_failure'\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tlogger.debug(`OAuth signIn resolved: ${event}`);\n\t\t\t\t\t\t\t\t\tclearTimeout(timeoutId);\n\n\t\t\t\t\t\t\t\t\tHub.remove('auth', hostedUISignCallback);\n\n\t\t\t\t\t\t\t\t\tres();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tconst user = this.userPool.getCurrentUser();\n\n\t\t\t\t\tif (!user) {\n\t\t\t\t\t\tlogger.debug('Failed to get user from user pool');\n\t\t\t\t\t\trej('No current user');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// refresh the session if the session expired.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst session = await this._userSession(user);\n\n\t\t\t\t\t\t// get user data from Cognito\n\t\t\t\t\t\tconst bypassCache = params ? params.bypassCache : false;\n\n\t\t\t\t\t\tif (bypassCache) {\n\t\t\t\t\t\t\tawait this.Credentials.clear();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst clientMetadata = this._config.clientMetadata;\n\n\t\t\t\t\t\t// validate the token's scope first before calling this function\n\t\t\t\t\t\tconst { scope = '' } = session.getAccessToken().decodePayload();\n\t\t\t\t\t\tif (scope.split(' ').includes(USER_ADMIN_SCOPE)) {\n\t\t\t\t\t\t\tuser.getUserData(\n\t\t\t\t\t\t\t\tasync (err, data) => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug('getting user data failed', err);\n\t\t\t\t\t\t\t\t\t\tif (this.isSessionInvalid(err)) {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tawait this.cleanUpInvalidSession(user);\n\t\t\t\t\t\t\t\t\t\t\t} catch (cleanUpError) {\n\t\t\t\t\t\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`Session is invalid due to: ${err.message} and failed to clean up invalid session: ${cleanUpError.message}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\trej(err);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tres(user);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n\t\t\t\t\t\t\t\t\tconst attributeList = [];\n\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < data.UserAttributes.length; i++) {\n\t\t\t\t\t\t\t\t\t\tconst attribute = {\n\t\t\t\t\t\t\t\t\t\t\tName: data.UserAttributes[i].Name,\n\t\t\t\t\t\t\t\t\t\t\tValue: data.UserAttributes[i].Value,\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tconst userAttribute = new CognitoUserAttribute(attribute);\n\t\t\t\t\t\t\t\t\t\tattributeList.push(userAttribute);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst attributes = this.attributesToObject(attributeList);\n\t\t\t\t\t\t\t\t\tObject.assign(user, { attributes, preferredMFA });\n\t\t\t\t\t\t\t\t\treturn res(user);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ bypassCache, clientMetadata }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t`Unable to get the user data because the ${USER_ADMIN_SCOPE} ` +\n\t\t\t\t\t\t\t\t\t`is not in the scopes of the access token`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn res(user);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(e => {\n\t\t\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\t\t\treturn rej(e);\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate isOAuthInProgress(): boolean {\n\t\treturn this.oAuthFlowInProgress;\n\t}\n\n\t/**\n\t * Get current authenticated user\n\t * @param {CurrentUserOpts} - options for getting the current user\n\t * @return - A promise resolves to current authenticated CognitoUser if success\n\t */\n\tpublic async currentAuthenticatedUser(\n\t\tparams?: CurrentUserOpts\n\t): Promise<CognitoUser | any> {\n\t\tlogger.debug('getting current authenticated user');\n\t\tlet federatedUser = null;\n\t\ttry {\n\t\t\tawait this._storageSync;\n\t\t} catch (e) {\n\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\tthrow e;\n\t\t}\n\n\t\ttry {\n\t\t\tconst federatedInfo = JSON.parse(\n\t\t\t\tthis._storage.getItem('aws-amplify-federatedInfo')\n\t\t\t);\n\t\t\tif (federatedInfo) {\n\t\t\t\tfederatedUser = {\n\t\t\t\t\t...federatedInfo.user,\n\t\t\t\t\ttoken: federatedInfo.token,\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tlogger.debug('cannot load federated user from auth storage');\n\t\t}\n\n\t\tif (federatedUser) {\n\t\t\tthis.user = federatedUser;\n\t\t\tlogger.debug('get current authenticated federated user', this.user);\n\t\t\treturn this.user;\n\t\t} else {\n\t\t\tlogger.debug('get current authenticated userpool user');\n\t\t\tlet user = null;\n\t\t\ttry {\n\t\t\t\tuser = await this.currentUserPoolUser(params);\n\t\t\t} catch (e) {\n\t\t\t\tif (e === 'No userPool') {\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'Cannot get the current user because the user pool is missing. ' +\n\t\t\t\t\t\t\t'Please make sure the Auth module is configured with a valid Cognito User Pool ID'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlogger.debug('The user is not authenticated by the error', e);\n\t\t\t\treturn Promise.reject('The user is not authenticated');\n\t\t\t}\n\t\t\tthis.user = user;\n\t\t\treturn this.user;\n\t\t}\n\t}\n\n\t/**\n\t * Get current user's session\n\t * @return - A promise resolves to session object if success\n\t */\n\tpublic currentSession(): Promise<CognitoUserSession> {\n\t\tconst that = this;\n\t\tlogger.debug('Getting current session');\n\t\t// Purposely not calling the reject method here because we don't need a console error\n\t\tif (!this.userPool) {\n\t\t\treturn Promise.reject(new Error('No User Pool in the configuration.'));\n\t\t}\n\n\t\treturn new Promise((res, rej) => {\n\t\t\tthat\n\t\t\t\t.currentUserPoolUser()\n\t\t\t\t.then(user => {\n\t\t\t\t\tthat\n\t\t\t\t\t\t.userSession(user)\n\t\t\t\t\t\t.then(session => {\n\t\t\t\t\t\t\tres(session);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(e => {\n\t\t\t\t\t\t\tlogger.debug('Failed to get the current session', e);\n\t\t\t\t\t\t\trej(e);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch(e => {\n\t\t\t\t\tlogger.debug('Failed to get the current user', e);\n\t\t\t\t\trej(e);\n\t\t\t\t\treturn;\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate async _userSession(user?: CognitoUser): Promise<CognitoUserSession> {\n\t\tif (!user) {\n\t\t\tlogger.debug('the user is null');\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.NoUserSession);\n\t\t}\n\t\tconst clientMetadata = this._config.clientMetadata;\n\t\t// Debouncing the concurrent userSession calls by caching the promise.\n\t\t// This solution assumes users will always call this function with the same CognitoUser instance.\n\t\tif (this.inflightSessionPromiseCounter === 0) {\n\t\t\tthis.inflightSessionPromise = new Promise<CognitoUserSession>(\n\t\t\t\t(res, rej) => {\n\t\t\t\t\tuser.getSession(\n\t\t\t\t\t\tasync (err, session) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tlogger.debug('Failed to get the session from user', user);\n\t\t\t\t\t\t\t\tif (this.isSessionInvalid(err)) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tawait this.cleanUpInvalidSession(user);\n\t\t\t\t\t\t\t\t\t} catch (cleanUpError) {\n\t\t\t\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`Session is invalid due to: ${err.message} and failed to clean up invalid session: ${cleanUpError.message}`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trej(err);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.debug('Succeed to get the user session', session);\n\t\t\t\t\t\t\t\tres(session);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ clientMetadata }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tthis.inflightSessionPromiseCounter++;\n\n\t\ttry {\n\t\t\tconst userSession = await this.inflightSessionPromise;\n\t\t\t// Set private member. Avoid user.setSignInUserSession() to prevent excessive localstorage refresh.\n\t\t\t// @ts-ignore\n\t\t\tuser.signInUserSession = userSession;\n\t\t\treturn userSession!;\n\t\t} finally {\n\t\t\tthis.inflightSessionPromiseCounter--;\n\t\t}\n\t}\n\n\t/**\n\t * Get the corresponding user session\n\t * @param {Object} user - The CognitoUser object\n\t * @return - A promise resolves to the session\n\t */\n\tpublic userSession(user): Promise<CognitoUserSession> {\n\t\treturn this._userSession(user);\n\t}\n\n\t/**\n\t * Get authenticated credentials of current user.\n\t * @return - A promise resolves to be current user's credentials\n\t */\n\tpublic async currentUserCredentials(): Promise<ICredentials> {\n\t\tlogger.debug('Getting current user credentials');\n\n\t\ttry {\n\t\t\tawait this._storageSync;\n\t\t} catch (e) {\n\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\tthrow e;\n\t\t}\n\n\t\t// first to check whether there is federation info in the auth storage\n\t\tlet federatedInfo = null;\n\t\ttry {\n\t\t\tfederatedInfo = JSON.parse(\n\t\t\t\tthis._storage.getItem('aws-amplify-federatedInfo')\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tlogger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n\t\t}\n\n\t\tif (federatedInfo) {\n\t\t\t// refresh the jwt token here if necessary\n\t\t\treturn this.Credentials.refreshFederatedToken(federatedInfo);\n\t\t} else {\n\t\t\treturn this.currentSession()\n\t\t\t\t.then(session => {\n\t\t\t\t\tlogger.debug('getting session success', session);\n\t\t\t\t\treturn this.Credentials.set(session, 'session');\n\t\t\t\t})\n\t\t\t\t.catch(() => {\n\t\t\t\t\tlogger.debug('getting guest credentials');\n\t\t\t\t\treturn this.Credentials.set(null, 'guest');\n\t\t\t\t});\n\t\t}\n\t}\n\n\tpublic currentCredentials(): Promise<ICredentials> {\n\t\tlogger.debug('getting current credentials');\n\t\treturn this.Credentials.get();\n\t}\n\n\t/**\n\t * Initiate an attribute confirmation request\n\t * @param {Object} user - The CognitoUser\n\t * @param {Object} attr - The attributes to be verified\n\t * @return - A promise resolves to callback data if success\n\t */\n\tpublic verifyUserAttribute(\n\t\tuser: CognitoUser | any,\n\t\tattr: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.getAttributeVerificationCode(\n\t\t\t\tattr,\n\t\t\t\t{\n\t\t\t\t\tonSuccess(success) {\n\t\t\t\t\t\treturn resolve(success);\n\t\t\t\t\t},\n\t\t\t\t\tonFailure(err) {\n\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Confirm an attribute using a confirmation code\n\t * @param {Object} user - The CognitoUser\n\t * @param {Object} attr - The attribute to be verified\n\t * @param {String} code - The confirmation code\n\t * @return - A promise resolves to callback data if success\n\t */\n\tpublic verifyUserAttributeSubmit(\n\t\tuser: CognitoUser | any,\n\t\tattr: string,\n\t\tcode: string\n\t): Promise<string> {\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.verifyAttribute(attr, code, {\n\t\t\t\tonSuccess(data) {\n\t\t\t\t\tresolve(data);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t\tonFailure(err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic verifyCurrentUserAttribute(attr: string): Promise<void> {\n\t\tconst that = this;\n\t\treturn that\n\t\t\t.currentUserPoolUser()\n\t\t\t.then(user => that.verifyUserAttribute(user, attr));\n\t}\n\n\t/**\n\t * Confirm current user's attribute using a confirmation code\n\t * @param {Object} attr - The attribute to be verified\n\t * @param {String} code - The confirmation code\n\t * @return - A promise resolves to callback data if success\n\t */\n\tverifyCurrentUserAttributeSubmit(\n\t\tattr: string,\n\t\tcode: string\n\t): Promise<string> {\n\t\tconst that = this;\n\t\treturn that\n\t\t\t.currentUserPoolUser()\n\t\t\t.then(user => that.verifyUserAttributeSubmit(user, attr, code));\n\t}\n\n\tprivate async cognitoIdentitySignOut(\n\t\topts: SignOutOpts,\n\t\tuser: CognitoUser | any\n\t) {\n\t\ttry {\n\t\t\tawait this._storageSync;\n\t\t} catch (e) {\n\t\t\tlogger.debug('Failed to sync cache info into memory', e);\n\t\t\tthrow e;\n\t\t}\n\n\t\tconst isSignedInHostedUI =\n\t\t\tthis._oAuthHandler &&\n\t\t\tthis._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n\n\t\treturn new Promise((res, rej) => {\n\t\t\tif (opts && opts.global) {\n\t\t\t\tlogger.debug('user global sign out', user);\n\t\t\t\t// in order to use global signout\n\t\t\t\t// we must validate the user as an authenticated user by using getSession\n\t\t\t\tconst clientMetadata = this._config.clientMetadata; // TODO: verify behavior if this is override during signIn\n\n\t\t\t\tuser.getSession(\n\t\t\t\t\tasync (err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tlogger.debug('failed to get the user session', err);\n\t\t\t\t\t\t\tif (this.isSessionInvalid(err)) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tawait this.cleanUpInvalidSession(user);\n\t\t\t\t\t\t\t\t} catch (cleanUpError) {\n\t\t\t\t\t\t\t\t\trej(\n\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t`Session is invalid due to: ${err.message} and failed to clean up invalid session: ${cleanUpError.message}`\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuser.globalSignOut({\n\t\t\t\t\t\t\tonSuccess: data => {\n\t\t\t\t\t\t\t\tlogger.debug('global sign out success');\n\t\t\t\t\t\t\t\tif (isSignedInHostedUI) {\n\t\t\t\t\t\t\t\t\tthis.oAuthSignOutRedirect(res, rej);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn res();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\t\t\tlogger.debug('global sign out failed', err);\n\t\t\t\t\t\t\t\treturn rej(err);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\t{ clientMetadata }\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tlogger.debug('user sign out', user);\n\t\t\t\tuser.signOut(() => {\n\t\t\t\t\tif (isSignedInHostedUI) {\n\t\t\t\t\t\tthis.oAuthSignOutRedirect(res, rej);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn res();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate oAuthSignOutRedirect(\n\t\tresolve: () => void,\n\t\treject: (reason?: any) => void\n\t) {\n\t\tconst { isBrowser } = browserOrNode();\n\n\t\tif (isBrowser) {\n\t\t\tthis.oAuthSignOutRedirectOrReject(reject);\n\t\t} else {\n\t\t\tthis.oAuthSignOutAndResolve(resolve);\n\t\t}\n\t}\n\n\tprivate oAuthSignOutAndResolve(resolve: () => void) {\n\t\tthis._oAuthHandler.signOut();\n\t\tresolve();\n\t}\n\n\tprivate oAuthSignOutRedirectOrReject(reject: (reason?: any) => void) {\n\t\tthis._oAuthHandler.signOut(); // this method redirects url\n\n\t\t// App should be redirected to another url otherwise it will reject\n\t\tsetTimeout(() => reject(Error('Signout timeout fail')), 3000);\n\t}\n\n\t/**\n\t * Sign out method\n\t * @\n\t * @return - A promise resolved if success\n\t */\n\tpublic async signOut(opts?: SignOutOpts): Promise<any> {\n\t\ttry {\n\t\t\tawait this.cleanCachedItems();\n\t\t} catch (e) {\n\t\t\tlogger.debug('failed to clear cached items');\n\t\t}\n\n\t\tif (this.userPool) {\n\t\t\tconst user = this.userPool.getCurrentUser();\n\t\t\tif (user) {\n\t\t\t\tawait this.cognitoIdentitySignOut(opts, user);\n\t\t\t} else {\n\t\t\t\tlogger.debug('no current Cognito user');\n\t\t\t}\n\t\t} else {\n\t\t\tlogger.debug('no Cognito User pool');\n\t\t}\n\n\t\t/**\n\t\t * Note for future refactor - no reliable way to get username with\n\t\t * Cognito User Pools vs Identity when federating with Social Providers\n\t\t * This is why we need a well structured session object that can be inspected\n\t\t * and information passed back in the message below for Hub dispatch\n\t\t */\n\t\tdispatchAuthEvent('signOut', this.user, `A user has been signed out`);\n\t\tthis.user = null;\n\t}\n\n\tprivate async cleanCachedItems() {\n\t\t// clear cognito cached item\n\t\tawait this.Credentials.clear();\n\t}\n\n\t/**\n\t * Change a password for an authenticated user\n\t * @param {Object} user - The CognitoUser object\n\t * @param {String} oldPassword - the current password\n\t * @param {String} newPassword - the requested new password\n\t * @return - A promise resolves if success\n\t */\n\tpublic changePassword(\n\t\tuser: CognitoUser | any,\n\t\toldPassword: string,\n\t\tnewPassword: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<'SUCCESS'> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.userSession(user).then(session => {\n\t\t\t\tuser.changePassword(\n\t\t\t\t\toldPassword,\n\t\t\t\t\tnewPassword,\n\t\t\t\t\t(err, data) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tlogger.debug('change password failure', err);\n\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn resolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tclientMetadata\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Initiate a forgot password request\n\t * @param {String} username - the username to change password\n\t * @return - A promise resolves if success\n\t */\n\tpublic forgotPassword(\n\t\tusername: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<any> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.forgotPassword(\n\t\t\t\t{\n\t\t\t\t\tonSuccess: () => {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tlogger.debug('forgot password failure', err);\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPassword_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${username} forgotPassword failed`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t\tinputVerificationCode: data => {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPassword',\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t`${username} has initiated forgot password flow`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Confirm a new password using a confirmation Code\n\t * @param {String} username - The username\n\t * @param {String} code - The confirmation code\n\t * @param {String} password - The new password\n\t * @return - A promise that resolves if success\n\t */\n\tpublic forgotPasswordSubmit(\n\t\tusername: string,\n\t\tcode: string,\n\t\tpassword: string,\n\t\tclientMetadata: ClientMetaData = this._config.clientMetadata\n\t): Promise<string> {\n\t\tif (!this.userPool) {\n\t\t\treturn this.rejectNoUserPool();\n\t\t}\n\t\tif (!username) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyUsername);\n\t\t}\n\t\tif (!code) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyCode);\n\t\t}\n\t\tif (!password) {\n\t\t\treturn this.rejectAuthError(AuthErrorTypes.EmptyPassword);\n\t\t}\n\n\t\tconst user = this.createCognitoUser(username);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuser.confirmPassword(\n\t\t\t\tcode,\n\t\t\t\tpassword,\n\t\t\t\t{\n\t\t\t\t\tonSuccess: success => {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPasswordSubmit',\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t`${username} forgotPasswordSubmit successful`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve(success);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t\tonFailure: err => {\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'forgotPasswordSubmit_failure',\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t\t`${username} forgotPasswordSubmit failed`\n\t\t\t\t\t\t);\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tclientMetadata\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Get user information\n\t * @async\n\t * @return {Object }- current User's information\n\t */\n\tpublic async currentUserInfo() {\n\t\tconst source = this.Credentials.getCredSource();\n\n\t\tif (!source || source === 'aws' || source === 'userPool') {\n\t\t\tconst user = await this.currentUserPoolUser().catch(err =>\n\t\t\t\tlogger.error(err)\n\t\t\t);\n\t\t\tif (!user) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst attributes = await this.userAttributes(user);\n\t\t\t\tconst userAttrs: object = this.attributesToObject(attributes);\n\t\t\t\tlet credentials = null;\n\t\t\t\ttry {\n\t\t\t\t\tcredentials = await this.currentCredentials();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t'Failed to retrieve credentials while getting current user info',\n\t\t\t\t\t\te\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst info = {\n\t\t\t\t\tid: credentials ? credentials.identityId : undefined,\n\t\t\t\t\tusername: user.getUsername(),\n\t\t\t\t\tattributes: userAttrs,\n\t\t\t\t};\n\t\t\t\treturn info;\n\t\t\t} catch (err) {\n\t\t\t\tlogger.error('currentUserInfo error', err);\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\n\t\tif (source === 'federated') {\n\t\t\tconst user = this.user;\n\t\t\treturn user ? user : {};\n\t\t}\n\t}\n\n\tpublic async federatedSignIn(\n\t\toptions?: FederatedSignInOptions\n\t): Promise<ICredentials>;\n\tpublic async federatedSignIn(\n\t\tprovider: LegacyProvider,\n\t\tresponse: FederatedResponse,\n\t\tuser: FederatedUser\n\t): Promise<ICredentials>;\n\tpublic async federatedSignIn(\n\t\toptions?: FederatedSignInOptionsCustom\n\t): Promise<ICredentials>;\n\tpublic async federatedSignIn(\n\t\tproviderOrOptions:\n\t\t\t| LegacyProvider\n\t\t\t| FederatedSignInOptions\n\t\t\t| FederatedSignInOptionsCustom,\n\t\tresponse?: FederatedResponse,\n\t\tuser?: FederatedUser\n\t): Promise<ICredentials> {\n\t\tif (!this._config.identityPoolId && !this._config.userPoolId) {\n\t\t\tthrow new Error(\n\t\t\t\t`Federation requires either a User Pool or Identity Pool in config`\n\t\t\t);\n\t\t}\n\n\t\t// Ensure backwards compatability\n\t\tif (typeof providerOrOptions === 'undefined') {\n\t\t\tif (this._config.identityPoolId && !this._config.userPoolId) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Federation with Identity Pools requires tokens passed as arguments`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tisFederatedSignInOptions(providerOrOptions) ||\n\t\t\tisFederatedSignInOptionsCustom(providerOrOptions) ||\n\t\t\thasCustomState(providerOrOptions) ||\n\t\t\ttypeof providerOrOptions === 'undefined'\n\t\t) {\n\t\t\tconst options = providerOrOptions || {\n\t\t\t\tprovider: CognitoHostedUIIdentityProvider.Cognito,\n\t\t\t};\n\t\t\tconst provider = isFederatedSignInOptions(options)\n\t\t\t\t? options.provider\n\t\t\t\t: (options as FederatedSignInOptionsCustom).customProvider;\n\n\t\t\tconst customState = isFederatedSignInOptions(options)\n\t\t\t\t? options.customState\n\t\t\t\t: (options as FederatedSignInOptionsCustom).customState;\n\n\t\t\tif (this._config.userPoolId) {\n\t\t\t\tconst client_id = isCognitoHostedOpts(this._config.oauth)\n\t\t\t\t\t? this._config.userPoolWebClientId\n\t\t\t\t\t: this._config.oauth.clientID;\n\t\t\t\t/*Note: Invenstigate automatically adding trailing slash */\n\t\t\t\tconst redirect_uri = isCognitoHostedOpts(this._config.oauth)\n\t\t\t\t\t? this._config.oauth.redirectSignIn\n\t\t\t\t\t: this._config.oauth.redirectUri;\n\n\t\t\t\tthis._oAuthHandler.oauthSignIn(\n\t\t\t\t\tthis._config.oauth.responseType,\n\t\t\t\t\tthis._config.oauth.domain,\n\t\t\t\t\tredirect_uri,\n\t\t\t\t\tclient_id,\n\t\t\t\t\tprovider,\n\t\t\t\t\tcustomState\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst provider = providerOrOptions;\n\t\t\t// To check if the user is already logged in\n\t\t\ttry {\n\t\t\t\tconst loggedInUser = JSON.stringify(\n\t\t\t\t\tJSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user\n\t\t\t\t);\n\t\t\t\tif (loggedInUser) {\n\t\t\t\t\tlogger.warn(`There is already a signed in user: ${loggedInUser} in your app.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tYou should not call Auth.federatedSignIn method again as it may cause unexpected behavior.`);\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\n\t\t\tconst { token, identity_id, expires_at } = response;\n\t\t\t// Because this.Credentials.set would update the user info with identity id\n\t\t\t// So we need to retrieve the user again.\n\t\t\tconst credentials = await this.Credentials.set(\n\t\t\t\t{ provider, token, identity_id, user, expires_at },\n\t\t\t\t'federation'\n\t\t\t);\n\t\t\tconst currentUser = await this.currentAuthenticatedUser();\n\t\t\tdispatchAuthEvent(\n\t\t\t\t'signIn',\n\t\t\t\tcurrentUser,\n\t\t\t\t`A user ${currentUser.username} has been signed in`\n\t\t\t);\n\t\t\tlogger.debug('federated sign in credentials', credentials);\n\t\t\treturn credentials;\n\t\t}\n\t}\n\n\t/**\n\t * Used to complete the OAuth flow with or without the Cognito Hosted UI\n\t * @param {String} URL - optional parameter for customers to pass in the response URL\n\t */\n\tprivate async _handleAuthResponse(URL?: string) {\n\t\tif (this.oAuthFlowInProgress) {\n\t\t\tlogger.debug(`Skipping URL ${URL} current flow in progress`);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tthis.oAuthFlowInProgress = true;\n\t\t\tif (!this._config.userPoolId) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`OAuth responses require a User Pool defined in config`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tdispatchAuthEvent(\n\t\t\t\t'parsingCallbackUrl',\n\t\t\t\t{ url: URL },\n\t\t\t\t`The callback url is being parsed`\n\t\t\t);\n\n\t\t\tconst currentUrl =\n\t\t\t\tURL || (browserOrNode().isBrowser ? window.location.href : '');\n\n\t\t\tconst hasCodeOrError = !!(parse(currentUrl).query || '')\n\t\t\t\t.split('&')\n\t\t\t\t.map(entry => entry.split('='))\n\t\t\t\t.find(([k]) => k === 'code' || k === 'error');\n\n\t\t\tconst hasTokenOrError = !!(parse(currentUrl).hash || '#')\n\t\t\t\t.substr(1)\n\t\t\t\t.split('&')\n\t\t\t\t.map(entry => entry.split('='))\n\t\t\t\t.find(([k]) => k === 'access_token' || k === 'error');\n\n\t\t\tif (hasCodeOrError || hasTokenOrError) {\n\t\t\t\tthis._storage.setItem('amplify-redirected-from-hosted-ui', 'true');\n\t\t\t\ttry {\n\t\t\t\t\tconst { accessToken, idToken, refreshToken, state } =\n\t\t\t\t\t\tawait this._oAuthHandler.handleAuthResponse(currentUrl);\n\t\t\t\t\tconst session = new CognitoUserSession({\n\t\t\t\t\t\tIdToken: new CognitoIdToken({ IdToken: idToken }),\n\t\t\t\t\t\tRefreshToken: new CognitoRefreshToken({\n\t\t\t\t\t\t\tRefreshToken: refreshToken,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tAccessToken: new CognitoAccessToken({\n\t\t\t\t\t\t\tAccessToken: accessToken,\n\t\t\t\t\t\t}),\n\t\t\t\t\t});\n\n\t\t\t\t\tlet credentials;\n\t\t\t\t\t// Get AWS Credentials & store if Identity Pool is defined\n\t\t\t\t\tif (this._config.identityPoolId) {\n\t\t\t\t\t\tcredentials = await this.Credentials.set(session, 'session');\n\t\t\t\t\t\tlogger.debug('AWS credentials', credentials);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\tPrior to the request we do sign the custom state along with the state we set. This check will verify\n\t\t\t\tif there is a dash indicated when setting custom state from the request. If a dash is contained\n\t\t\t\tthen there is custom state present on the state string.\n\t\t\t\t*/\n\t\t\t\t\tconst isCustomStateIncluded = /-/.test(state);\n\n\t\t\t\t\t/*\n\t\t\t\tThe following is to create a user for the Cognito Identity SDK to store the tokens\n\t\t\t\tWhen we remove this SDK later that logic will have to be centralized in our new version\n\t\t\t\t*/\n\t\t\t\t\t//#region\n\t\t\t\t\tconst currentUser = this.createCognitoUser(\n\t\t\t\t\t\tsession.getIdToken().decodePayload()['cognito:username']\n\t\t\t\t\t);\n\n\t\t\t\t\t// This calls cacheTokens() in Cognito SDK\n\t\t\t\t\tcurrentUser.setSignInUserSession(session);\n\n\t\t\t\t\tif (window && typeof window.history !== 'undefined') {\n\t\t\t\t\t\twindow.history.replaceState(\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t(this._config.oauth as AwsCognitoOAuthOpts).redirectSignIn\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t'signIn',\n\t\t\t\t\t\tcurrentUser,\n\t\t\t\t\t\t`A user ${currentUser.getUsername()} has been signed in`\n\t\t\t\t\t);\n\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t'cognitoHostedUI',\n\t\t\t\t\t\tcurrentUser,\n\t\t\t\t\t\t`A user ${currentUser.getUsername()} has been signed in via Cognito Hosted UI`\n\t\t\t\t\t);\n\n\t\t\t\t\tif (isCustomStateIncluded) {\n\t\t\t\t\t\tconst customState = state.split('-').splice(1).join('-');\n\n\t\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t\t'customOAuthState',\n\t\t\t\t\t\t\turlSafeDecode(customState),\n\t\t\t\t\t\t\t`State for user ${currentUser.getUsername()}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t//#endregion\n\n\t\t\t\t\treturn credentials;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tlogger.debug('Error in cognito hosted auth response', err);\n\n\t\t\t\t\t// Just like a successful handling of `?code`, replace the window history to \"dispose\" of the `code`.\n\t\t\t\t\t// Otherwise, reloading the page will throw errors as the `code` has already been spent.\n\t\t\t\t\tif (window && typeof window.history !== 'undefined') {\n\t\t\t\t\t\twindow.history.replaceState(\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t(this._config.oauth as AwsCognitoOAuthOpts).redirectSignIn\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t'signIn_failure',\n\t\t\t\t\t\terr,\n\t\t\t\t\t\t`The OAuth response flow failed`\n\t\t\t\t\t);\n\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t'cognitoHostedUI_failure',\n\t\t\t\t\t\terr,\n\t\t\t\t\t\t`A failure occurred when returning to the Cognito Hosted UI`\n\t\t\t\t\t);\n\t\t\t\t\tdispatchAuthEvent(\n\t\t\t\t\t\t'customState_failure',\n\t\t\t\t\t\terr,\n\t\t\t\t\t\t`A failure occurred when returning state`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.oAuthFlowInProgress = false;\n\t\t}\n\t}\n\n\t/**\n\t * Compact version of credentials\n\t * @param {Object} credentials\n\t * @return {Object} - Credentials\n\t */\n\tpublic essentialCredentials(credentials): ICredentials {\n\t\treturn {\n\t\t\taccessKeyId: credentials.accessKeyId,\n\t\t\tsessionToken: credentials.sessionToken,\n\t\t\tsecretAccessKey: credentials.secretAccessKey,\n\t\t\tidentityId: credentials.identityId,\n\t\t\tauthenticated: credentials.authenticated,\n\t\t};\n\t}\n\n\tprivate attributesToObject(attributes) {\n\t\tconst obj = {};\n\t\tif (attributes) {\n\t\t\tattributes.map(attribute => {\n\t\t\t\tif (\n\t\t\t\t\tattribute.Name === 'email_verified' ||\n\t\t\t\t\tattribute.Name === 'phone_number_verified'\n\t\t\t\t) {\n\t\t\t\t\tobj[attribute.Name] =\n\t\t\t\t\t\tthis.isTruthyString(attribute.Value) || attribute.Value === true;\n\t\t\t\t} else {\n\t\t\t\t\tobj[attribute.Name] = attribute.Value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn obj;\n\t}\n\n\tprivate isTruthyString(value: any): boolean {\n\t\treturn (\n\t\t\ttypeof value.toLowerCase === 'function' && value.toLowerCase() === 'true'\n\t\t);\n\t}\n\n\tprivate createCognitoUser(username: string): CognitoUser {\n\t\tconst userData: ICognitoUserData = {\n\t\t\tUsername: username,\n\t\t\tPool: this.userPool,\n\t\t};\n\t\tuserData.Storage = this._storage;\n\n\t\tconst { authenticationFlowType } = this._config;\n\n\t\tconst user = new CognitoUser(userData);\n\t\tif (authenticationFlowType) {\n\t\t\tuser.setAuthenticationFlowType(authenticationFlowType);\n\t\t}\n\t\treturn user;\n\t}\n\n\tprivate _isValidAuthStorage(obj) {\n\t\t// We need to check if the obj has the functions of Storage\n\t\treturn (\n\t\t\t!!obj &&\n\t\t\ttypeof obj.getItem === 'function' &&\n\t\t\ttypeof obj.setItem === 'function' &&\n\t\t\ttypeof obj.removeItem === 'function' &&\n\t\t\ttypeof obj.clear === 'function'\n\t\t);\n\t}\n\n\tprivate noUserPoolErrorHandler(config: AuthOptions): AuthErrorTypes {\n\t\tif (config) {\n\t\t\tif (!config.userPoolId || !config.identityPoolId) {\n\t\t\t\treturn AuthErrorTypes.MissingAuthConfig;\n\t\t\t}\n\t\t}\n\t\treturn AuthErrorTypes.NoConfig;\n\t}\n\n\tprivate rejectAuthError(type: AuthErrorTypes): Promise<never> {\n\t\treturn Promise.reject(new AuthError(type));\n\t}\n\n\tprivate rejectNoUserPool(): Promise<never> {\n\t\tconst type = this.noUserPoolErrorHandler(this._config);\n\t\treturn Promise.reject(new NoUserPoolError(type));\n\t}\n\n\tpublic async rememberDevice(): Promise<string | AuthError> {\n\t\tlet currUser;\n\n\t\ttry {\n\t\t\tcurrUser = await this.currentUserPoolUser();\n\t\t} catch (error) {\n\t\t\tlogger.debug('The user is not authenticated by the error', error);\n\t\t\treturn Promise.reject('The user is not authenticated');\n\t\t}\n\n\t\tcurrUser.getCachedDeviceKeyAndPassword();\n\t\treturn new Promise((res, rej) => {\n\t\t\tcurrUser.setDeviceStatusRemembered({\n\t\t\t\tonSuccess: data => {\n\t\t\t\t\tres(data);\n\t\t\t\t},\n\t\t\t\tonFailure: err => {\n\t\t\t\t\tif (err.code === 'InvalidParameterException') {\n\t\t\t\t\t\trej(new AuthError(AuthErrorTypes.DeviceConfig));\n\t\t\t\t\t} else if (err.code === 'NetworkError') {\n\t\t\t\t\t\trej(new AuthError(AuthErrorTypes.NetworkError));\n\t\t\t\t\t} else {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic async forgetDevice(): Promise<void> {\n\t\tlet currUser;\n\n\t\ttry {\n\t\t\tcurrUser = await this.currentUserPoolUser();\n\t\t} catch (error) {\n\t\t\tlogger.debug('The user is not authenticated by the error', error);\n\t\t\treturn Promise.reject('The user is not authenticated');\n\t\t}\n\n\t\tcurrUser.getCachedDeviceKeyAndPassword();\n\t\treturn new Promise((res, rej) => {\n\t\t\tcurrUser.forgetDevice({\n\t\t\t\tonSuccess: data => {\n\t\t\t\t\tres(data);\n\t\t\t\t},\n\t\t\t\tonFailure: err => {\n\t\t\t\t\tif (err.code === 'InvalidParameterException') {\n\t\t\t\t\t\trej(new AuthError(AuthErrorTypes.DeviceConfig));\n\t\t\t\t\t} else if (err.code === 'NetworkError') {\n\t\t\t\t\t\trej(new AuthError(AuthErrorTypes.NetworkError));\n\t\t\t\t\t} else {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic async fetchDevices(): Promise<IAuthDevice[]> {\n\t\tlet currUser;\n\n\t\ttry {\n\t\t\tcurrUser = await this.currentUserPoolUser();\n\t\t} catch (error) {\n\t\t\tlogger.debug('The user is not authenticated by the error', error);\n\t\t\tthrow new Error('The user is not authenticated');\n\t\t}\n\n\t\tcurrUser.getCachedDeviceKeyAndPassword();\n\t\treturn new Promise((res, rej) => {\n\t\t\tconst cb = {\n\t\t\t\tonSuccess(data) {\n\t\t\t\t\tconst deviceList: IAuthDevice[] = data.Devices.map(device => {\n\t\t\t\t\t\tconst deviceName =\n\t\t\t\t\t\t\tdevice.DeviceAttributes.find(\n\t\t\t\t\t\t\t\t({ Name }) => Name === 'device_name'\n\t\t\t\t\t\t\t) || {};\n\n\t\t\t\t\t\tconst deviceInfo: IAuthDevice = {\n\t\t\t\t\t\t\tid: device.DeviceKey,\n\t\t\t\t\t\t\tname: deviceName.Value,\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn deviceInfo;\n\t\t\t\t\t});\n\t\t\t\t\tres(deviceList);\n\t\t\t\t},\n\t\t\t\tonFailure: err => {\n\t\t\t\t\tif (err.code === 'InvalidParameterException') {\n\t\t\t\t\t\trej(new AuthError(AuthErrorTypes.DeviceConfig));\n\t\t\t\t\t} else if (err.code === 'NetworkError') {\n\t\t\t\t\t\trej(new AuthError(AuthErrorTypes.NetworkError));\n\t\t\t\t\t} else {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\tcurrUser.listDevices(MAX_DEVICES, null, cb);\n\t\t});\n\t}\n}\n\nexport const Auth = new AuthClass(null);\n\nAmplify.register(Auth);\n"]},"metadata":{},"sourceType":"module"}