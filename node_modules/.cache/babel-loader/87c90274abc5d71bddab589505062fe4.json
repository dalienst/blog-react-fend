{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./hasHeader\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\n\nvar SignatureV4 =\n/** @class */\nfunction () {\n  function SignatureV4(_a) {\n    var applyChecksum = _a.applyChecksum,\n        credentials = _a.credentials,\n        region = _a.region,\n        service = _a.service,\n        sha256 = _a.sha256,\n        _b = _a.uriEscapePath,\n        uriEscapePath = _b === void 0 ? true : _b;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath; // default to true if applyChecksum isn't set\n\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeRegionProvider(region);\n    this.credentialProvider = normalizeCredentialsProvider(credentials);\n  }\n\n  SignatureV4.prototype.presign = function (originalRequest, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, signingDate, _b, expiresIn, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, credentials, region, _c, _d, longDate, shortDate, scope, request, canonicalHeaders, _e, _f, _g, _h, _j, _k;\n\n      return __generator(this, function (_l) {\n        switch (_l.label) {\n          case 0:\n            _a = options.signingDate, signingDate = _a === void 0 ? new Date() : _a, _b = options.expiresIn, expiresIn = _b === void 0 ? 3600 : _b, unsignableHeaders = options.unsignableHeaders, unhoistableHeaders = options.unhoistableHeaders, signableHeaders = options.signableHeaders, signingRegion = options.signingRegion, signingService = options.signingService;\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _l.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _c = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _c = _l.sent();\n            _l.label = 4;\n\n          case 4:\n            region = _c;\n            _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;\n\n            if (expiresIn > MAX_PRESIGNED_TTL) {\n              return [2\n              /*return*/\n              , Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\")];\n            }\n\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request = moveHeadersToQuery(prepareRequest(originalRequest), {\n              unhoistableHeaders: unhoistableHeaders\n            });\n\n            if (credentials.sessionToken) {\n              request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n            }\n\n            request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n            request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + \"/\" + scope;\n            request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n            request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n            _e = request.query;\n            _f = SIGNATURE_QUERY_PARAM;\n            _g = this.getSignature;\n            _h = [longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService)];\n            _j = this.createCanonicalRequest;\n            _k = [request, canonicalHeaders];\n            return [4\n            /*yield*/\n            , getPayloadHash(originalRequest, this.sha256)];\n\n          case 5:\n            return [4\n            /*yield*/\n            , _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l.sent()]))]))];\n\n          case 6:\n            _e[_f] = _l.sent();\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.sign = function (toSign, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (typeof toSign === \"string\") {\n          return [2\n          /*return*/\n          , this.signString(toSign, options)];\n        } else if (toSign.headers && toSign.payload) {\n          return [2\n          /*return*/\n          , this.signEvent(toSign, options)];\n        } else {\n          return [2\n          /*return*/\n          , this.signRequest(toSign, options)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  SignatureV4.prototype.signEvent = function (_a, _b) {\n    var headers = _a.headers,\n        payload = _a.payload;\n    var _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        priorSignature = _b.priorSignature,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n    return __awaiter(this, void 0, void 0, function () {\n      var region, _d, _e, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, _f, stringToSign;\n\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 1];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 2:\n            _d = _g.sent();\n            _g.label = 3;\n\n          case 3:\n            region = _d;\n            _e = formatDate(signingDate), shortDate = _e.shortDate, longDate = _e.longDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            return [4\n            /*yield*/\n            , getPayloadHash({\n              headers: {},\n              body: payload\n            }, this.sha256)];\n\n          case 4:\n            hashedPayload = _g.sent();\n            hash = new this.sha256();\n            hash.update(headers);\n            _f = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 5:\n            hashedHeaders = _f.apply(void 0, [_g.sent()]);\n            stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n            return [2\n            /*return*/\n            , this.signString(stringToSign, {\n              signingDate: signingDate,\n              signingRegion: region,\n              signingService: signingService\n            })];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signString = function (stringToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, shortDate, hash, _e, _f, _g;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _h.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _d = _h.sent();\n            _h.label = 4;\n\n          case 4:\n            region = _d;\n            shortDate = formatDate(signingDate).shortDate;\n            _f = (_e = this.sha256).bind;\n            return [4\n            /*yield*/\n            , this.getSigningKey(credentials, region, shortDate, signingService)];\n\n          case 5:\n            hash = new (_f.apply(_e, [void 0, _h.sent()]))();\n            hash.update(stringToSign);\n            _g = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 6:\n            return [2\n            /*return*/\n            , _g.apply(void 0, [_h.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.signRequest = function (requestToSign, _a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.signingDate,\n        signingDate = _c === void 0 ? new Date() : _c,\n        signableHeaders = _b.signableHeaders,\n        unsignableHeaders = _b.unsignableHeaders,\n        signingRegion = _b.signingRegion,\n        signingService = _b.signingService;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, region, _d, request, _e, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.credentialProvider()];\n\n          case 1:\n            credentials = _f.sent();\n            if (!(signingRegion !== null && signingRegion !== void 0)) return [3\n            /*break*/\n            , 2];\n            _d = signingRegion;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.regionProvider()];\n\n          case 3:\n            _d = _f.sent();\n            _f.label = 4;\n\n          case 4:\n            region = _d;\n            request = prepareRequest(requestToSign);\n            _e = formatDate(signingDate), longDate = _e.longDate, shortDate = _e.shortDate;\n            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n            request.headers[AMZ_DATE_HEADER] = longDate;\n\n            if (credentials.sessionToken) {\n              request.headers[TOKEN_HEADER] = credentials.sessionToken;\n            }\n\n            return [4\n            /*yield*/\n            , getPayloadHash(request, this.sha256)];\n\n          case 5:\n            payloadHash = _f.sent();\n\n            if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n              request.headers[SHA256_HEADER] = payloadHash;\n            }\n\n            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n            return [4\n            /*yield*/\n            , this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];\n\n          case 6:\n            signature = _f.sent();\n            request.headers[AUTH_HEADER] = ALGORITHM_IDENTIFIER + \" \" + (\"Credential=\" + credentials.accessKeyId + \"/\" + scope + \", \") + (\"SignedHeaders=\" + getCanonicalHeaderList(canonicalHeaders) + \", \") + (\"Signature=\" + signature);\n            return [2\n            /*return*/\n            , request];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.createCanonicalRequest = function (request, canonicalHeaders, payloadHash) {\n    var sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return request.method + \"\\n\" + this.getCanonicalPath(request) + \"\\n\" + getCanonicalQuery(request) + \"\\n\" + sortedHeaders.map(function (name) {\n      return name + \":\" + canonicalHeaders[name];\n    }).join(\"\\n\") + \"\\n\\n\" + sortedHeaders.join(\";\") + \"\\n\" + payloadHash;\n  };\n\n  SignatureV4.prototype.createStringToSign = function (longDate, credentialScope, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var hash, hashedRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            hash = new this.sha256();\n            hash.update(canonicalRequest);\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 1:\n            hashedRequest = _a.sent();\n            return [2\n            /*return*/\n            , ALGORITHM_IDENTIFIER + \"\\n\" + longDate + \"\\n\" + credentialScope + \"\\n\" + toHex(hashedRequest)];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getCanonicalPath = function (_a) {\n    var path = _a.path;\n\n    if (this.uriEscapePath) {\n      var doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return \"/\" + doubleEncoded.replace(/%2F/g, \"/\");\n    }\n\n    return path;\n  };\n\n  SignatureV4.prototype.getSignature = function (longDate, credentialScope, keyPromise, canonicalRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stringToSign, hash, _a, _b, _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createStringToSign(longDate, credentialScope, canonicalRequest)];\n\n          case 1:\n            stringToSign = _d.sent();\n            _b = (_a = this.sha256).bind;\n            return [4\n            /*yield*/\n            , keyPromise];\n\n          case 2:\n            hash = new (_b.apply(_a, [void 0, _d.sent()]))();\n            hash.update(stringToSign);\n            _c = toHex;\n            return [4\n            /*yield*/\n            , hash.digest()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _c.apply(void 0, [_d.sent()])];\n        }\n      });\n    });\n  };\n\n  SignatureV4.prototype.getSigningKey = function (credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  };\n\n  return SignatureV4;\n}();\n\nexport { SignatureV4 };\n\nvar formatDate = function (now) {\n  var longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate: longDate,\n    shortDate: longDate.substr(0, 8)\n  };\n};\n\nvar getCanonicalHeaderList = function (headers) {\n  return Object.keys(headers).sort().join(\";\");\n};\n\nvar normalizeRegionProvider = function (region) {\n  if (typeof region === \"string\") {\n    var promisified_1 = Promise.resolve(region);\n    return function () {\n      return promisified_1;\n    };\n  } else {\n    return region;\n  }\n};\n\nvar normalizeCredentialsProvider = function (credentials) {\n  if (typeof credentials === \"object\") {\n    var promisified_2 = Promise.resolve(credentials);\n    return function () {\n      return promisified_2;\n    };\n  } else {\n    return credentials;\n  }\n};","map":{"version":3,"mappings":"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","names":["toHex","ALGORITHM_IDENTIFIER","ALGORITHM_QUERY_PARAM","AMZ_DATE_HEADER","AMZ_DATE_QUERY_PARAM","AUTH_HEADER","CREDENTIAL_QUERY_PARAM","EVENT_ALGORITHM_IDENTIFIER","EXPIRES_QUERY_PARAM","MAX_PRESIGNED_TTL","SHA256_HEADER","SIGNATURE_QUERY_PARAM","SIGNED_HEADERS_QUERY_PARAM","TOKEN_HEADER","TOKEN_QUERY_PARAM","createScope","getSigningKey","getCanonicalHeaders","getCanonicalQuery","getPayloadHash","hasHeader","moveHeadersToQuery","prepareRequest","iso8601","_a","applyChecksum","credentials","region","service","sha256","_b","uriEscapePath","regionProvider","normalizeRegionProvider","credentialProvider","normalizeCredentialsProvider","SignatureV4","originalRequest","options","Date","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","signingRegion","signingService","_l","_c","_d","formatDate","signingDate","longDate","shortDate","Promise","reject","scope","request","sessionToken","query","accessKeyId","toString","canonicalHeaders","getCanonicalHeaderList","_e","_f","_g","getSignature","_j","createCanonicalRequest","_h","_k","toSign","signString","headers","payload","signEvent","signRequest","priorSignature","body","hashedPayload","hash","update","digest","hashedHeaders","stringToSign","join","bind","requestToSign","payloadHash","signature","sortedHeaders","Object","keys","sort","method","getCanonicalPath","map","name","credentialScope","canonicalRequest","hashedRequest","path","doubleEncoded","encodeURIComponent","replace","keyPromise","createStringToSign","now","substr","promisified_1","resolve","promisified_2"],"sources":["/home/dalienst/node_modules/@aws-sdk/signature-v4/src/SignatureV4.ts"],"sourcesContent":["import {\n  Credentials,\n  DateInput,\n  EventSigner,\n  EventSigningArguments,\n  FormattedEvent,\n  HashConstructor,\n  HeaderBag,\n  HttpRequest,\n  Provider,\n  RequestPresigner,\n  RequestPresigningArguments,\n  RequestSigner,\n  RequestSigningArguments,\n  SigningArguments,\n  StringSigner,\n} from \"@aws-sdk/types\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\n\nimport {\n  ALGORITHM_IDENTIFIER,\n  ALGORITHM_QUERY_PARAM,\n  AMZ_DATE_HEADER,\n  AMZ_DATE_QUERY_PARAM,\n  AUTH_HEADER,\n  CREDENTIAL_QUERY_PARAM,\n  EVENT_ALGORITHM_IDENTIFIER,\n  EXPIRES_QUERY_PARAM,\n  MAX_PRESIGNED_TTL,\n  SHA256_HEADER,\n  SIGNATURE_QUERY_PARAM,\n  SIGNED_HEADERS_QUERY_PARAM,\n  TOKEN_HEADER,\n  TOKEN_QUERY_PARAM,\n} from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./hasHeader\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\n\nexport interface SignatureV4Init {\n  /**\n   * The service signing name.\n   */\n  service: string;\n\n  /**\n   * The region name or a function that returns a promise that will be\n   * resolved with the region name.\n   */\n  region: string | Provider<string>;\n\n  /**\n   * The credentials with which the request should be signed or a function\n   * that returns a promise that will be resolved with credentials.\n   */\n  credentials: Credentials | Provider<Credentials>;\n\n  /**\n   * A constructor function for a hash object that will calculate SHA-256 HMAC\n   * checksums.\n   */\n  sha256?: HashConstructor;\n\n  /**\n   * Whether to uri-escape the request URI path as part of computing the\n   * canonical request string. This is required for every AWS service, except\n   * Amazon S3, as of late 2017.\n   *\n   * @default [true]\n   */\n  uriEscapePath?: boolean;\n\n  /**\n   * Whether to calculate a checksum of the request body and include it as\n   * either a request header (when signing) or as a query string parameter\n   * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for\n   * every other AWS service as of late 2017.\n   *\n   * @default [true]\n   */\n  applyChecksum?: boolean;\n}\n\nexport interface SignatureV4CryptoInit {\n  sha256: HashConstructor;\n}\n\nexport class SignatureV4 implements RequestPresigner, RequestSigner, StringSigner, EventSigner {\n  private readonly service: string;\n  private readonly regionProvider: Provider<string>;\n  private readonly credentialProvider: Provider<Credentials>;\n  private readonly sha256: HashConstructor;\n  private readonly uriEscapePath: boolean;\n  private readonly applyChecksum: boolean;\n\n  constructor({\n    applyChecksum,\n    credentials,\n    region,\n    service,\n    sha256,\n    uriEscapePath = true,\n  }: SignatureV4Init & SignatureV4CryptoInit) {\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    // default to true if applyChecksum isn't set\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeRegionProvider(region);\n    this.credentialProvider = normalizeCredentialsProvider(credentials);\n  }\n\n  public async presign(originalRequest: HttpRequest, options: RequestPresigningArguments = {}): Promise<HttpRequest> {\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService,\n    } = options;\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n\n    const { longDate, shortDate } = formatDate(signingDate);\n    if (expiresIn > MAX_PRESIGNED_TTL) {\n      return Promise.reject(\n        \"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\"\n      );\n    }\n\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });\n\n    if (credentials.sessionToken) {\n      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n    request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n\n    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(\n      longDate,\n      scope,\n      this.getSigningKey(credentials, region, shortDate, signingService),\n      this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256))\n    );\n\n    return request;\n  }\n\n  public async sign(stringToSign: string, options?: SigningArguments): Promise<string>;\n  public async sign(event: FormattedEvent, options: EventSigningArguments): Promise<string>;\n  public async sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;\n  public async sign(toSign: any, options: any): Promise<any> {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n\n  private async signEvent(\n    { headers, payload }: FormattedEvent,\n    { signingDate = new Date(), priorSignature, signingRegion, signingService }: EventSigningArguments\n  ): Promise<string> {\n    const region = signingRegion ?? (await this.regionProvider());\n    const { shortDate, longDate } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const hashedPayload = await getPayloadHash({ headers: {}, body: payload } as any, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = toHex(await hash.digest());\n    const stringToSign = [\n      EVENT_ALGORITHM_IDENTIFIER,\n      longDate,\n      scope,\n      priorSignature,\n      hashedHeaders,\n      hashedPayload,\n    ].join(\"\\n\");\n    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n  }\n\n  private async signString(\n    stringToSign: string,\n    { signingDate = new Date(), signingRegion, signingService }: SigningArguments = {}\n  ): Promise<string> {\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n    const { shortDate } = formatDate(signingDate);\n\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(stringToSign);\n    return toHex(await hash.digest());\n  }\n\n  private async signRequest(\n    requestToSign: HttpRequest,\n    {\n      signingDate = new Date(),\n      signableHeaders,\n      unsignableHeaders,\n      signingRegion,\n      signingService,\n    }: RequestSigningArguments = {}\n  ): Promise<HttpRequest> {\n    const credentials = await this.credentialProvider();\n    const region = signingRegion ?? (await this.regionProvider());\n    const request = prepareRequest(requestToSign);\n    const { longDate, shortDate } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n\n    request.headers[AMZ_DATE_HEADER] = longDate;\n    if (credentials.sessionToken) {\n      request.headers[TOKEN_HEADER] = credentials.sessionToken;\n    }\n\n    const payloadHash = await getPayloadHash(request, this.sha256);\n    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[SHA256_HEADER] = payloadHash;\n    }\n\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(\n      longDate,\n      scope,\n      this.getSigningKey(credentials, region, shortDate, signingService),\n      this.createCanonicalRequest(request, canonicalHeaders, payloadHash)\n    );\n\n    request.headers[AUTH_HEADER] =\n      `${ALGORITHM_IDENTIFIER} ` +\n      `Credential=${credentials.accessKeyId}/${scope}, ` +\n      `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\n      `Signature=${signature}`;\n\n    return request;\n  }\n\n  private createCanonicalRequest(request: HttpRequest, canonicalHeaders: HeaderBag, payloadHash: string): string {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n\n  private async createStringToSign(\n    longDate: string,\n    credentialScope: string,\n    canonicalRequest: string\n  ): Promise<string> {\n    const hash = new this.sha256();\n    hash.update(canonicalRequest);\n    const hashedRequest = await hash.digest();\n\n    return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n  }\n\n  private getCanonicalPath({ path }: HttpRequest): string {\n    if (this.uriEscapePath) {\n      const doubleEncoded = encodeURIComponent(path.replace(/^\\//, \"\"));\n      return `/${doubleEncoded.replace(/%2F/g, \"/\")}`;\n    }\n\n    return path;\n  }\n\n  private async getSignature(\n    longDate: string,\n    credentialScope: string,\n    keyPromise: Promise<Uint8Array>,\n    canonicalRequest: string\n  ): Promise<string> {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n\n    const hash = new this.sha256(await keyPromise);\n    hash.update(stringToSign);\n    return toHex(await hash.digest());\n  }\n\n  private getSigningKey(\n    credentials: Credentials,\n    region: string,\n    shortDate: string,\n    service?: string\n  ): Promise<Uint8Array> {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n}\n\nconst formatDate = (now: DateInput): { longDate: string; shortDate: string } => {\n  const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.substr(0, 8),\n  };\n};\n\nconst getCanonicalHeaderList = (headers: object): string => Object.keys(headers).sort().join(\";\");\n\nconst normalizeRegionProvider = (region: string | Provider<string>): Provider<string> => {\n  if (typeof region === \"string\") {\n    const promisified = Promise.resolve(region);\n    return () => promisified;\n  } else {\n    return region;\n  }\n};\n\nconst normalizeCredentialsProvider = (credentials: Credentials | Provider<Credentials>): Provider<Credentials> => {\n  if (typeof credentials === \"object\") {\n    const promisified = Promise.resolve(credentials);\n    return () => promisified;\n  } else {\n    return credentials;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}