{"ast":null,"code":"import { __assign, __read } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n    throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n  }\n\n  if (lat < -90 || 90 < lat) {\n    throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n  } else if (lng < -180 || 180 < lng) {\n    throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n  }\n}\nexport function validateGeofenceId(geofenceId) {\n  var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu; // Check if geofenceId is valid\n\n  if (!geofenceIdRegex.test(geofenceId)) {\n    throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n  }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : ''; // Validate LinearRing size, must be at least 4 points\n\n  if (linearRing.length < 4) {\n    throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n  } // Validate all coordinates are valid, error with which ones are bad\n\n\n  var badCoordinates = [];\n  linearRing.forEach(function (coordinates) {\n    try {\n      validateCoordinates(coordinates[0], coordinates[1]);\n    } catch (error) {\n      badCoordinates.push({\n        coordinates: coordinates,\n        error: error.message\n      });\n    }\n  });\n\n  if (badCoordinates.length > 0) {\n    throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n  } // Validate first and last coordinates are the same\n\n\n  var _a = __read(linearRing[0], 2),\n      lngA = _a[0],\n      latA = _a[1];\n\n  var _b = __read(linearRing[linearRing.length - 1], 2),\n      lngB = _b[0],\n      latB = _b[1];\n\n  if (lngA !== lngB || latA !== latB) {\n    throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n  }\n\n  if (booleanClockwise(linearRing)) {\n    throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n  }\n}\nexport function validatePolygon(polygon, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n\n  if (!Array.isArray(polygon)) {\n    throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n  }\n\n  if (polygon.length < 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n  }\n\n  if (polygon.length > 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n  }\n\n  var verticesCount = polygon.reduce(function (prev, linearRing) {\n    return prev + linearRing.length;\n  }, 0);\n\n  if (verticesCount > 1000) {\n    throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n  }\n\n  polygon.forEach(function (linearRing) {\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function validateGeofencesInput(geofences) {\n  var geofenceIds = {};\n  geofences.forEach(function (geofence) {\n    // verify all required properties are present\n    // Validate geofenceId exists\n    if (!geofence.geofenceId) {\n      throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n    }\n\n    var geofenceId = geofence.geofenceId;\n    validateGeofenceId(geofenceId); // Validate geofenceId is unique\n\n    if (geofenceIds[geofenceId]) {\n      throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n    } else {\n      geofenceIds[geofenceId] = true;\n    } // Validate geometry exists\n\n\n    if (!geofence.geometry) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n    }\n\n    var geometry = geofence.geometry; // Validate polygon exists\n\n    if (!geometry.polygon) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n    }\n\n    var polygon = geometry.polygon; // Validate polygon length and structure\n\n    try {\n      validatePolygon(polygon, geofenceId);\n    } catch (error) {\n      if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n        throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n      }\n    } // Validate LinearRing length, structure, and coordinates\n\n\n    var _a = __read(polygon, 1),\n        linearRing = _a[0];\n\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n  var locationServiceModifiedInput = __assign({}, locationServiceInput);\n\n  locationServiceModifiedInput.FilterCountries = options.countries;\n  locationServiceModifiedInput.MaxResults = options.maxResults;\n\n  if (options.searchIndexName) {\n    locationServiceModifiedInput.IndexName = options.searchIndexName;\n  }\n\n  if (options['biasPosition'] && options['searchAreaConstraints']) {\n    throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n  }\n\n  if (options['biasPosition']) {\n    locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n  }\n\n  if (options['searchAreaConstraints']) {\n    locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n  }\n\n  return locationServiceModifiedInput;\n}","map":{"version":3,"mappings":"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","names":["booleanClockwise","validateCoordinates","lng","lat","Number","isFinite","Error","validateGeofenceId","geofenceId","geofenceIdRegex","test","validateLinearRing","linearRing","errorPrefix","length","badCoordinates","forEach","coordinates","error","push","message","JSON","stringify","lngA","latA","lngB","latB","validatePolygon","polygon","Array","isArray","verticesCount","reduce","prev","validateGeofencesInput","geofences","geofenceIds","geofence","geometry","includes","mapSearchOptions","options","locationServiceInput","locationServiceModifiedInput","FilterCountries","countries","MaxResults","maxResults","searchIndexName","IndexName","BiasPosition","FilterBBox"],"sources":["/home/dalienst/node_modules/@aws-amplify/geo/src/util.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport booleanClockwise from '@turf/boolean-clockwise';\n\nimport {\n\tLongitude,\n\tLatitude,\n\tGeofenceId,\n\tGeofenceInput,\n\tGeofencePolygon,\n\tLinearRing,\n} from './types';\n\nexport function validateCoordinates(lng: Longitude, lat: Latitude): void {\n\tif (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n\t\tthrow new Error(`Invalid coordinates: [${lng},${lat}]`);\n\t}\n\tif (lat < -90 || 90 < lat) {\n\t\tthrow new Error('Latitude must be between -90 and 90 degrees inclusive.');\n\t} else if (lng < -180 || 180 < lng) {\n\t\tthrow new Error(\n\t\t\t'Longitude must be between -180 and 180 degrees inclusive.'\n\t\t);\n\t}\n}\n\nexport function validateGeofenceId(geofenceId: GeofenceId): void {\n\tconst geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu;\n\n\t// Check if geofenceId is valid\n\tif (!geofenceIdRegex.test(geofenceId)) {\n\t\tthrow new Error(\n\t\t\t`Invalid geofenceId: '${geofenceId}' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.`\n\t\t);\n\t}\n}\n\nexport function validateLinearRing(\n\tlinearRing: LinearRing,\n\tgeofenceId?: GeofenceId\n): void {\n\tconst errorPrefix = geofenceId ? `${geofenceId}: ` : '';\n\t// Validate LinearRing size, must be at least 4 points\n\tif (linearRing.length < 4) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}LinearRing must contain 4 or more coordinates.`\n\t\t);\n\t}\n\n\t// Validate all coordinates are valid, error with which ones are bad\n\tconst badCoordinates = [];\n\tlinearRing.forEach(coordinates => {\n\t\ttry {\n\t\t\tvalidateCoordinates(coordinates[0], coordinates[1]);\n\t\t} catch (error) {\n\t\t\tbadCoordinates.push({ coordinates, error: error.message });\n\t\t}\n\t});\n\tif (badCoordinates.length > 0) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}One or more of the coordinates in the Polygon LinearRing are not valid: ${JSON.stringify(\n\t\t\t\tbadCoordinates\n\t\t\t)}`\n\t\t);\n\t}\n\n\t// Validate first and last coordinates are the same\n\tconst [lngA, latA] = linearRing[0];\n\tconst [lngB, latB] = linearRing[linearRing.length - 1];\n\n\tif (lngA !== lngB || latA !== latB) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}LinearRing's first and last coordinates are not the same`\n\t\t);\n\t}\n\n\tif (booleanClockwise(linearRing)) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}LinearRing coordinates must be wound counterclockwise`\n\t\t);\n\t}\n}\n\nexport function validatePolygon(\n\tpolygon: GeofencePolygon,\n\tgeofenceId?: GeofenceId\n): void {\n\tconst errorPrefix = geofenceId ? `${geofenceId}: ` : '';\n\tif (!Array.isArray(polygon)) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon is of incorrect structure. It should be an array of LinearRings`\n\t\t);\n\t}\n\tif (polygon.length < 1) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon must have a single LinearRing array.`\n\t\t);\n\t}\n\n\tif (polygon.length > 1) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.`\n\t\t);\n\t}\n\tconst verticesCount = polygon.reduce(\n\t\t(prev, linearRing) => prev + linearRing.length,\n\t\t0\n\t);\n\tif (verticesCount > 1000) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon has more than the maximum 1000 vertices.`\n\t\t);\n\t}\n\tpolygon.forEach(linearRing => {\n\t\tvalidateLinearRing(linearRing, geofenceId);\n\t});\n}\n\nexport function validateGeofencesInput(geofences: GeofenceInput[]) {\n\tconst geofenceIds = {};\n\n\tgeofences.forEach((geofence: GeofenceInput) => {\n\t\t// verify all required properties are present\n\n\t\t// Validate geofenceId exists\n\t\tif (!geofence.geofenceId) {\n\t\t\tthrow new Error(`Geofence '${geofence}' is missing geofenceId`);\n\t\t}\n\t\tconst { geofenceId } = geofence;\n\t\tvalidateGeofenceId(geofenceId);\n\n\t\t// Validate geofenceId is unique\n\t\tif (geofenceIds[geofenceId]) {\n\t\t\tthrow new Error(`Duplicate geofenceId: ${geofenceId}`);\n\t\t} else {\n\t\t\tgeofenceIds[geofenceId] = true;\n\t\t}\n\n\t\t// Validate geometry exists\n\t\tif (!geofence.geometry) {\n\t\t\tthrow new Error(`Geofence '${geofenceId}' is missing geometry`);\n\t\t}\n\t\tconst { geometry } = geofence;\n\n\t\t// Validate polygon exists\n\t\tif (!geometry.polygon) {\n\t\t\tthrow new Error(`Geofence '${geofenceId}' is missing geometry.polygon`);\n\t\t}\n\t\tconst { polygon } = geometry;\n\n\t\t// Validate polygon length and structure\n\t\ttry {\n\t\t\tvalidatePolygon(polygon, geofenceId);\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror.message.includes(\n\t\t\t\t\t'Polygon has more than the maximum 1000 vertices.'\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Geofence '${geofenceId}' has more than the maximum of 1000 vertices`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Validate LinearRing length, structure, and coordinates\n\t\tconst [linearRing] = polygon;\n\t\tvalidateLinearRing(linearRing, geofenceId);\n\t});\n}\n\nexport function mapSearchOptions(options, locationServiceInput) {\n\tconst locationServiceModifiedInput = { ...locationServiceInput };\n\tlocationServiceModifiedInput.FilterCountries = options.countries;\n\tlocationServiceModifiedInput.MaxResults = options.maxResults;\n\n\tif (options.searchIndexName) {\n\t\tlocationServiceModifiedInput.IndexName = options.searchIndexName;\n\t}\n\n\tif (options['biasPosition'] && options['searchAreaConstraints']) {\n\t\tthrow new Error(\n\t\t\t'BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object'\n\t\t);\n\t}\n\tif (options['biasPosition']) {\n\t\tlocationServiceModifiedInput.BiasPosition = options['biasPosition'];\n\t}\n\tif (options['searchAreaConstraints']) {\n\t\tlocationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n\t}\n\treturn locationServiceModifiedInput;\n}\n"]},"metadata":{},"sourceType":"module"}