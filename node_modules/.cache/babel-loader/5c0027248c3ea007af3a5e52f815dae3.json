{"ast":null,"code":"import { __values } from \"tslib\";\nimport { isFieldAssociation } from '../types';\n/**\n * Defines a relationship from a LOCAL model.field to a REMOTE model.field and helps\n * navigate the relationship, providing a simplified peek at the relationship details\n * pertinent to setting FK's and constructing join conditions.\n *\n * Because I mean, relationships are tough.\n *\n */\n\nvar ModelRelationship =\n/** @class */\nfunction () {\n  /**\n   * @param modelDefinition The \"local\" model.\n   * @param field The \"local\" model field.\n   */\n  function ModelRelationship(model, field) {\n    if (!isFieldAssociation(model.schema, field)) {\n      throw new Error(model.schema.name + \".\" + field + \" is not a relationship.\");\n    }\n\n    this.localModel = model;\n    this._field = field;\n  }\n  /**\n   * Returns a ModelRelationship for the the given model and field if the pair\n   * indicates a relationship to another model. Else, returns `null`.\n   *\n   * @param model The model the relationship field exists in.\n   * @param field The field that may relates the local model to the remote model.\n   */\n\n\n  ModelRelationship.from = function (model, field) {\n    if (isFieldAssociation(model.schema, field)) {\n      return new this(model, field);\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Enumerates all valid `ModelRelationship`'s on the given model.\n   *\n   * @param model The model definition to enumerate relationships of.\n   */\n\n\n  ModelRelationship.allFrom = function (model) {\n    var e_1, _a;\n\n    var relationships = [];\n\n    try {\n      for (var _b = __values(Object.keys(model.schema.fields)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var field = _c.value;\n        var relationship = ModelRelationship.from(model, field);\n        relationship && relationships.push(relationship);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return relationships;\n  };\n\n  Object.defineProperty(ModelRelationship.prototype, \"localDefinition\", {\n    get: function () {\n      return this.localModel.schema;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"field\", {\n    /**\n     * The virtual/computed field on the local model that should contain\n     * the related model.\n     */\n    get: function () {\n      return this._field;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localConstructor\", {\n    /**\n     * The constructor that can be used to query DataStore or create instance for\n     * the local model.\n     */\n    get: function () {\n      return this.localModel.builder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"type\", {\n    /**\n     * The name/type of the relationship the local model has with the remote model\n     * via the defined local model field.\n     */\n    get: function () {\n      return this.localAssocation.connectionType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localAssocation\", {\n    /**\n     * Raw details about the local FK as-is from the local model's field definition in\n     * the schema. This field requires interpretation.\n     *\n     * @see localJoinFields\n     * @see localAssociatedWith\n     */\n    get: function () {\n      return this.localDefinition.fields[this.field].association;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localJoinFields\", {\n    /**\n     * The field names on the local model that can be used to query or queried to match\n     * with instances of the remote model.\n     *\n     * Fields are returned in-order to match the order of `this.remoteKeyFields`.\n     */\n    get: function () {\n      /**\n       * This is relatively straightforward, actually.\n       *\n       * If we have explicitly stated targetNames, codegen is telling us authoritatively\n       * to use those fields for this relationship. The local model \"points to\" fields\n       * in the remote one.\n       *\n       * In other cases, the remote model points to this one's\n       */\n      if (this.localAssocation.targetName) {\n        // This case is theoretically unnecessary going forward.\n        return [this.localAssocation.targetName];\n      } else if (this.localAssocation.targetNames) {\n        return this.localAssocation.targetNames;\n      } else {\n        return this.localPKFields;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localPKFields\", {\n    /**\n     * The field names on the local model that uniquely identify it.\n     *\n     * These fields may or may not be relevant to the join fields.\n     */\n    get: function () {\n      return this.localModel.pkField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteDefinition\", {\n    get: function () {\n      var _a;\n\n      return (_a = this.remoteModelType.modelConstructor) === null || _a === void 0 ? void 0 : _a.schema;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteModelType\", {\n    get: function () {\n      return this.localDefinition.fields[this.field].type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteModelConstructor\", {\n    /**\n     * Constructor that can be used to query DataStore or create instances for\n     * the remote model.\n     */\n    get: function () {\n      return this.remoteModelType.modelConstructor.builder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remotePKFields\", {\n    /**\n     * The field names on the remote model that uniquely identify it.\n     *\n     * These fields may or may not be relevant to the join fields.\n     */\n    get: function () {\n      var _a;\n\n      return ((_a = this.remoteModelType.modelConstructor) === null || _a === void 0 ? void 0 : _a.pkField) || ['id'];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"localAssociatedWith\", {\n    /**\n     * The `associatedWith` fields from the local perspective.\n     *\n     * When present, these fields indicate which fields on the remote model to use\n     * when looking for a remote association and/or determining the final remote\n     * key fields.\n     */\n    get: function () {\n      if (this.localAssocation.connectionType === 'HAS_MANY' || this.localAssocation.connectionType === 'HAS_ONE') {\n        // This de-arraying is theoretically unnecessary going forward.\n        return Array.isArray(this.localAssocation.associatedWith) ? this.localAssocation.associatedWith : [this.localAssocation.associatedWith];\n      } else {\n        return undefined;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"explicitRemoteAssociation\", {\n    get: function () {\n      var _a;\n\n      if (this.localAssociatedWith) {\n        if (this.localAssociatedWith.length === 1) {\n          return (_a = this.remoteDefinition.fields[this.localAssociatedWith[0]]) === null || _a === void 0 ? void 0 : _a.association;\n        } else {\n          return undefined;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"remoteJoinFields\", {\n    /**\n     * The field names on the remote model that can used to query or queried to match\n     * with instances of the local model.\n     *\n     * Fields are returned in-order to match the order of `this.localKeyFields`.\n     */\n    get: function () {\n      /**\n       * If the local relationship explicitly names \"associated with\" fields, we\n       * need to see if this points direction to a reciprocating assocation. If it\n       * does, the remote assocation indicates what fields to use.\n       */\n      var _a, _b, _c;\n\n      if ((_a = this.explicitRemoteAssociation) === null || _a === void 0 ? void 0 : _a.targetName) {\n        // This case is theoretically unnecessary going forward.\n        return [this.explicitRemoteAssociation.targetName];\n      } else if ((_b = this.explicitRemoteAssociation) === null || _b === void 0 ? void 0 : _b.targetNames) {\n        return (_c = this.explicitRemoteAssociation) === null || _c === void 0 ? void 0 : _c.targetNames;\n      } else if (this.localAssociatedWith) {\n        return this.localAssociatedWith;\n      } else {\n        return this.remotePKFields;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ModelRelationship.prototype, \"isComplete\", {\n    /**\n     * Whether this relationship everything necessary to get, set, and query from\n     * the perspective of the local model provided at instantiation.\n     */\n    get: function () {\n      return this.localJoinFields.length > 0 && this.remoteJoinFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates an FK mapper object with respect to the given related instance.\n   *\n   * E.g., if the local FK fields are `[parentId, parentName]` and point to\n   * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n   * will return:\n   *\n   * ```\n   * {\n   * \tparentId: remote.customId,\n   * \tparentName: remote.name\n   * }\n   * ```\n   *\n   * @param remote The remote related instance.\n   */\n\n  ModelRelationship.prototype.createLocalFKObject = function (remote) {\n    var fk = {};\n\n    for (var i = 0; i < this.localJoinFields.length; i++) {\n      fk[this.localJoinFields[i]] = remote[this.remoteJoinFields[i]];\n    }\n\n    return fk;\n  };\n  /**\n   * Creates an query mapper object to help fetch the remote instance(s) or\n   * `null` if any of the necessary local fields are `null` or `undefined`.\n   *\n   * E.g., if the local FK fields are `[parentId, parentName]` and point to\n   * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n   * will return:\n   *\n   * ```\n   * {\n   * \tcustomId: local.parentId\n   * \tname: local.parentName\n   * }\n   * ```\n   *\n   * If the local fields are not populated, returns\n   *\n   * @param local The local instance.\n   */\n\n\n  ModelRelationship.prototype.createRemoteQueryObject = function (local) {\n    var query = {};\n\n    for (var i = 0; i < this.remoteJoinFields.length; i++) {\n      var localValue = local[this.localJoinFields[i]];\n      if (localValue === null || localValue === undefined) return null;\n      query[this.remoteJoinFields[i]] = local[this.localJoinFields[i]];\n    }\n\n    return query;\n  };\n\n  return ModelRelationship;\n}();\n\nexport { ModelRelationship };","map":{"version":3,"mappings":"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","names":["isFieldAssociation","model","field","schema","Error","name","localModel","_field","ModelRelationship","relationships","keys","fields","_c","relationship","from","push","Object","builder","localAssocation","connectionType","localDefinition","association","targetName","targetNames","localPKFields","pkField","remoteModelType","modelConstructor","_a","type","Array","isArray","associatedWith","undefined","localAssociatedWith","length","remoteDefinition","explicitRemoteAssociation","_b","remotePKFields","localJoinFields","remoteJoinFields","remote","fk","i","local","query","localValue"],"sources":["/home/dalienst/node_modules/@aws-amplify/datastore/src/storage/relationship.ts"],"sourcesContent":["import { isFieldAssociation, ModelFieldType, ModelMeta } from '../types';\n\n/**\n * Defines a relationship from a LOCAL model.field to a REMOTE model.field and helps\n * navigate the relationship, providing a simplified peek at the relationship details\n * pertinent to setting FK's and constructing join conditions.\n *\n * Because I mean, relationships are tough.\n *\n */\nexport class ModelRelationship<T> {\n\tprivate localModel: ModelMeta<T>;\n\tprivate _field: string;\n\n\t/**\n\t * @param modelDefinition The \"local\" model.\n\t * @param field The \"local\" model field.\n\t */\n\tconstructor(model: ModelMeta<T>, field: string) {\n\t\tif (!isFieldAssociation(model.schema, field)) {\n\t\t\tthrow new Error(`${model.schema.name}.${field} is not a relationship.`);\n\t\t}\n\t\tthis.localModel = model;\n\t\tthis._field = field;\n\t}\n\n\t/**\n\t * Returns a ModelRelationship for the the given model and field if the pair\n\t * indicates a relationship to another model. Else, returns `null`.\n\t *\n\t * @param model The model the relationship field exists in.\n\t * @param field The field that may relates the local model to the remote model.\n\t */\n\tstatic from<T>(model: ModelMeta<T>, field: string) {\n\t\tif (isFieldAssociation(model.schema, field)) {\n\t\t\treturn new this(model, field);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Enumerates all valid `ModelRelationship`'s on the given model.\n\t *\n\t * @param model The model definition to enumerate relationships of.\n\t */\n\tstatic allFrom<T>(model: ModelMeta<T>) {\n\t\tconst relationships: ModelRelationship<T>[] = [];\n\t\tfor (const field of Object.keys(model.schema.fields)) {\n\t\t\tconst relationship = ModelRelationship.from(model, field);\n\t\t\trelationship && relationships.push(relationship);\n\t\t}\n\t\treturn relationships;\n\t}\n\n\tprivate get localDefinition() {\n\t\treturn this.localModel.schema;\n\t}\n\n\t/**\n\t * The virtual/computed field on the local model that should contain\n\t * the related model.\n\t */\n\tget field() {\n\t\treturn this._field;\n\t}\n\n\t/**\n\t * The constructor that can be used to query DataStore or create instance for\n\t * the local model.\n\t */\n\tget localConstructor() {\n\t\treturn this.localModel.builder;\n\t}\n\n\t/**\n\t * The name/type of the relationship the local model has with the remote model\n\t * via the defined local model field.\n\t */\n\tget type() {\n\t\treturn this.localAssocation.connectionType;\n\t}\n\n\t/**\n\t * Raw details about the local FK as-is from the local model's field definition in\n\t * the schema. This field requires interpretation.\n\t *\n\t * @see localJoinFields\n\t * @see localAssociatedWith\n\t */\n\tprivate get localAssocation() {\n\t\treturn this.localDefinition.fields[this.field].association!;\n\t}\n\n\t/**\n\t * The field names on the local model that can be used to query or queried to match\n\t * with instances of the remote model.\n\t *\n\t * Fields are returned in-order to match the order of `this.remoteKeyFields`.\n\t */\n\tget localJoinFields() {\n\t\t/**\n\t\t * This is relatively straightforward, actually.\n\t\t *\n\t\t * If we have explicitly stated targetNames, codegen is telling us authoritatively\n\t\t * to use those fields for this relationship. The local model \"points to\" fields\n\t\t * in the remote one.\n\t\t *\n\t\t * In other cases, the remote model points to this one's\n\t\t */\n\t\tif (this.localAssocation.targetName) {\n\t\t\t// This case is theoretically unnecessary going forward.\n\t\t\treturn [this.localAssocation.targetName];\n\t\t} else if (this.localAssocation.targetNames) {\n\t\t\treturn this.localAssocation.targetNames;\n\t\t} else {\n\t\t\treturn this.localPKFields;\n\t\t}\n\t}\n\n\t/**\n\t * The field names on the local model that uniquely identify it.\n\t *\n\t * These fields may or may not be relevant to the join fields.\n\t */\n\tget localPKFields() {\n\t\treturn this.localModel.pkField;\n\t}\n\n\tget remoteDefinition() {\n\t\treturn this.remoteModelType.modelConstructor?.schema;\n\t}\n\n\tprivate get remoteModelType() {\n\t\treturn this.localDefinition.fields[this.field].type as ModelFieldType;\n\t}\n\n\t/**\n\t * Constructor that can be used to query DataStore or create instances for\n\t * the remote model.\n\t */\n\tget remoteModelConstructor() {\n\t\treturn this.remoteModelType.modelConstructor!.builder!;\n\t}\n\n\t/**\n\t * The field names on the remote model that uniquely identify it.\n\t *\n\t * These fields may or may not be relevant to the join fields.\n\t */\n\tget remotePKFields() {\n\t\treturn this.remoteModelType.modelConstructor?.pkField || ['id'];\n\t}\n\n\t/**\n\t * The `associatedWith` fields from the local perspective.\n\t *\n\t * When present, these fields indicate which fields on the remote model to use\n\t * when looking for a remote association and/or determining the final remote\n\t * key fields.\n\t */\n\tprivate get localAssociatedWith() {\n\t\tif (\n\t\t\tthis.localAssocation.connectionType === 'HAS_MANY' ||\n\t\t\tthis.localAssocation.connectionType === 'HAS_ONE'\n\t\t) {\n\t\t\t// This de-arraying is theoretically unnecessary going forward.\n\t\t\treturn Array.isArray(this.localAssocation.associatedWith)\n\t\t\t\t? this.localAssocation.associatedWith\n\t\t\t\t: [this.localAssocation.associatedWith];\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tprivate get explicitRemoteAssociation() {\n\t\tif (this.localAssociatedWith) {\n\t\t\tif (this.localAssociatedWith.length === 1) {\n\t\t\t\treturn this.remoteDefinition!.fields[this.localAssociatedWith[0]]\n\t\t\t\t\t?.association;\n\t\t\t} else {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The field names on the remote model that can used to query or queried to match\n\t * with instances of the local model.\n\t *\n\t * Fields are returned in-order to match the order of `this.localKeyFields`.\n\t */\n\tget remoteJoinFields() {\n\t\t/**\n\t\t * If the local relationship explicitly names \"associated with\" fields, we\n\t\t * need to see if this points direction to a reciprocating assocation. If it\n\t\t * does, the remote assocation indicates what fields to use.\n\t\t */\n\n\t\tif (this.explicitRemoteAssociation?.targetName) {\n\t\t\t// This case is theoretically unnecessary going forward.\n\t\t\treturn [this.explicitRemoteAssociation.targetName!];\n\t\t} else if (this.explicitRemoteAssociation?.targetNames) {\n\t\t\treturn this.explicitRemoteAssociation?.targetNames!;\n\t\t} else if (this.localAssociatedWith) {\n\t\t\treturn this.localAssociatedWith;\n\t\t} else {\n\t\t\treturn this.remotePKFields;\n\t\t}\n\t}\n\n\t/**\n\t * Whether this relationship everything necessary to get, set, and query from\n\t * the perspective of the local model provided at instantiation.\n\t */\n\tget isComplete() {\n\t\treturn this.localJoinFields.length > 0 && this.remoteJoinFields.length > 0;\n\t}\n\n\t/**\n\t * Creates an FK mapper object with respect to the given related instance.\n\t *\n\t * E.g., if the local FK fields are `[parentId, parentName]` and point to\n\t * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n\t * will return:\n\t *\n\t * ```\n\t * {\n\t * \tparentId: remote.customId,\n\t * \tparentName: remote.name\n\t * }\n\t * ```\n\t *\n\t * @param remote The remote related instance.\n\t */\n\tcreateLocalFKObject(remote: any) {\n\t\tconst fk = {} as Record<string, string>;\n\t\tfor (let i = 0; i < this.localJoinFields.length; i++) {\n\t\t\tfk[this.localJoinFields[i]] = remote[this.remoteJoinFields[i]];\n\t\t}\n\t\treturn fk;\n\t}\n\n\t/**\n\t * Creates an query mapper object to help fetch the remote instance(s) or\n\t * `null` if any of the necessary local fields are `null` or `undefined`.\n\t *\n\t * E.g., if the local FK fields are `[parentId, parentName]` and point to\n\t * `[customId, name]` on the remote model, `createLocalFKObject(remote)`\n\t * will return:\n\t *\n\t * ```\n\t * {\n\t * \tcustomId: local.parentId\n\t * \tname: local.parentName\n\t * }\n\t * ```\n\t *\n\t * If the local fields are not populated, returns\n\t *\n\t * @param local The local instance.\n\t */\n\tcreateRemoteQueryObject(local: T) {\n\t\tconst query = {} as Record<string, string>;\n\t\tfor (let i = 0; i < this.remoteJoinFields.length; i++) {\n\t\t\tconst localValue = local[this.localJoinFields[i]];\n\t\t\tif (localValue === null || localValue === undefined) return null;\n\t\t\tquery[this.remoteJoinFields[i]] = local[this.localJoinFields[i]];\n\t\t}\n\t\treturn query;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}