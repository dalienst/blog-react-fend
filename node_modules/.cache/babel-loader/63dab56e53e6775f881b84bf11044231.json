{"ast":null,"code":"import $kqwpH$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport { createContext as $kqwpH$createContext, forwardRef as $kqwpH$forwardRef, useContext as $kqwpH$useContext, useState as $kqwpH$useState, useEffect as $kqwpH$useEffect, createElement as $kqwpH$createElement, useRef as $kqwpH$useRef } from \"react\";\nimport { composeEventHandlers as $kqwpH$composeEventHandlers } from \"@radix-ui/primitive\";\nimport { Primitive as $kqwpH$Primitive, dispatchDiscreteCustomEvent as $kqwpH$dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useComposedRefs as $kqwpH$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useCallbackRef as $kqwpH$useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useEscapeKeydown as $kqwpH$useEscapeKeydown } from \"@radix-ui/react-use-escape-keydown\";\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst $5cb92bef7577960e$var$DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst $5cb92bef7577960e$var$CONTEXT_UPDATE = 'dismissableLayer.update';\nconst $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst $5cb92bef7577960e$var$FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\nlet $5cb92bef7577960e$var$originalBodyPointerEvents;\nconst $5cb92bef7577960e$var$DismissableLayerContext = /*#__PURE__*/$kqwpH$createContext({\n  layers: new Set(),\n  layersWithOutsidePointerEventsDisabled: new Set(),\n  branches: new Set()\n});\nconst $5cb92bef7577960e$export$177fb62ff3ec1f22 = /*#__PURE__*/$kqwpH$forwardRef((props, forwardedRef) => {\n  const {\n    disableOutsidePointerEvents = false,\n    onEscapeKeyDown: onEscapeKeyDown,\n    onPointerDownOutside: onPointerDownOutside,\n    onFocusOutside: onFocusOutside,\n    onInteractOutside: onInteractOutside,\n    onDismiss: onDismiss,\n    ...layerProps\n  } = props;\n  const context = $kqwpH$useContext($5cb92bef7577960e$var$DismissableLayerContext);\n  const [node1, setNode] = $kqwpH$useState(null);\n  const [, force] = $kqwpH$useState({});\n  const composedRefs = $kqwpH$useComposedRefs(forwardedRef, node => setNode(node));\n  const layers = Array.from(context.layers);\n  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n\n  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n\n  const index = node1 ? layers.indexOf(node1) : -1;\n  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n  const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside(event => {\n    const target = event.target;\n    const isPointerDownOnBranch = [...context.branches].some(branch => branch.contains(target));\n    if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);\n    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);\n    if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();\n  });\n  const focusOutside = $5cb92bef7577960e$var$useFocusOutside(event => {\n    const target = event.target;\n    const isFocusInBranch = [...context.branches].some(branch => branch.contains(target));\n    if (isFocusInBranch) return;\n    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);\n    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);\n    if (!event.defaultPrevented) onDismiss === null || onDismiss === void 0 || onDismiss();\n  });\n  $kqwpH$useEscapeKeydown(event => {\n    const isHighestLayer = index === context.layers.size - 1;\n    if (!isHighestLayer) return;\n    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);\n\n    if (!event.defaultPrevented && onDismiss) {\n      event.preventDefault();\n      onDismiss();\n    }\n  });\n  $kqwpH$useEffect(() => {\n    if (!node1) return;\n\n    if (disableOutsidePointerEvents) {\n      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n        $5cb92bef7577960e$var$originalBodyPointerEvents = document.body.style.pointerEvents;\n        document.body.style.pointerEvents = 'none';\n      }\n\n      context.layersWithOutsidePointerEventsDisabled.add(node1);\n    }\n\n    context.layers.add(node1);\n    $5cb92bef7577960e$var$dispatchUpdate();\n    return () => {\n      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) document.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;\n    };\n  }, [node1, disableOutsidePointerEvents, context]);\n  /**\n  * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n  * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n  * and add it to the end again so the layering order wouldn't be _creation order_.\n  * We only want them to be removed from context stacks when unmounted.\n  */\n\n  $kqwpH$useEffect(() => {\n    return () => {\n      if (!node1) return;\n      context.layers.delete(node1);\n      context.layersWithOutsidePointerEventsDisabled.delete(node1);\n      $5cb92bef7577960e$var$dispatchUpdate();\n    };\n  }, [node1, context]);\n  $kqwpH$useEffect(() => {\n    const handleUpdate = () => force({});\n\n    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);\n    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);\n  }, []);\n  return /*#__PURE__*/$kqwpH$createElement($kqwpH$Primitive.div, $kqwpH$babelruntimehelpersesmextends({}, layerProps, {\n    ref: composedRefs,\n    style: {\n      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? 'auto' : 'none' : undefined,\n      ...props.style\n    },\n    onFocusCapture: $kqwpH$composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),\n    onBlurCapture: $kqwpH$composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),\n    onPointerDownCapture: $kqwpH$composeEventHandlers(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)\n  }));\n});\n/*#__PURE__*/\n\nObject.assign($5cb92bef7577960e$export$177fb62ff3ec1f22, {\n  displayName: $5cb92bef7577960e$var$DISMISSABLE_LAYER_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst $5cb92bef7577960e$var$BRANCH_NAME = 'DismissableLayerBranch';\nconst $5cb92bef7577960e$export$4d5eb2109db14228 = /*#__PURE__*/$kqwpH$forwardRef((props, forwardedRef) => {\n  const context = $kqwpH$useContext($5cb92bef7577960e$var$DismissableLayerContext);\n  const ref = $kqwpH$useRef(null);\n  const composedRefs = $kqwpH$useComposedRefs(forwardedRef, ref);\n  $kqwpH$useEffect(() => {\n    const node = ref.current;\n\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n  return /*#__PURE__*/$kqwpH$createElement($kqwpH$Primitive.div, $kqwpH$babelruntimehelpersesmextends({}, props, {\n    ref: composedRefs\n  }));\n});\n/*#__PURE__*/\n\nObject.assign($5cb92bef7577960e$export$4d5eb2109db14228, {\n  displayName: $5cb92bef7577960e$var$BRANCH_NAME\n});\n/* -----------------------------------------------------------------------------------------------*/\n\n/**\n* Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n* to mimic layer dismissing behaviour present in OS.\n* Returns props to pass to the node we want to check for outside events.\n*/\n\nfunction $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside) {\n  const handlePointerDownOutside = $kqwpH$useCallbackRef(onPointerDownOutside);\n  const isPointerInsideReactTreeRef = $kqwpH$useRef(false);\n  const handleClickRef = $kqwpH$useRef(() => {});\n  $kqwpH$useEffect(() => {\n    const handlePointerDown = event => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = {\n          originalEvent: event\n        };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {\n            discrete: true\n          });\n        }\n        /**\n        * On touch devices, we need to wait for a click event because browsers implement\n        * a ~350ms delay between the time the user stops touching the display and when the\n        * browser executres events. We need to ensure we don't reactivate pointer-events within\n        * this timeframe otherwise the browser may execute events that should have been prevented.\n        *\n        * Additionally, this also lets us deal automatically with cancellations when a click event\n        * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n        *\n        * This is why we also continuously remove the previous listener, because we cannot be\n        * certain that it was raised, and therefore cleaned-up.\n        */\n\n\n        if (event.pointerType === 'touch') {\n          document.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          document.addEventListener('click', handleClickRef.current, {\n            once: true\n          });\n        } else handleAndDispatchPointerDownOutsideEvent();\n      }\n\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n    * if this hook executes in a component that mounts via a `pointerdown` event, the event\n    * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n    * this by delaying the event listener registration on the document.\n    * This is not React specific, but rather how the DOM works, ie:\n    * ```\n    * button.addEventListener('pointerdown', () => {\n    *   console.log('I will log');\n    *   document.addEventListener('pointerdown', () => {\n    *     console.log('I will also log');\n    *   })\n    * });\n    */\n\n\n    const timerId = window.setTimeout(() => {\n      document.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      document.removeEventListener('pointerdown', handlePointerDown);\n      document.removeEventListener('click', handleClickRef.current);\n    };\n  }, [handlePointerDownOutside]);\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true\n  };\n}\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\n\n\nfunction $5cb92bef7577960e$var$useFocusOutside(onFocusOutside) {\n  const handleFocusOutside = $kqwpH$useCallbackRef(onFocusOutside);\n  const isFocusInsideReactTreeRef = $kqwpH$useRef(false);\n  $kqwpH$useEffect(() => {\n    const handleFocus = event => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = {\n          originalEvent: event\n        };\n        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false\n        });\n      }\n    };\n\n    document.addEventListener('focusin', handleFocus);\n    return () => document.removeEventListener('focusin', handleFocus);\n  }, [handleFocusOutside]);\n  return {\n    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,\n    onBlurCapture: () => isFocusInsideReactTreeRef.current = false\n  };\n}\n\nfunction $5cb92bef7577960e$var$dispatchUpdate() {\n  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, _ref) {\n  let {\n    discrete: discrete\n  } = _ref;\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, {\n    bubbles: false,\n    cancelable: true,\n    detail: detail\n  });\n  if (handler) target.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) $kqwpH$dispatchDiscreteCustomEvent(target, event);else target.dispatchEvent(event);\n}\n\nconst $5cb92bef7577960e$export$be92b6f5f03c0fe9 = $5cb92bef7577960e$export$177fb62ff3ec1f22;\nconst $5cb92bef7577960e$export$aecb2ddcb55c95be = $5cb92bef7577960e$export$4d5eb2109db14228;\nexport { $5cb92bef7577960e$export$177fb62ff3ec1f22 as DismissableLayer, $5cb92bef7577960e$export$4d5eb2109db14228 as DismissableLayerBranch, $5cb92bef7577960e$export$be92b6f5f03c0fe9 as Root, $5cb92bef7577960e$export$aecb2ddcb55c95be as Branch };","map":{"version":3,"mappings":"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","names":["DISMISSABLE_LAYER_NAME","CONTEXT_UPDATE","POINTER_DOWN_OUTSIDE","FOCUS_OUTSIDE","originalBodyPointerEvents","DismissableLayerContext","React","layers","Set","layersWithOutsidePointerEventsDisabled","branches","DismissableLayer","props","forwardedRef","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","onDismiss","layerProps","context","node","setNode","force","composedRefs","useComposedRefs","Array","from","highestLayerWithOutsidePointerEventsDisabled","slice","highestLayerWithOutsidePointerEventsDisabledIndex","indexOf","index","isBodyPointerEventsDisabled","size","isPointerEventsEnabled","pointerDownOutside","usePointerDownOutside","event","target","isPointerDownOnBranch","some","branch","contains","defaultPrevented","focusOutside","useFocusOutside","isFocusInBranch","useEscapeKeydown","isHighestLayer","preventDefault","document","body","style","pointerEvents","add","dispatchUpdate","delete","handleUpdate","addEventListener","removeEventListener","$kqwpH$createElement","$kqwpH$Primitive","div","ref","undefined","onFocusCapture","composeEventHandlers","onBlurCapture","onPointerDownCapture","Object","displayName","BRANCH_NAME","DismissableLayerBranch","current","handlePointerDownOutside","useCallbackRef","isPointerInsideReactTreeRef","handleClickRef","handlePointerDown","eventDetail","originalEvent","handleAndDispatchPointerDownOutsideEvent","handleAndDispatchCustomEvent","discrete","pointerType","once","timerId","window","setTimeout","clearTimeout","handleFocusOutside","isFocusInsideReactTreeRef","handleFocus","CustomEvent","dispatchEvent","name","handler","detail","bubbles","cancelable","dispatchDiscreteCustomEvent","Root","Branch"],"sources":["/home/dalienst/node_modules/@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/DismissableLayer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    });\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = document.body.style.pointerEvents;\n          document.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          document.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ElementRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(onPointerDownOutside?: (event: PointerDownOutsideEvent) => void) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          document.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          document.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      document.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      document.removeEventListener('pointerdown', handlePointerDown);\n      document.removeEventListener('click', handleClickRef.current);\n    };\n  }, [handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(onFocusOutside?: (event: FocusOutsideEvent) => void) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    document.addEventListener('focusin', handleFocus);\n    return () => document.removeEventListener('focusin', handleFocus);\n  }, [handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n"]},"metadata":{},"sourceType":"module"}