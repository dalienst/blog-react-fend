{"ast":null,"code":"import $45QHv$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport { forwardRef as $45QHv$forwardRef, useState as $45QHv$useState, useRef as $45QHv$useRef, useEffect as $45QHv$useEffect, useCallback as $45QHv$useCallback, createElement as $45QHv$createElement } from \"react\";\nimport { useComposedRefs as $45QHv$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive as $45QHv$Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef as $45QHv$useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/$45QHv$forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container1, setContainer] = $45QHv$useState(null);\n  const onMountAutoFocus = $45QHv$useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $45QHv$useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = $45QHv$useRef(null);\n  const composedRefs = $45QHv$useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = $45QHv$useRef({\n    paused: false,\n\n    pause() {\n      this.paused = true;\n    },\n\n    resume() {\n      this.paused = false;\n    }\n\n  }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n\n  $45QHv$useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event) {\n        if (focusScope.paused || !container1) return;\n        const target = event.target;\n        if (container1.contains(target)) lastFocusedElementRef.current = target;else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n\n      function handleFocusOut(event) {\n        if (focusScope.paused || !container1) return;\n        if (!container1.contains(event.relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container1, focusScope.paused]);\n  $45QHv$useEffect(() => {\n    if (container1) {\n      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n\n        if (!mountEvent.defaultPrevented) {\n          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);\n        }\n      }\n\n      return () => {\n        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n            select: true\n          }); // we need to remove the listener after we `dispatchEvent`\n\n          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope]); // Takes care of looping focus (when tabbing whilst at the edges)\n\n  const handleKeyDown = $45QHv$useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /*#__PURE__*/$45QHv$createElement($45QHv$Primitive.div, $45QHv$babelruntimehelpersesmextends({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\n/*#__PURE__*/\n\nObject.assign($d3863c46a17e8a28$export$20e40289641fbbb6, {\n  displayName: $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n* Attempts focusing the first element in a list of candidates.\n* Stops when focus has actually moved.\n*/\n\nfunction $d3863c46a17e8a28$var$focusFirst(candidates) {\n  let {\n    select = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const previouslyFocusedElement = document.activeElement;\n\n  for (const candidate of candidates) {\n    $d3863c46a17e8a28$var$focus(candidate, {\n      select: select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */\n\n\nfunction $d3863c46a17e8a28$var$getTabbableEdges(container) {\n  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\n\n\nfunction $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n\n\n  return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\n\n\nfunction $d3863c46a17e8a28$var$findVisible(elements, container) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!$d3863c46a17e8a28$var$isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\n\nfunction $d3863c46a17e8a28$var$isHidden(node, _ref) {\n  let {\n    upTo: upTo\n  } = _ref;\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n\n  return false;\n}\n\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction $d3863c46a17e8a28$var$focus(element) {\n  let {\n    select = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n\n    element.focus({\n      preventScroll: true\n    }); // only select if its not the same element, it supports selection and we need to select\n\n    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();\n  }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\n\nconst $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\n\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack = [];\n  return {\n    add(focusScope) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause(); // remove in case it already exists (because we'll re-add it at the top of the stack)\n\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope) {\n      var _stack$;\n\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n\n  };\n}\n\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) updatedArray.splice(index, 1);\n  return updatedArray;\n}\n\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n  return items.filter(item => item.tagName !== 'A');\n}\n\nconst $d3863c46a17e8a28$export$be92b6f5f03c0fe9 = $d3863c46a17e8a28$export$20e40289641fbbb6;\nexport { $d3863c46a17e8a28$export$20e40289641fbbb6 as FocusScope, $d3863c46a17e8a28$export$be92b6f5f03c0fe9 as Root };","map":{"version":3,"mappings":"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","names":["AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","bubbles","cancelable","FOCUS_SCOPE_NAME","FocusScope","React","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","useCallbackRef","lastFocusedElementRef","composedRefs","useComposedRefs","node","focusScope","paused","pause","resume","current","handleFocusIn","event","target","contains","focus","select","handleFocusOut","relatedTarget","document","addEventListener","removeEventListener","focusScopesStack","add","previouslyFocusedElement","activeElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","focusFirst","removeLinks","getTabbableCandidates","setTimeout","unmountEvent","body","remove","handleKeyDown","isTabKey","key","altKey","ctrlKey","metaKey","focusedElement","currentTarget","first","last","getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","$45QHv$createElement","$45QHv$Primitive","div","$45QHv$babelruntimehelpersesmextends","tabIndex","ref","onKeyDown","Object","displayName","candidates","candidate","findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","undefined","display","parentElement","isSelectableInput","HTMLInputElement","preventScroll","createFocusScopesStack","stack","activeFocusScope","arrayRemove","unshift","array","item","updatedArray","index","indexOf","splice","items","filter","Root"],"sources":["/home/dalienst/node_modules/@radix-ui/react-focus-scope/dist/packages/react/focus-scope/src/FocusScope.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        if (!container.contains(event.relatedTarget as HTMLElement | null)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"]},"metadata":{},"sourceType":"module"}