{"ast":null,"code":"import { __awaiter, __generator, __read, __spread } from \"tslib\";\nimport { UploadPartCommand, CompleteMultipartUploadCommand, AbortMultipartUploadCommand, ListPartsCommand, CreateMultipartUploadCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';\nimport axios from 'axios';\nimport { Logger } from '@aws-amplify/core';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport { SET_CONTENT_LENGTH_HEADER, UPLOADS_STORAGE_KEY } from '../common/StorageConstants';\nvar logger = new Logger('AWSS3UploadTask');\nexport var AWSS3UploadTaskState;\n\n(function (AWSS3UploadTaskState) {\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"INIT\"] = 0] = \"INIT\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"IN_PROGRESS\"] = 1] = \"IN_PROGRESS\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"PAUSED\"] = 2] = \"PAUSED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"CANCELLED\"] = 3] = \"CANCELLED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"COMPLETED\"] = 4] = \"COMPLETED\";\n})(AWSS3UploadTaskState || (AWSS3UploadTaskState = {}));\n\nexport var TaskEvents;\n\n(function (TaskEvents) {\n  TaskEvents[\"CANCEL\"] = \"cancel\";\n  TaskEvents[\"UPLOAD_COMPLETE\"] = \"uploadComplete\";\n  TaskEvents[\"UPLOAD_PROGRESS\"] = \"uploadPartProgress\";\n  TaskEvents[\"ERROR\"] = \"error\";\n})(TaskEvents || (TaskEvents = {})); // maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\n\n\nvar MAX_PARTS = 10000; // 5MB in bytes\n\nvar PART_SIZE = 5 * 1024 * 1024;\nvar DEFAULT_QUEUE_SIZE = 4;\n\nfunction comparePartNumber(a, b) {\n  return a.PartNumber - b.PartNumber;\n}\n\nvar AWSS3UploadTask =\n/** @class */\nfunction () {\n  function AWSS3UploadTask(_a) {\n    var s3Client = _a.s3Client,\n        file = _a.file,\n        emitter = _a.emitter,\n        storage = _a.storage,\n        params = _a.params,\n        level = _a.level,\n        prefixPromise = _a.prefixPromise;\n    this.partSize = PART_SIZE;\n    this.queueSize = DEFAULT_QUEUE_SIZE;\n    this.inProgress = [];\n    this.completedParts = [];\n    this.queued = [];\n    this.bytesUploaded = 0;\n    this.totalBytes = 0;\n    this.state = AWSS3UploadTaskState.INIT;\n    this.prefixPromise = prefixPromise;\n    this.s3client = s3Client;\n    this.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n    this.storage = storage;\n    this.storageSync = Promise.resolve();\n\n    if (typeof this.storage['sync'] === 'function') {\n      this.storageSync = this.storage['sync']();\n    }\n\n    this.params = params;\n    this.file = file;\n    this.totalBytes = this.file.size;\n    this.bytesUploaded = 0;\n    this.emitter = emitter;\n    this.queued = [];\n    this.fileId = this._getFileId(level);\n\n    this._validateParams(); // event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n    // function to it unless user adds their own onError callback\n\n\n    this.emitter.on(TaskEvents.ERROR, function () {});\n  }\n\n  Object.defineProperty(AWSS3UploadTask.prototype, \"percent\", {\n    get: function () {\n      return this.bytesUploaded / this.totalBytes * 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AWSS3UploadTask.prototype, \"isInProgress\", {\n    get: function () {\n      return this.state === AWSS3UploadTaskState.IN_PROGRESS;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AWSS3UploadTask.prototype._listSingleFile = function (_a) {\n    var key = _a.key,\n        bucket = _a.bucket;\n    return __awaiter(this, void 0, void 0, function () {\n      var listObjectRes, _b, Contents, prefix, obj;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListObjectsV2Command({\n              Bucket: bucket,\n              Prefix: key\n            }))];\n\n          case 1:\n            listObjectRes = _c.sent();\n            _b = listObjectRes.Contents, Contents = _b === void 0 ? [] : _b;\n            return [4\n            /*yield*/\n            , this.prefixPromise];\n\n          case 2:\n            prefix = _c.sent();\n            obj = Contents.find(function (o) {\n              return o.Key === \"\" + prefix + key;\n            });\n            return [2\n            /*return*/\n            , obj];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._getFileId = function (level) {\n    // We should check if it's a File first because File is also instance of a Blob\n    if (isFile(this.file)) {\n      return [this.file.name, this.file.lastModified, this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    } else {\n      return [this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    }\n  };\n\n  AWSS3UploadTask.prototype._findCachedUploadParts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests, cachedUploadFileData, listPartsOutput;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n\n            if (Object.keys(uploadRequests).length === 0 || !Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)) {\n              return [2\n              /*return*/\n              , {\n                parts: [],\n                uploadId: null\n              }];\n            }\n\n            cachedUploadFileData = uploadRequests[this.fileId];\n            cachedUploadFileData.lastTouched = Date.now();\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListPartsCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: cachedUploadFileData.uploadId\n            }))];\n\n          case 2:\n            listPartsOutput = _a.sent();\n            return [2\n            /*return*/\n            , {\n              parts: listPartsOutput.Parts || [],\n              uploadId: cachedUploadFileData.uploadId\n            }];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._emitEvent = function (event, payload) {\n    this.emitter.emit(event, payload);\n  };\n\n  AWSS3UploadTask.prototype._validateParams = function () {\n    if (this.file.size / this.partSize > MAX_PARTS) {\n      throw new Error(\"Too many parts. Number of parts is \" + this.file.size / this.partSize + \", maximum is \" + MAX_PARTS + \".\");\n    }\n  };\n\n  AWSS3UploadTask.prototype._listCachedUploadTasks = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tasks;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.storageSync];\n\n          case 1:\n            _a.sent();\n\n            tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n            return [2\n            /*return*/\n            , JSON.parse(tasks)];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._cache = function (fileMetadata) {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            uploadRequests[this.fileId] = fileMetadata;\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isCached = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = (_a = Object.prototype.hasOwnProperty).call;\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _b.apply(_a, [_c.sent(), this.fileId])];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._removeFromCache = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            delete uploadRequests[this.fileId];\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._onPartUploadCompletion = function (_a) {\n    var eTag = _a.eTag,\n        partNumber = _a.partNumber,\n        chunk = _a.chunk;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        this.completedParts.push({\n          ETag: eTag,\n          PartNumber: partNumber\n        });\n        this.bytesUploaded += byteLength(chunk);\n\n        this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n          loaded: this.bytesUploaded,\n          total: this.totalBytes\n        }); // Remove the completed item from the inProgress array\n\n\n        this.inProgress = this.inProgress.filter(function (job) {\n          return job.uploadPartInput.PartNumber !== partNumber;\n        });\n        if (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED) this._startNextPart();\n        if (this._isDone()) this._completeUpload();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._completeUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new CompleteMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId,\n              MultipartUpload: {\n                // Parts are not always completed in order, we need to manually sort them\n                Parts: this.completedParts.sort(comparePartNumber)\n              }\n            }))];\n\n          case 1:\n            _a.sent();\n\n            this._verifyFileSize();\n\n            this._emitEvent(TaskEvents.UPLOAD_COMPLETE, {\n              key: this.params.Key\n            });\n\n            this._removeFromCache();\n\n            this.state = AWSS3UploadTaskState.COMPLETED;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            err_1 = _a.sent();\n            logger.error('error completing upload', err_1);\n\n            this._emitEvent(TaskEvents.ERROR, err_1);\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._makeUploadPartRequest = function (input, cancelTokenSource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var res, err_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new UploadPartCommand(input), {\n              cancelTokenSource: cancelTokenSource\n            })];\n\n          case 1:\n            res = _a.sent();\n            return [4\n            /*yield*/\n            , this._onPartUploadCompletion({\n              eTag: res.ETag,\n              partNumber: input.PartNumber,\n              chunk: input.Body\n            })];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_2 = _a.sent();\n\n            if (this.state === AWSS3UploadTaskState.PAUSED) {\n              logger.log('upload paused');\n            } else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n              logger.log('upload aborted');\n            } else {\n              logger.error('error starting next part of upload: ', err_2);\n            } // axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n            // expected behavior\n\n\n            if (!axios.isCancel(err_2) && err_2.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE) {\n              this._emitEvent(TaskEvents.ERROR, err_2);\n\n              this.pause();\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._startNextPart = function () {\n    if (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n      var cancelTokenSource = axios.CancelToken.source();\n      var nextPart = this.queued.shift();\n      this.inProgress.push({\n        uploadPartInput: nextPart,\n        s3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n        cancel: cancelTokenSource.cancel\n      });\n    }\n  };\n  /**\n   * Verify on S3 side that the file size matches the one on the client side.\n   *\n   * @async\n   * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n   */\n\n\n  AWSS3UploadTask.prototype._verifyFileSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var obj, valid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listSingleFile({\n              key: this.params.Key,\n              bucket: this.params.Bucket\n            })];\n\n          case 1:\n            obj = _a.sent();\n            valid = Boolean(obj && obj.Size === this.file.size);\n\n            if (!valid) {\n              throw new Error('File size does not match between local file and file on s3');\n            }\n\n            return [2\n            /*return*/\n            , valid];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isDone = function () {\n    return !this.queued.length && !this.inProgress.length && this.bytesUploaded === this.totalBytes;\n  };\n\n  AWSS3UploadTask.prototype._createParts = function () {\n    var size = this.file.size;\n    var parts = [];\n\n    for (var bodyStart = 0; bodyStart < size;) {\n      var bodyEnd = Math.min(bodyStart + this.partSize, size);\n      parts.push({\n        Body: this.file.slice(bodyStart, bodyEnd),\n        Key: this.params.Key,\n        Bucket: this.params.Bucket,\n        PartNumber: parts.length + 1,\n        UploadId: this.uploadId\n      });\n      bodyStart += this.partSize;\n    }\n\n    return parts;\n  };\n\n  AWSS3UploadTask.prototype._initCachedUploadParts = function (cachedParts) {\n    this.bytesUploaded += cachedParts.reduce(function (acc, part) {\n      return acc + part.Size;\n    }, 0); // Find the set of part numbers that have already been uploaded\n\n    var uploadedPartNumSet = new Set(cachedParts.map(function (part) {\n      return part.PartNumber;\n    }));\n    this.queued = this.queued.filter(function (part) {\n      return !uploadedPartNumSet.has(part.PartNumber);\n    });\n    this.completedParts = cachedParts.map(function (part) {\n      return {\n        PartNumber: part.PartNumber,\n        ETag: part.ETag\n      };\n    });\n\n    this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n      loaded: this.bytesUploaded,\n      total: this.totalBytes\n    });\n  };\n\n  AWSS3UploadTask.prototype._initMultipartUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new CreateMultipartUploadCommand(this.params))];\n\n          case 1:\n            res = _a.sent();\n\n            this._cache({\n              uploadId: res.UploadId,\n              lastTouched: Date.now(),\n              bucket: this.params.Bucket,\n              key: this.params.Key,\n              fileName: this.file instanceof File ? this.file.name : ''\n            });\n\n            return [2\n            /*return*/\n            , res.UploadId];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._initializeUploadTask = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, parts, uploadId, uploadId, err_3;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.state = AWSS3UploadTaskState.IN_PROGRESS;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this._isCached()];\n\n          case 2:\n            if (!_b.sent()) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this._findCachedUploadParts()];\n\n          case 3:\n            _a = _b.sent(), parts = _a.parts, uploadId = _a.uploadId;\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._initCachedUploadParts(parts);\n\n            this._startUpload();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            if (!!this.uploadId) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this._initMultipartUpload()];\n\n          case 5:\n            uploadId = _b.sent();\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._startUpload();\n\n            _b.label = 6;\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            err_3 = _b.sent();\n\n            if (!axios.isCancel(err_3)) {\n              logger.error('Error initializing the upload task', err_3);\n            }\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype.resume = function () {\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n      logger.warn('Upload task already in progress'); // first time running resume, find any cached parts on s3 or start a new multipart upload request before\n      // starting the upload\n    } else if (!this.uploadId) {\n      this._initializeUploadTask();\n    } else {\n      this._startUpload();\n    }\n  };\n\n  AWSS3UploadTask.prototype._startUpload = function () {\n    this.state = AWSS3UploadTaskState.IN_PROGRESS;\n\n    for (var i = 0; i < this.queueSize; i++) {\n      this._startNextPart();\n    }\n  };\n\n  AWSS3UploadTask.prototype._cancel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.state === AWSS3UploadTaskState.CANCELLED)) return [3\n            /*break*/\n            , 1];\n            logger.warn('This task has already been cancelled');\n            return [2\n            /*return*/\n            , false];\n\n          case 1:\n            if (!(this.state === AWSS3UploadTaskState.COMPLETED)) return [3\n            /*break*/\n            , 2];\n            logger.warn('This task has already been completed');\n            return [2\n            /*return*/\n            , false];\n\n          case 2:\n            this.pause();\n            this.queued = [];\n            this.completedParts = [];\n            this.bytesUploaded = 0;\n            this.state = AWSS3UploadTaskState.CANCELLED;\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new AbortMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId\n            }))];\n\n          case 4:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._removeFromCache()];\n\n          case 5:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , true];\n\n          case 6:\n            err_4 = _a.sent();\n            logger.error('Error cancelling upload task', err_4);\n            return [2\n            /*return*/\n            , false];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * pause this particular upload task\n   **/\n\n\n  AWSS3UploadTask.prototype.pause = function () {\n    var _a;\n\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.PAUSED) {\n      logger.warn('This task is already paused');\n    }\n\n    this.state = AWSS3UploadTaskState.PAUSED; // Use axios cancel token to abort the part request immediately\n    // Add the inProgress parts back to pending\n\n    var removedInProgressReq = this.inProgress.splice(0, this.inProgress.length);\n    removedInProgressReq.forEach(function (req) {\n      req.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n    }); // Put all removed in progress parts back into the queue\n\n    (_a = this.queued).unshift.apply(_a, __spread(removedInProgressReq.map(function (req) {\n      return req.uploadPartInput;\n    })));\n  };\n\n  return AWSS3UploadTask;\n}();\n\nexport { AWSS3UploadTask };","map":{"version":3,"mappings":"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","names":["UploadPartCommand","CompleteMultipartUploadCommand","AbortMultipartUploadCommand","ListPartsCommand","CreateMultipartUploadCommand","ListObjectsV2Command","axios","Logger","byteLength","isFile","AWSS3ProviderUploadErrorStrings","SET_CONTENT_LENGTH_HEADER","UPLOADS_STORAGE_KEY","logger","AWSS3UploadTaskState","TaskEvents","MAX_PARTS","PART_SIZE","DEFAULT_QUEUE_SIZE","comparePartNumber","a","b","PartNumber","_a","s3Client","file","emitter","storage","params","level","prefixPromise","INIT","s3client","middlewareStack","remove","storageSync","Promise","resolve","totalBytes","size","bytesUploaded","queued","fileId","_getFileId","_validateParams","on","ERROR","Object","AWSS3UploadTask","state","IN_PROGRESS","key","bucket","send","Bucket","Prefix","listObjectRes","_c","_b","prefix","obj","Contents","find","Key","name","lastModified","type","join","_listCachedUploadTasks","uploadRequests","keys","length","prototype","hasOwnProperty","call","parts","uploadId","cachedUploadFileData","lastTouched","Date","now","setItem","JSON","stringify","UploadId","listPartsOutput","Parts","event","payload","emit","partSize","Error","tasks","getItem","parse","fileMetadata","eTag","partNumber","chunk","completedParts","push","ETag","_emitEvent","UPLOAD_PROGRESS","loaded","total","inProgress","filter","uploadPartInput","PAUSED","_startNextPart","_isDone","_completeUpload","MultipartUpload","sort","_verifyFileSize","UPLOAD_COMPLETE","_removeFromCache","COMPLETED","error","err_1","input","cancelTokenSource","res","_onPartUploadCompletion","Body","log","CANCELLED","err_2","isCancel","message","UPLOAD_PAUSED_MESSAGE","pause","CancelToken","source","nextPart","shift","s3Request","_makeUploadPartRequest","cancel","_listSingleFile","valid","Boolean","Size","bodyStart","bodyEnd","Math","min","slice","cachedParts","reduce","acc","part","uploadedPartNumSet","Set","map","has","_cache","fileName","File","_isCached","_findCachedUploadParts","_createParts","_initCachedUploadParts","_startUpload","_initMultipartUpload","err_3","warn","_initializeUploadTask","i","queueSize","err_4","removedInProgressReq","splice","forEach","req","unshift","apply","__spread"],"sources":["/home/dalienst/node_modules/@aws-amplify/storage/src/providers/AWSS3UploadTask.ts"],"sourcesContent":["import {\n\tUploadPartCommandInput,\n\tCompletedPart,\n\tS3Client,\n\tUploadPartCommand,\n\tCompleteMultipartUploadCommand,\n\tPart,\n\tAbortMultipartUploadCommand,\n\tListPartsCommand,\n\tCreateMultipartUploadCommand,\n\tPutObjectCommandInput,\n\tListObjectsV2Command,\n} from '@aws-sdk/client-s3';\nimport * as events from 'events';\nimport axios, { Canceler, CancelTokenSource } from 'axios';\nimport { HttpHandlerOptions } from '@aws-sdk/types';\nimport { Logger } from '@aws-amplify/core';\nimport { UploadTask } from '../types/Provider';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport {\n\tSET_CONTENT_LENGTH_HEADER,\n\tUPLOADS_STORAGE_KEY,\n} from '../common/StorageConstants';\nimport { StorageAccessLevel } from '..';\n\nconst logger = new Logger('AWSS3UploadTask');\nexport enum AWSS3UploadTaskState {\n\tINIT,\n\tIN_PROGRESS,\n\tPAUSED,\n\tCANCELLED,\n\tCOMPLETED,\n}\n\nexport enum TaskEvents {\n\tCANCEL = 'cancel',\n\tUPLOAD_COMPLETE = 'uploadComplete',\n\tUPLOAD_PROGRESS = 'uploadPartProgress',\n\tERROR = 'error',\n}\n\nexport interface AWSS3UploadTaskParams {\n\ts3Client: S3Client;\n\tfile: Blob;\n\tstorage: Storage;\n\tlevel: StorageAccessLevel;\n\tparams: PutObjectCommandInput;\n\tprefixPromise: Promise<string>;\n\temitter?: events.EventEmitter;\n}\n\nexport interface InProgressRequest {\n\tuploadPartInput: UploadPartCommandInput;\n\ts3Request: Promise<any>;\n\tcancel: Canceler;\n}\n\nexport interface UploadTaskCompleteEvent {\n\tkey?: string;\n}\n\nexport interface UploadTaskProgressEvent {\n\t/**\n\t * bytes that has been sent to S3 so far\n\t */\n\tloaded: number;\n\t/**\n\t * total bytes that needs to be sent to S3\n\t */\n\ttotal: number;\n}\n\nexport interface FileMetadata {\n\tbucket: string;\n\tfileName: string;\n\tkey: string;\n\t// Unix timestamp in ms\n\tlastTouched: number;\n\tuploadId: string;\n}\n\n// maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\nconst MAX_PARTS = 10000;\n// 5MB in bytes\nconst PART_SIZE = 5 * 1024 * 1024;\nconst DEFAULT_QUEUE_SIZE = 4;\n\nfunction comparePartNumber(a: CompletedPart, b: CompletedPart) {\n\treturn a.PartNumber - b.PartNumber;\n}\n\nexport class AWSS3UploadTask implements UploadTask {\n\tprivate readonly emitter: events.EventEmitter;\n\tprivate readonly file: Blob;\n\tprivate readonly partSize: number = PART_SIZE;\n\tprivate readonly queueSize = DEFAULT_QUEUE_SIZE;\n\tprivate readonly s3client: S3Client;\n\tprivate readonly storage: Storage;\n\tprivate readonly storageSync: Promise<any>;\n\tprivate readonly fileId: string;\n\tprivate readonly params: PutObjectCommandInput;\n\tprivate readonly prefixPromise: Promise<string>;\n\tprivate inProgress: InProgressRequest[] = [];\n\tprivate completedParts: CompletedPart[] = [];\n\tprivate queued: UploadPartCommandInput[] = [];\n\tprivate bytesUploaded: number = 0;\n\tprivate totalBytes: number = 0;\n\tprivate uploadId: string;\n\n\tpublic state: AWSS3UploadTaskState = AWSS3UploadTaskState.INIT;\n\n\tconstructor({\n\t\ts3Client,\n\t\tfile,\n\t\temitter,\n\t\tstorage,\n\t\tparams,\n\t\tlevel,\n\t\tprefixPromise,\n\t}: AWSS3UploadTaskParams) {\n\t\tthis.prefixPromise = prefixPromise;\n\t\tthis.s3client = s3Client;\n\t\tthis.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n\t\tthis.storage = storage;\n\t\tthis.storageSync = Promise.resolve();\n\t\tif (typeof this.storage['sync'] === 'function') {\n\t\t\tthis.storageSync = this.storage['sync']();\n\t\t}\n\t\tthis.params = params;\n\t\tthis.file = file;\n\t\tthis.totalBytes = this.file.size;\n\t\tthis.bytesUploaded = 0;\n\t\tthis.emitter = emitter;\n\t\tthis.queued = [];\n\t\tthis.fileId = this._getFileId(level);\n\t\tthis._validateParams();\n\t\t// event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n\t\t// function to it unless user adds their own onError callback\n\t\tthis.emitter.on(TaskEvents.ERROR, () => {});\n\t}\n\n\tget percent() {\n\t\treturn (this.bytesUploaded / this.totalBytes) * 100;\n\t}\n\n\tget isInProgress() {\n\t\treturn this.state === AWSS3UploadTaskState.IN_PROGRESS;\n\t}\n\n\tprivate async _listSingleFile({\n\t\tkey,\n\t\tbucket,\n\t}: {\n\t\tkey: string;\n\t\tbucket: string;\n\t}) {\n\t\tconst listObjectRes = await this.s3client.send(\n\t\t\tnew ListObjectsV2Command({\n\t\t\t\tBucket: bucket,\n\t\t\t\tPrefix: key,\n\t\t\t})\n\t\t);\n\t\tconst { Contents = [] } = listObjectRes;\n\t\tconst prefix = await this.prefixPromise;\n\t\tconst obj = Contents.find(o => o.Key === `${prefix}${key}`);\n\t\treturn obj;\n\t}\n\n\tprivate _getFileId(level: StorageAccessLevel): string {\n\t\t// We should check if it's a File first because File is also instance of a Blob\n\t\tif (isFile(this.file)) {\n\t\t\treturn [\n\t\t\t\tthis.file.name,\n\t\t\t\tthis.file.lastModified,\n\t\t\t\tthis.file.size,\n\t\t\t\tthis.file.type,\n\t\t\t\tthis.params.Bucket,\n\t\t\t\tlevel,\n\t\t\t\tthis.params.Key,\n\t\t\t].join('-');\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tthis.file.size,\n\t\t\t\tthis.file.type,\n\t\t\t\tthis.params.Bucket,\n\t\t\t\tlevel,\n\t\t\t\tthis.params.Key,\n\t\t\t].join('-');\n\t\t}\n\t}\n\n\tprivate async _findCachedUploadParts(): Promise<{\n\t\tparts: Part[];\n\t\tuploadId: string;\n\t}> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\n\t\tif (\n\t\t\tObject.keys(uploadRequests).length === 0 ||\n\t\t\t!Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)\n\t\t) {\n\t\t\treturn { parts: [], uploadId: null };\n\t\t}\n\n\t\tconst cachedUploadFileData = uploadRequests[this.fileId];\n\t\tcachedUploadFileData.lastTouched = Date.now();\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\n\t\tconst listPartsOutput = await this.s3client.send(\n\t\t\tnew ListPartsCommand({\n\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\tKey: this.params.Key,\n\t\t\t\tUploadId: cachedUploadFileData.uploadId,\n\t\t\t})\n\t\t);\n\n\t\treturn {\n\t\t\tparts: listPartsOutput.Parts || [],\n\t\t\tuploadId: cachedUploadFileData.uploadId,\n\t\t};\n\t}\n\n\tprivate _emitEvent<T = any>(event: string, payload: T) {\n\t\tthis.emitter.emit(event, payload);\n\t}\n\n\tprivate _validateParams() {\n\t\tif (this.file.size / this.partSize > MAX_PARTS) {\n\t\t\tthrow new Error(\n\t\t\t\t`Too many parts. Number of parts is ${\n\t\t\t\t\tthis.file.size / this.partSize\n\t\t\t\t}, maximum is ${MAX_PARTS}.`\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async _listCachedUploadTasks(): Promise<\n\t\tRecord<string, FileMetadata>\n\t> {\n\t\tawait this.storageSync;\n\t\tconst tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n\t\treturn JSON.parse(tasks);\n\t}\n\n\tprivate async _cache(fileMetadata: FileMetadata): Promise<void> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\t\tuploadRequests[this.fileId] = fileMetadata;\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\t}\n\n\tprivate async _isCached(): Promise<boolean> {\n\t\treturn Object.prototype.hasOwnProperty.call(\n\t\t\tawait this._listCachedUploadTasks(),\n\t\t\tthis.fileId\n\t\t);\n\t}\n\n\tprivate async _removeFromCache(): Promise<void> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\t\tdelete uploadRequests[this.fileId];\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\t}\n\n\tprivate async _onPartUploadCompletion({\n\t\teTag,\n\t\tpartNumber,\n\t\tchunk,\n\t}: {\n\t\teTag: string;\n\t\tpartNumber: number;\n\t\tchunk: UploadPartCommandInput['Body'];\n\t}) {\n\t\tthis.completedParts.push({\n\t\t\tETag: eTag,\n\t\t\tPartNumber: partNumber,\n\t\t});\n\t\tthis.bytesUploaded += byteLength(chunk);\n\t\tthis._emitEvent<UploadTaskProgressEvent>(TaskEvents.UPLOAD_PROGRESS, {\n\t\t\tloaded: this.bytesUploaded,\n\t\t\ttotal: this.totalBytes,\n\t\t});\n\t\t// Remove the completed item from the inProgress array\n\t\tthis.inProgress = this.inProgress.filter(\n\t\t\tjob => job.uploadPartInput.PartNumber !== partNumber\n\t\t);\n\t\tif (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED)\n\t\t\tthis._startNextPart();\n\t\tif (this._isDone()) this._completeUpload();\n\t}\n\n\tprivate async _completeUpload() {\n\t\ttry {\n\t\t\tawait this.s3client.send(\n\t\t\t\tnew CompleteMultipartUploadCommand({\n\t\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\t\tKey: this.params.Key,\n\t\t\t\t\tUploadId: this.uploadId,\n\t\t\t\t\tMultipartUpload: {\n\t\t\t\t\t\t// Parts are not always completed in order, we need to manually sort them\n\t\t\t\t\t\tParts: this.completedParts.sort(comparePartNumber),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis._verifyFileSize();\n\t\t\tthis._emitEvent<UploadTaskCompleteEvent>(TaskEvents.UPLOAD_COMPLETE, {\n\t\t\t\tkey: this.params.Key,\n\t\t\t});\n\t\t\tthis._removeFromCache();\n\t\t\tthis.state = AWSS3UploadTaskState.COMPLETED;\n\t\t} catch (err) {\n\t\t\tlogger.error('error completing upload', err);\n\t\t\tthis._emitEvent(TaskEvents.ERROR, err);\n\t\t}\n\t}\n\n\tprivate async _makeUploadPartRequest(\n\t\tinput: UploadPartCommandInput,\n\t\tcancelTokenSource: CancelTokenSource\n\t) {\n\t\ttry {\n\t\t\tconst res = await this.s3client.send(new UploadPartCommand(input), {\n\t\t\t\tcancelTokenSource,\n\t\t\t} as HttpHandlerOptions);\n\t\t\tawait this._onPartUploadCompletion({\n\t\t\t\teTag: res.ETag,\n\t\t\t\tpartNumber: input.PartNumber,\n\t\t\t\tchunk: input.Body,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (this.state === AWSS3UploadTaskState.PAUSED) {\n\t\t\t\tlogger.log('upload paused');\n\t\t\t} else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\t\tlogger.log('upload aborted');\n\t\t\t} else {\n\t\t\t\tlogger.error('error starting next part of upload: ', err);\n\t\t\t}\n\t\t\t// axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n\t\t\t// expected behavior\n\t\t\tif (\n\t\t\t\t!axios.isCancel(err) &&\n\t\t\t\terr.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE\n\t\t\t) {\n\t\t\t\tthis._emitEvent(TaskEvents.ERROR, err);\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _startNextPart() {\n\t\tif (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n\t\t\tconst cancelTokenSource = axios.CancelToken.source();\n\t\t\tconst nextPart = this.queued.shift();\n\t\t\tthis.inProgress.push({\n\t\t\t\tuploadPartInput: nextPart,\n\t\t\t\ts3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n\t\t\t\tcancel: cancelTokenSource.cancel,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Verify on S3 side that the file size matches the one on the client side.\n\t *\n\t * @async\n\t * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n\t */\n\tprivate async _verifyFileSize() {\n\t\tconst obj = await this._listSingleFile({\n\t\t\tkey: this.params.Key,\n\t\t\tbucket: this.params.Bucket,\n\t\t});\n\t\tconst valid = Boolean(obj && obj.Size === this.file.size);\n\t\tif (!valid) {\n\t\t\tthrow new Error(\n\t\t\t\t'File size does not match between local file and file on s3'\n\t\t\t);\n\t\t}\n\t\treturn valid;\n\t}\n\n\tprivate _isDone() {\n\t\treturn (\n\t\t\t!this.queued.length &&\n\t\t\t!this.inProgress.length &&\n\t\t\tthis.bytesUploaded === this.totalBytes\n\t\t);\n\t}\n\n\tprivate _createParts() {\n\t\tconst size = this.file.size;\n\t\tconst parts: UploadPartCommandInput[] = [];\n\t\tfor (let bodyStart = 0; bodyStart < size; ) {\n\t\t\tconst bodyEnd = Math.min(bodyStart + this.partSize, size);\n\t\t\tparts.push({\n\t\t\t\tBody: this.file.slice(bodyStart, bodyEnd),\n\t\t\t\tKey: this.params.Key,\n\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\tPartNumber: parts.length + 1,\n\t\t\t\tUploadId: this.uploadId,\n\t\t\t});\n\t\t\tbodyStart += this.partSize;\n\t\t}\n\t\treturn parts;\n\t}\n\n\tprivate _initCachedUploadParts(cachedParts: Part[]) {\n\t\tthis.bytesUploaded += cachedParts.reduce((acc, part) => acc + part.Size, 0);\n\t\t// Find the set of part numbers that have already been uploaded\n\t\tconst uploadedPartNumSet = new Set(\n\t\t\tcachedParts.map(part => part.PartNumber)\n\t\t);\n\t\tthis.queued = this.queued.filter(\n\t\t\tpart => !uploadedPartNumSet.has(part.PartNumber)\n\t\t);\n\t\tthis.completedParts = cachedParts.map(part => ({\n\t\t\tPartNumber: part.PartNumber,\n\t\t\tETag: part.ETag,\n\t\t}));\n\t\tthis._emitEvent<UploadTaskProgressEvent>(TaskEvents.UPLOAD_PROGRESS, {\n\t\t\tloaded: this.bytesUploaded,\n\t\t\ttotal: this.totalBytes,\n\t\t});\n\t}\n\n\tprivate async _initMultipartUpload() {\n\t\tconst res = await this.s3client.send(\n\t\t\tnew CreateMultipartUploadCommand(this.params)\n\t\t);\n\t\tthis._cache({\n\t\t\tuploadId: res.UploadId,\n\t\t\tlastTouched: Date.now(),\n\t\t\tbucket: this.params.Bucket,\n\t\t\tkey: this.params.Key,\n\t\t\tfileName: this.file instanceof File ? this.file.name : '',\n\t\t});\n\t\treturn res.UploadId;\n\t}\n\n\tprivate async _initializeUploadTask() {\n\t\tthis.state = AWSS3UploadTaskState.IN_PROGRESS;\n\t\ttry {\n\t\t\tif (await this._isCached()) {\n\t\t\t\tconst { parts, uploadId } = await this._findCachedUploadParts();\n\t\t\t\tthis.uploadId = uploadId;\n\t\t\t\tthis.queued = this._createParts();\n\t\t\t\tthis._initCachedUploadParts(parts);\n\t\t\t\tthis._startUpload();\n\t\t\t} else {\n\t\t\t\tif (!this.uploadId) {\n\t\t\t\t\tconst uploadId = await this._initMultipartUpload();\n\t\t\t\t\tthis.uploadId = uploadId;\n\t\t\t\t\tthis.queued = this._createParts();\n\t\t\t\t\tthis._startUpload();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (!axios.isCancel(err)) {\n\t\t\t\tlogger.error('Error initializing the upload task', err);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic resume(): void {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t} else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n\t\t\tlogger.warn('Upload task already in progress');\n\t\t\t// first time running resume, find any cached parts on s3 or start a new multipart upload request before\n\t\t\t// starting the upload\n\t\t} else if (!this.uploadId) {\n\t\t\tthis._initializeUploadTask();\n\t\t} else {\n\t\t\tthis._startUpload();\n\t\t}\n\t}\n\n\tprivate _startUpload() {\n\t\tthis.state = AWSS3UploadTaskState.IN_PROGRESS;\n\t\tfor (let i = 0; i < this.queueSize; i++) {\n\t\t\tthis._startNextPart();\n\t\t}\n\t}\n\n\tasync _cancel(): Promise<boolean> {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t\treturn false;\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthis.pause();\n\t\t\tthis.queued = [];\n\t\t\tthis.completedParts = [];\n\t\t\tthis.bytesUploaded = 0;\n\t\t\tthis.state = AWSS3UploadTaskState.CANCELLED;\n\t\t\ttry {\n\t\t\t\tawait this.s3client.send(\n\t\t\t\t\tnew AbortMultipartUploadCommand({\n\t\t\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\t\t\tKey: this.params.Key,\n\t\t\t\t\t\tUploadId: this.uploadId,\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tawait this._removeFromCache();\n\t\t\t\treturn true;\n\t\t\t} catch (err) {\n\t\t\t\tlogger.error('Error cancelling upload task', err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * pause this particular upload task\n\t **/\n\tpublic pause(): void {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t} else if (this.state === AWSS3UploadTaskState.PAUSED) {\n\t\t\tlogger.warn('This task is already paused');\n\t\t}\n\t\tthis.state = AWSS3UploadTaskState.PAUSED;\n\t\t// Use axios cancel token to abort the part request immediately\n\t\t// Add the inProgress parts back to pending\n\t\tconst removedInProgressReq = this.inProgress.splice(\n\t\t\t0,\n\t\t\tthis.inProgress.length\n\t\t);\n\t\tremovedInProgressReq.forEach(req => {\n\t\t\treq.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n\t\t});\n\t\t// Put all removed in progress parts back into the queue\n\t\tthis.queued.unshift(\n\t\t\t...removedInProgressReq.map(req => req.uploadPartInput)\n\t\t);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}