{"ast":null,"code":"/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar _ = require('./es6_');\n/**\n * Performs an deep extend on the objects, from right to left.\n * @private\n * @param {Object[]} objects - An array of JS objects\n * @param {Function} collision - A function to be called when a merge collision happens.\n * @param {string[]} path - (for internal use) An array of strings which is the current path down the object when this is called recursively.\n * @returns {Object}\n */\n\n\nfunction deepExtend(objects, collision, path) {\n  if (objects == null) return {};\n  var src,\n      copyIsArray,\n      copy,\n      name,\n      options,\n      clone,\n      target = objects[0] || {},\n      i = 1,\n      length = objects.length;\n  path = path || []; // Handle case when target is a string or something (possible in deep copy)\n\n  if (typeof target !== 'object') {\n    target = {};\n  }\n\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = objects[i]) != null) {\n      // Extend the base object\n      for (name in options) {\n        if (!options.hasOwnProperty(name)) continue;\n        if (name === '__proto__') continue;\n        src = target[name];\n        copy = options[name]; // Prevent never-ending loop\n\n        if (target === copy) {\n          continue;\n        } // Recurse if we're merging plain objects or arrays\n\n\n        if (copy && (_.isPlainObject(copy) || (copyIsArray = _.isArray(copy)))) {\n          if (copyIsArray) {\n            copyIsArray = false;\n            clone = src && _.isArray(src) ? src : [];\n          } else {\n            clone = src && _.isPlainObject(src) ? src : {};\n          }\n\n          var nextPath = path.slice(0);\n          nextPath.push(name); // Never move original objects, clone them\n\n          target[name] = deepExtend([clone, copy], collision, nextPath); // Don't bring in undefined values\n        } else if (copy !== undefined) {\n          if (src != null && typeof collision == 'function') {\n            collision({\n              target: target,\n              copy: options,\n              path: path,\n              key: name\n            });\n          }\n\n          target[name] = copy;\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = deepExtend;","map":{"version":3,"sources":["/home/dalienst/node_modules/style-dictionary/lib/utils/deepExtend.js"],"names":["_","require","deepExtend","objects","collision","path","src","copyIsArray","copy","name","options","clone","target","i","length","hasOwnProperty","isPlainObject","isArray","nextPath","slice","push","undefined","key","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBC,OAApB,EAA6BC,SAA7B,EAAwCC,IAAxC,EAA8C;AAC5C,MAAIF,OAAO,IAAI,IAAf,EACE,OAAO,EAAP;AAEF,MAAIG,GAAJ;AAAA,MAASC,WAAT;AAAA,MAAsBC,IAAtB;AAAA,MAA4BC,IAA5B;AAAA,MAAkCC,OAAlC;AAAA,MAA2CC,KAA3C;AAAA,MACEC,MAAM,GAAGT,OAAO,CAAC,CAAD,CAAP,IAAc,EADzB;AAAA,MAEEU,CAAC,GAAG,CAFN;AAAA,MAGEC,MAAM,GAAGX,OAAO,CAACW,MAHnB;AAKAT,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf,CAT4C,CAW5C;;AACA,MAAK,OAAOO,MAAP,KAAkB,QAAvB,EAAkC;AAChCA,IAAAA,MAAM,GAAG,EAAT;AACD;;AAED,SAAQC,CAAC,GAAGC,MAAZ,EAAoBD,CAAC,EAArB,EAAyB;AACvB;AACA,QAAK,CAACH,OAAO,GAAGP,OAAO,CAAEU,CAAF,CAAlB,KAA4B,IAAjC,EAAwC;AACtC;AACA,WAAKJ,IAAL,IAAaC,OAAb,EAAsB;AACpB,YAAI,CAACA,OAAO,CAACK,cAAR,CAAuBN,IAAvB,CAAL,EACE;AACF,YAAIA,IAAI,KAAK,WAAb,EACE;AAEFH,QAAAA,GAAG,GAAGM,MAAM,CAACH,IAAD,CAAZ;AACAD,QAAAA,IAAI,GAAGE,OAAO,CAACD,IAAD,CAAd,CAPoB,CASpB;;AACA,YAAIG,MAAM,KAAKJ,IAAf,EAAqB;AACnB;AACD,SAZmB,CAcpB;;;AACA,YAAKA,IAAI,KAAMR,CAAC,CAACgB,aAAF,CAAgBR,IAAhB,MAA0BD,WAAW,GAAGP,CAAC,CAACiB,OAAF,CAAUT,IAAV,CAAxC,CAAN,CAAT,EAA4E;AAC1E,cAAKD,WAAL,EAAmB;AACjBA,YAAAA,WAAW,GAAG,KAAd;AACAI,YAAAA,KAAK,GAAGL,GAAG,IAAIN,CAAC,CAACiB,OAAF,CAAUX,GAAV,CAAP,GAAwBA,GAAxB,GAA8B,EAAtC;AACD,WAHD,MAGO;AACLK,YAAAA,KAAK,GAAGL,GAAG,IAAIN,CAAC,CAACgB,aAAF,CAAgBV,GAAhB,CAAP,GAA8BA,GAA9B,GAAoC,EAA5C;AACD;;AAED,cAAIY,QAAQ,GAAGb,IAAI,CAACc,KAAL,CAAW,CAAX,CAAf;AACAD,UAAAA,QAAQ,CAACE,IAAT,CAAcX,IAAd,EAT0E,CAW1E;;AACAG,UAAAA,MAAM,CAAEH,IAAF,CAAN,GAAiBP,UAAU,CAAE,CAACS,KAAD,EAAQH,IAAR,CAAF,EAAiBJ,SAAjB,EAA4Bc,QAA5B,CAA3B,CAZ0E,CAc1E;AACD,SAfD,MAeO,IAAKV,IAAI,KAAKa,SAAd,EAA0B;AAC/B,cAAIf,GAAG,IAAI,IAAP,IAAe,OAAOF,SAAP,IAAoB,UAAvC,EAAmD;AACjDA,YAAAA,SAAS,CAAC;AAACQ,cAAAA,MAAM,EAAEA,MAAT;AAAiBJ,cAAAA,IAAI,EAAEE,OAAvB;AAAgCL,cAAAA,IAAI,EAAEA,IAAtC;AAA4CiB,cAAAA,GAAG,EAAEb;AAAjD,aAAD,CAAT;AACD;;AACDG,UAAAA,MAAM,CAAEH,IAAF,CAAN,GAAiBD,IAAjB;AACD;AACF;AACF;AACF;;AAED,SAAOI,MAAP;AACD;;AAEDW,MAAM,CAACC,OAAP,GAAiBtB,UAAjB","sourcesContent":["/*\n * Copyright 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nvar _ = require('./es6_');\n\n/**\n * Performs an deep extend on the objects, from right to left.\n * @private\n * @param {Object[]} objects - An array of JS objects\n * @param {Function} collision - A function to be called when a merge collision happens.\n * @param {string[]} path - (for internal use) An array of strings which is the current path down the object when this is called recursively.\n * @returns {Object}\n */\nfunction deepExtend(objects, collision, path) {\n  if (objects == null)\n    return {};\n\n  var src, copyIsArray, copy, name, options, clone,\n    target = objects[0] || {},\n    i = 1,\n    length = objects.length;\n\n  path = path || [];\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if ( typeof target !== 'object' ) {\n    target = {};\n  }\n\n  for ( ; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ( (options = objects[ i ]) != null ) {\n      // Extend the base object\n      for (name in options) {\n        if (!options.hasOwnProperty(name))\n          continue;\n        if (name === '__proto__')\n          continue;\n\n        src = target[name];\n        copy = options[name];\n\n        // Prevent never-ending loop\n        if (target === copy) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if ( copy && ( _.isPlainObject(copy) || (copyIsArray = _.isArray(copy)) ) ) {\n          if ( copyIsArray ) {\n            copyIsArray = false;\n            clone = src && _.isArray(src) ? src : [];\n          } else {\n            clone = src && _.isPlainObject(src) ? src : {};\n          }\n\n          var nextPath = path.slice(0);\n          nextPath.push(name);\n\n          // Never move original objects, clone them\n          target[ name ] = deepExtend( [clone, copy], collision, nextPath );\n\n          // Don't bring in undefined values\n        } else if ( copy !== undefined ) {\n          if (src != null && typeof collision == 'function') {\n            collision({target: target, copy: options, path: path, key: name});\n          }\n          target[ name ] = copy;\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = deepExtend;\n"]},"metadata":{},"sourceType":"script"}