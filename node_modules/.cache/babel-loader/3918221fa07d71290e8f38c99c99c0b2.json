{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _tslib = require('./_virtual/_tslib.js');\n\nvar defaultWaitForOptions = {\n  timeout: 10000 // 10 seconds\n\n};\n/**\r\n * Subscribes to an actor ref and waits for its emitted value to satisfy\r\n * a predicate, and then resolves with that value.\r\n *\r\n * @example\r\n * ```js\r\n * const state = await waitFor(someService, state => {\r\n *   return state.hasTag('loaded');\r\n * });\r\n *\r\n * state.hasTag('loaded'); // true\r\n * ```\r\n *\r\n * @param actorRef The actor ref to subscribe to\r\n * @param predicate Determines if a value matches the condition to wait for\r\n * @param options\r\n * @returns A promise that eventually resolves to the emitted value\r\n * that matches the condition\r\n */\n\nfunction waitFor(actorRef, predicate, options) {\n  var resolvedOptions = _tslib.__assign(_tslib.__assign({}, defaultWaitForOptions), options);\n\n  return new Promise(function (res, rej) {\n    var done = false;\n\n    if (process.env.NODE_ENV !== 'production' && resolvedOptions.timeout < 0) {\n      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');\n    }\n\n    var handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(function () {\n      sub.unsubscribe();\n      rej(new Error(\"Timeout of \".concat(resolvedOptions.timeout, \" ms exceeded\")));\n    }, resolvedOptions.timeout);\n\n    var dispose = function () {\n      clearTimeout(handle);\n      done = true;\n      sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n    };\n\n    var sub = actorRef.subscribe({\n      next: function (emitted) {\n        if (predicate(emitted)) {\n          dispose();\n          res(emitted);\n        }\n      },\n      error: function (err) {\n        dispose();\n        rej(err);\n      },\n      complete: function () {\n        dispose();\n        rej(new Error(\"Actor terminated without satisfying predicate\"));\n      }\n    });\n\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\nexports.waitFor = waitFor;","map":{"version":3,"sources":["/home/dalienst/node_modules/xstate/lib/waitFor.js"],"names":["Object","defineProperty","exports","value","_tslib","require","defaultWaitForOptions","timeout","waitFor","actorRef","predicate","options","resolvedOptions","__assign","Promise","res","rej","done","process","env","NODE_ENV","console","error","handle","Infinity","undefined","setTimeout","sub","unsubscribe","Error","concat","dispose","clearTimeout","subscribe","next","emitted","err","complete"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAApB;;AAEA,IAAIC,qBAAqB,GAAG;AAC1BC,EAAAA,OAAO,EAAE,KADiB,CACX;;AADW,CAA5B;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,OAAT,CAAiBC,QAAjB,EAA2BC,SAA3B,EAAsCC,OAAtC,EAA+C;AAC7C,MAAIC,eAAe,GAAGR,MAAM,CAACS,QAAP,CAAgBT,MAAM,CAACS,QAAP,CAAgB,EAAhB,EAAoBP,qBAApB,CAAhB,EAA4DK,OAA5D,CAAtB;;AAEA,SAAO,IAAIG,OAAJ,CAAY,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AACrC,QAAIC,IAAI,GAAG,KAAX;;AAEA,QAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyCR,eAAe,CAACL,OAAhB,GAA0B,CAAvE,EAA0E;AACxEc,MAAAA,OAAO,CAACC,KAAR,CAAc,gGAAd;AACD;;AAED,QAAIC,MAAM,GAAGX,eAAe,CAACL,OAAhB,KAA4BiB,QAA5B,GAAuCC,SAAvC,GAAmDC,UAAU,CAAC,YAAY;AACrFC,MAAAA,GAAG,CAACC,WAAJ;AACAZ,MAAAA,GAAG,CAAC,IAAIa,KAAJ,CAAU,cAAcC,MAAd,CAAqBlB,eAAe,CAACL,OAArC,EAA8C,cAA9C,CAAV,CAAD,CAAH;AACD,KAHyE,EAGvEK,eAAe,CAACL,OAHuD,CAA1E;;AAKA,QAAIwB,OAAO,GAAG,YAAY;AACxBC,MAAAA,YAAY,CAACT,MAAD,CAAZ;AACAN,MAAAA,IAAI,GAAG,IAAP;AACAU,MAAAA,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAK,KAAK,CAA7B,GAAiC,KAAK,CAAtC,GAA0CA,GAAG,CAACC,WAAJ,EAA1C;AACD,KAJD;;AAMA,QAAID,GAAG,GAAGlB,QAAQ,CAACwB,SAAT,CAAmB;AAC3BC,MAAAA,IAAI,EAAE,UAAUC,OAAV,EAAmB;AACvB,YAAIzB,SAAS,CAACyB,OAAD,CAAb,EAAwB;AACtBJ,UAAAA,OAAO;AACPhB,UAAAA,GAAG,CAACoB,OAAD,CAAH;AACD;AACF,OAN0B;AAO3Bb,MAAAA,KAAK,EAAE,UAAUc,GAAV,EAAe;AACpBL,QAAAA,OAAO;AACPf,QAAAA,GAAG,CAACoB,GAAD,CAAH;AACD,OAV0B;AAW3BC,MAAAA,QAAQ,EAAE,YAAY;AACpBN,QAAAA,OAAO;AACPf,QAAAA,GAAG,CAAC,IAAIa,KAAJ,CAAU,+CAAV,CAAD,CAAH;AACD;AAd0B,KAAnB,CAAV;;AAiBA,QAAIZ,IAAJ,EAAU;AACRU,MAAAA,GAAG,CAACC,WAAJ;AACD;AACF,GAtCM,CAAP;AAuCD;;AAED1B,OAAO,CAACM,OAAR,GAAkBA,OAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar _tslib = require('./_virtual/_tslib.js');\n\nvar defaultWaitForOptions = {\n  timeout: 10000 // 10 seconds\n\n};\n/**\r\n * Subscribes to an actor ref and waits for its emitted value to satisfy\r\n * a predicate, and then resolves with that value.\r\n *\r\n * @example\r\n * ```js\r\n * const state = await waitFor(someService, state => {\r\n *   return state.hasTag('loaded');\r\n * });\r\n *\r\n * state.hasTag('loaded'); // true\r\n * ```\r\n *\r\n * @param actorRef The actor ref to subscribe to\r\n * @param predicate Determines if a value matches the condition to wait for\r\n * @param options\r\n * @returns A promise that eventually resolves to the emitted value\r\n * that matches the condition\r\n */\n\nfunction waitFor(actorRef, predicate, options) {\n  var resolvedOptions = _tslib.__assign(_tslib.__assign({}, defaultWaitForOptions), options);\n\n  return new Promise(function (res, rej) {\n    var done = false;\n\n    if (process.env.NODE_ENV !== 'production' && resolvedOptions.timeout < 0) {\n      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');\n    }\n\n    var handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(function () {\n      sub.unsubscribe();\n      rej(new Error(\"Timeout of \".concat(resolvedOptions.timeout, \" ms exceeded\")));\n    }, resolvedOptions.timeout);\n\n    var dispose = function () {\n      clearTimeout(handle);\n      done = true;\n      sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n    };\n\n    var sub = actorRef.subscribe({\n      next: function (emitted) {\n        if (predicate(emitted)) {\n          dispose();\n          res(emitted);\n        }\n      },\n      error: function (err) {\n        dispose();\n        rej(err);\n      },\n      complete: function () {\n        dispose();\n        rej(new Error(\"Actor terminated without satisfying predicate\"));\n      }\n    });\n\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\nexports.waitFor = waitFor;\n"]},"metadata":{},"sourceType":"script"}