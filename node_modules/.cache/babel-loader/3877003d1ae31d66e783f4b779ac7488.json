{"ast":null,"code":"import along from \"@turf/along\";\nimport circle from \"@turf/circle\";\nimport length from \"@turf/length\";\nimport { lineString } from \"@turf/helpers\";\nimport { isGeofenceArray, validateCoordinates } from \"./utils\";\nconst GEOFENCE_ID_REGEX = /^[-._\\p{L}\\p{N}]+$/iu;\nexport const getGeofenceFeatureArray = data => {\n  const coordinates = isGeofenceArray(data) ? data.map(geofence => geofence.geometry.polygon) : data;\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"MultiPolygon\",\n      coordinates\n    },\n    properties: {}\n  };\n};\nexport const getGeofenceFeatureFromPolygon = polygon => {\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n}; // Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon\n\nexport const getPolygonFeatureFromBounds = (id, bounds) => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  }); // Gets coordinates 1/4 along the line from each coordinate\n\n  const southWestCoordinate = along(line, distanceInMiles / 4, {\n    units: \"miles\"\n  }).geometry.coordinates;\n  const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {\n    units: \"miles\"\n  }).geometry.coordinates; // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate\n\n  const polygon = [[northeastCoordinate, [southWestCoordinate[0], northeastCoordinate[1]], southWestCoordinate, [northeastCoordinate[0], southWestCoordinate[1]], northeastCoordinate]];\n  return {\n    id,\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n};\nexport const getCircleFeatureFromCoords = (id, center, _ref) => {\n  let {\n    bounds,\n    radius\n  } = _ref;\n\n  if (!bounds && !radius) {\n    throw new Error(\"Circle requires a bounds or a radius\");\n  }\n\n  validateCoordinates(center);\n  const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;\n  const circleFeature = circle(center, circleRadius, {\n    units: \"miles\"\n  });\n  return {\n    id,\n    type: \"Feature\",\n    properties: {\n      isCircle: true,\n      center,\n      radius: circleRadius\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: circleFeature.geometry.coordinates\n    }\n  };\n};\n\nconst getDistanceFromBounds = bounds => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  return length(line, {\n    units: \"miles\"\n  });\n};\n\nexport const doesGeofenceExist = (id, loadedGeofences) => {\n  return !!loadedGeofences[id];\n};\nexport const isValidGeofenceId = id => {\n  return !!id.match(GEOFENCE_ID_REGEX);\n};\nexport const isExistingGeofenceId = (id, loadedGeofences) => {\n  return doesGeofenceExist(id, loadedGeofences);\n};\nexport const isGeofenceDisplayed = (id, displayedGeofences) => {\n  return !!displayedGeofences.find(geofence => geofence.geofenceId === id);\n};\nexport const getDistanceBetweenCoordinates = (startCoord, endCoord) => {\n  const line = lineString([startCoord, endCoord]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  });\n  return distanceInMiles;\n};","map":{"version":3,"sources":["/home/dalienst/node_modules/maplibre-gl-js-amplify/lib/esm/geofenceUtils.js"],"names":["along","circle","length","lineString","isGeofenceArray","validateCoordinates","GEOFENCE_ID_REGEX","getGeofenceFeatureArray","data","coordinates","map","geofence","geometry","polygon","type","properties","getGeofenceFeatureFromPolygon","getPolygonFeatureFromBounds","id","bounds","swCoordinate","getSouthWest","toArray","neCoordinate","getNorthEast","center","getCenter","line","distanceInMiles","units","southWestCoordinate","northeastCoordinate","getCircleFeatureFromCoords","radius","Error","circleRadius","getDistanceFromBounds","circleFeature","isCircle","doesGeofenceExist","loadedGeofences","isValidGeofenceId","match","isExistingGeofenceId","isGeofenceDisplayed","displayedGeofences","find","geofenceId","getDistanceBetweenCoordinates","startCoord","endCoord"],"mappings":"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","sourcesContent":["import along from \"@turf/along\";\nimport circle from \"@turf/circle\";\nimport length from \"@turf/length\";\nimport { lineString } from \"@turf/helpers\";\nimport { isGeofenceArray, validateCoordinates } from \"./utils\";\nconst GEOFENCE_ID_REGEX = /^[-._\\p{L}\\p{N}]+$/iu;\nexport const getGeofenceFeatureArray = (data) => {\n    const coordinates = isGeofenceArray(data)\n        ? data.map((geofence) => geofence.geometry.polygon)\n        : data;\n    return {\n        type: \"Feature\",\n        geometry: {\n            type: \"MultiPolygon\",\n            coordinates,\n        },\n        properties: {},\n    };\n};\nexport const getGeofenceFeatureFromPolygon = (polygon) => {\n    return {\n        type: \"Feature\",\n        geometry: {\n            type: \"Polygon\",\n            coordinates: polygon,\n        },\n        properties: {},\n    };\n};\n// Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon\nexport const getPolygonFeatureFromBounds = (id, bounds) => {\n    const swCoordinate = bounds.getSouthWest().toArray();\n    const neCoordinate = bounds.getNorthEast().toArray();\n    const center = bounds.getCenter().toArray();\n    const line = lineString([swCoordinate, center, neCoordinate]);\n    const distanceInMiles = length(line, { units: \"miles\" });\n    // Gets coordinates 1/4 along the line from each coordinate\n    const southWestCoordinate = along(line, distanceInMiles / 4, {\n        units: \"miles\",\n    }).geometry.coordinates;\n    const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {\n        units: \"miles\",\n    }).geometry.coordinates;\n    // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate\n    const polygon = [\n        [\n            northeastCoordinate,\n            [southWestCoordinate[0], northeastCoordinate[1]],\n            southWestCoordinate,\n            [northeastCoordinate[0], southWestCoordinate[1]],\n            northeastCoordinate,\n        ],\n    ];\n    return {\n        id,\n        type: \"Feature\",\n        geometry: {\n            type: \"Polygon\",\n            coordinates: polygon,\n        },\n        properties: {},\n    };\n};\nexport const getCircleFeatureFromCoords = (id, center, { bounds, radius }) => {\n    if (!bounds && !radius) {\n        throw new Error(\"Circle requires a bounds or a radius\");\n    }\n    validateCoordinates(center);\n    const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;\n    const circleFeature = circle(center, circleRadius, { units: \"miles\" });\n    return {\n        id,\n        type: \"Feature\",\n        properties: {\n            isCircle: true,\n            center,\n            radius: circleRadius,\n        },\n        geometry: {\n            type: \"Polygon\",\n            coordinates: circleFeature.geometry.coordinates,\n        },\n    };\n};\nconst getDistanceFromBounds = (bounds) => {\n    const swCoordinate = bounds.getSouthWest().toArray();\n    const neCoordinate = bounds.getNorthEast().toArray();\n    const center = bounds.getCenter().toArray();\n    const line = lineString([swCoordinate, center, neCoordinate]);\n    return length(line, { units: \"miles\" });\n};\nexport const doesGeofenceExist = (id, loadedGeofences) => {\n    return !!loadedGeofences[id];\n};\nexport const isValidGeofenceId = (id) => {\n    return !!id.match(GEOFENCE_ID_REGEX);\n};\nexport const isExistingGeofenceId = (id, loadedGeofences) => {\n    return doesGeofenceExist(id, loadedGeofences);\n};\nexport const isGeofenceDisplayed = (id, displayedGeofences) => {\n    return !!displayedGeofences.find((geofence) => geofence.geofenceId === id);\n};\nexport const getDistanceBetweenCoordinates = (startCoord, endCoord) => {\n    const line = lineString([startCoord, endCoord]);\n    const distanceInMiles = length(line, { units: \"miles\" });\n    return distanceInMiles;\n};\n"]},"metadata":{},"sourceType":"module"}