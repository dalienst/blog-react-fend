{"ast":null,"code":"import { __assign } from './_virtual/_tslib.js';\nimport { symbolObservable, toInvokeSource, mapContext, isMachine } from './utils.js';\nimport { provide } from './serviceScope.js';\n\nfunction createNullActor(id) {\n  var _a;\n\n  return _a = {\n    id: id,\n    send: function () {\n      return void 0;\n    },\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    getSnapshot: function () {\n      return undefined;\n    },\n    toJSON: function () {\n      return {\n        id: id\n      };\n    }\n  }, _a[symbolObservable] = function () {\n    return this;\n  }, _a;\n}\n/**\r\n * Creates a deferred actor that is able to be invoked given the provided\r\n * invocation information in its `.meta` value.\r\n *\r\n * @param invokeDefinition The meta information needed to invoke the actor.\r\n */\n\n\nfunction createInvocableActor(invokeDefinition, machine, context, _event) {\n  var _a;\n\n  var invokeSrc = toInvokeSource(invokeDefinition.src);\n  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];\n  var resolvedData = invokeDefinition.data ? mapContext(invokeDefinition.data, context, _event) : undefined;\n  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore\n\n  tempActor.meta = invokeDefinition;\n  return tempActor;\n}\n\nfunction createDeferredActor(entity, id, data) {\n  var tempActor = createNullActor(id); // @ts-ignore\n\n  tempActor.deferred = true;\n\n  if (isMachine(entity)) {\n    // \"mute\" the existing service scope so potential spawned actors within the `.initialState` stay deferred here\n    var initialState_1 = tempActor.state = provide(undefined, function () {\n      return (data ? entity.withContext(data) : entity).initialState;\n    });\n\n    tempActor.getSnapshot = function () {\n      return initialState_1;\n    };\n  }\n\n  return tempActor;\n}\n\nfunction isActor(item) {\n  try {\n    return typeof item.send === 'function';\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isSpawnedActor(item) {\n  return isActor(item) && 'id' in item;\n} // TODO: refactor the return type, this could be written in a better way but it's best to avoid unneccessary breaking changes now\n\n\nfunction toActorRef(actorRefLike) {\n  var _a;\n\n  return __assign((_a = {\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    id: 'anonymous',\n    getSnapshot: function () {\n      return undefined;\n    }\n  }, _a[symbolObservable] = function () {\n    return this;\n  }, _a), actorRefLike);\n}\n\nexport { createDeferredActor, createInvocableActor, createNullActor, isActor, isSpawnedActor, toActorRef };","map":{"version":3,"sources":["/home/dalienst/node_modules/xstate/es/Actor.js"],"names":["__assign","symbolObservable","toInvokeSource","mapContext","isMachine","provide","createNullActor","id","_a","send","subscribe","unsubscribe","getSnapshot","undefined","toJSON","createInvocableActor","invokeDefinition","machine","context","_event","invokeSrc","src","serviceCreator","options","services","type","resolvedData","data","tempActor","createDeferredActor","meta","entity","deferred","initialState_1","state","withContext","initialState","isActor","item","e","isSpawnedActor","toActorRef","actorRefLike"],"mappings":"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","sourcesContent":["import { __assign } from './_virtual/_tslib.js';\nimport { symbolObservable, toInvokeSource, mapContext, isMachine } from './utils.js';\nimport { provide } from './serviceScope.js';\n\nfunction createNullActor(id) {\n  var _a;\n\n  return _a = {\n    id: id,\n    send: function () {\n      return void 0;\n    },\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    getSnapshot: function () {\n      return undefined;\n    },\n    toJSON: function () {\n      return {\n        id: id\n      };\n    }\n  }, _a[symbolObservable] = function () {\n    return this;\n  }, _a;\n}\n/**\r\n * Creates a deferred actor that is able to be invoked given the provided\r\n * invocation information in its `.meta` value.\r\n *\r\n * @param invokeDefinition The meta information needed to invoke the actor.\r\n */\n\nfunction createInvocableActor(invokeDefinition, machine, context, _event) {\n  var _a;\n\n  var invokeSrc = toInvokeSource(invokeDefinition.src);\n  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];\n  var resolvedData = invokeDefinition.data ? mapContext(invokeDefinition.data, context, _event) : undefined;\n  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore\n\n  tempActor.meta = invokeDefinition;\n  return tempActor;\n}\nfunction createDeferredActor(entity, id, data) {\n  var tempActor = createNullActor(id); // @ts-ignore\n\n  tempActor.deferred = true;\n\n  if (isMachine(entity)) {\n    // \"mute\" the existing service scope so potential spawned actors within the `.initialState` stay deferred here\n    var initialState_1 = tempActor.state = provide(undefined, function () {\n      return (data ? entity.withContext(data) : entity).initialState;\n    });\n\n    tempActor.getSnapshot = function () {\n      return initialState_1;\n    };\n  }\n\n  return tempActor;\n}\nfunction isActor(item) {\n  try {\n    return typeof item.send === 'function';\n  } catch (e) {\n    return false;\n  }\n}\nfunction isSpawnedActor(item) {\n  return isActor(item) && 'id' in item;\n} // TODO: refactor the return type, this could be written in a better way but it's best to avoid unneccessary breaking changes now\n\nfunction toActorRef(actorRefLike) {\n  var _a;\n\n  return __assign((_a = {\n    subscribe: function () {\n      return {\n        unsubscribe: function () {\n          return void 0;\n        }\n      };\n    },\n    id: 'anonymous',\n    getSnapshot: function () {\n      return undefined;\n    }\n  }, _a[symbolObservable] = function () {\n    return this;\n  }, _a), actorRefLike);\n}\n\nexport { createDeferredActor, createInvocableActor, createNullActor, isActor, isSpawnedActor, toActorRef };\n"]},"metadata":{},"sourceType":"module"}