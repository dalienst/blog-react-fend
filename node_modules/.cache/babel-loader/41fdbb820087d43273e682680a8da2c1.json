{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\nimport { PredicateInternalsKey } from '../types';\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\n\nvar ops = __spread(comparisonKeys);\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\n\n\nvar predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\n\nvar registerPredicateInternals = function (condition, key) {\n  var finalKey = key || new PredicateInternalsKey();\n  predicateInternalsMap.set(finalKey, condition);\n  return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\n\n\nexport var internals = function (key) {\n  if (!predicateInternalsMap.has(key)) {\n    throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n  }\n\n  return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\n\nvar negations = {\n  and: 'or',\n  or: 'and',\n  not: 'and',\n  eq: 'ne',\n  ne: 'eq',\n  gt: 'le',\n  ge: 'lt',\n  lt: 'ge',\n  le: 'gt',\n  contains: 'notContains',\n  notContains: 'contains'\n};\n/**\n * Given a V1 predicate \"seed\", applies a list of V2 field-level conditions\n * to the predicate, returning a new/final V1 predicate chain link.\n * @param predicate The base/seed V1 predicate to build on\n * @param conditions The V2 conditions to add to the predicate chain.\n * @param negateChildren Whether the conditions should be negated first.\n * @returns A V1 predicate, with conditions incorporated.\n */\n\nfunction applyConditionsToV1Predicate(predicate, conditions, negateChildren) {\n  var e_1, _a, e_2, _b;\n\n  var p = predicate;\n  var finalConditions = [];\n\n  try {\n    for (var conditions_1 = __values(conditions), conditions_1_1 = conditions_1.next(); !conditions_1_1.done; conditions_1_1 = conditions_1.next()) {\n      var c = conditions_1_1.value;\n\n      if (negateChildren) {\n        if (c.operator === 'between') {\n          finalConditions.push(new FieldCondition(c.field, 'lt', [c.operands[0]]), new FieldCondition(c.field, 'gt', [c.operands[1]]));\n        } else {\n          finalConditions.push(new FieldCondition(c.field, negations[c.operator], c.operands));\n        }\n      } else {\n        finalConditions.push(c);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (conditions_1_1 && !conditions_1_1.done && (_a = conditions_1.return)) _a.call(conditions_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  try {\n    for (var finalConditions_1 = __values(finalConditions), finalConditions_1_1 = finalConditions_1.next(); !finalConditions_1_1.done; finalConditions_1_1 = finalConditions_1.next()) {\n      var c = finalConditions_1_1.value;\n      p = p[c.field](c.operator, c.operator === 'between' ? c.operands : c.operands[0]);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (finalConditions_1_1 && !finalConditions_1_1.done && (_b = finalConditions_1.return)) _b.call(finalConditions_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return p;\n}\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\n\n\nvar FieldCondition =\n/** @class */\nfunction () {\n  function FieldCondition(field, operator, operands) {\n    this.field = field;\n    this.operator = operator;\n    this.operands = operands;\n    this.validate();\n  }\n  /**\n   * Creates a copy of self.\n   * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n   * @returns A new, identitical `FieldCondition`.\n   */\n\n\n  FieldCondition.prototype.copy = function (extract) {\n    return [new FieldCondition(this.field, this.operator, __spread(this.operands)), undefined];\n  };\n\n  FieldCondition.prototype.toAST = function () {\n    var _a, _b;\n\n    return _a = {}, _a[this.field] = (_b = {}, _b[this.operator] = this.operator === 'between' ? [this.operands[0], this.operands[1]] : this.operands[0], _b), _a;\n  };\n  /**\n   * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n   * transforms them into legacy predicates. (*For now.*)\n   * @param storage N/A. If ever implemented, the storage adapter to query.\n   * @returns N/A. If ever implemented, return items from `storage` that match.\n   */\n\n\n  FieldCondition.prototype.fetch = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.reject('No implementation needed [yet].')];\n      });\n    });\n  };\n  /**\n   * Determins whether a given item matches the expressed condition.\n   * @param item The item to test.\n   * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n   */\n\n\n  FieldCondition.prototype.matches = function (item) {\n    return __awaiter(this, void 0, void 0, function () {\n      var v, operations, operation, result;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        v = item[this.field];\n        operations = {\n          eq: function () {\n            return v === _this.operands[0];\n          },\n          ne: function () {\n            return v !== _this.operands[0];\n          },\n          gt: function () {\n            return v > _this.operands[0];\n          },\n          ge: function () {\n            return v >= _this.operands[0];\n          },\n          lt: function () {\n            return v < _this.operands[0];\n          },\n          le: function () {\n            return v <= _this.operands[0];\n          },\n          contains: function () {\n            return v.indexOf(_this.operands[0]) > -1;\n          },\n          notContains: function () {\n            return v.indexOf(_this.operands[0]) === -1;\n          },\n          beginsWith: function () {\n            return v.startsWith(_this.operands[0]);\n          },\n          between: function () {\n            return v >= _this.operands[0] && v <= _this.operands[1];\n          }\n        };\n        operation = operations[this.operator];\n\n        if (operation) {\n          result = operation();\n          return [2\n          /*return*/\n          , result];\n        } else {\n          throw new Error(\"Invalid operator given: \" + this.operator);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Checks `this.operands` for compatibility with `this.operator`.\n   */\n\n\n  FieldCondition.prototype.validate = function () {\n    var _this = this;\n    /**\n     * Creates a validator that checks for a particular `operands` count.\n     * Throws an exception if the `count` disagrees with `operands.length`.\n     * @param count The number of `operands` expected.\n     */\n\n\n    var argumentCount = function (count) {\n      var argsClause = count === 1 ? 'argument is' : 'arguments are';\n      return function () {\n        if (_this.operands.length !== count) {\n          return \"Exactly \" + count + \" \" + argsClause + \" required.\";\n        }\n      };\n    }; // NOTE: validations should return a message on failure.\n    // hence, they should be \"joined\" together with logical OR's\n    // as seen in the `between:` entry.\n\n\n    var validations = {\n      eq: argumentCount(1),\n      ne: argumentCount(1),\n      gt: argumentCount(1),\n      ge: argumentCount(1),\n      lt: argumentCount(1),\n      le: argumentCount(1),\n      contains: argumentCount(1),\n      notContains: argumentCount(1),\n      beginsWith: argumentCount(1),\n      between: function () {\n        return argumentCount(2)() || (_this.operands[0] > _this.operands[1] ? 'The first argument must be less than or equal to the second argument.' : null);\n      }\n    };\n    var validate = validations[this.operator];\n\n    if (validate) {\n      var e = validate();\n      if (typeof e === 'string') throw new Error(\"Incorrect usage of `\" + this.operator + \"()`: \" + e);\n    } else {\n      throw new Error(\"Non-existent operator: `\" + this.operator + \"()`\");\n    }\n  };\n\n  return FieldCondition;\n}();\n\nexport { FieldCondition };\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\n\nvar getGroupId = function () {\n  var seed = 1;\n  return function () {\n    return \"group_\" + seed++;\n  };\n}();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\n\n\nvar GroupCondition =\n/** @class */\nfunction () {\n  function GroupCondition(\n  /**\n   * The `ModelMeta` of the model to query and/or filter against.\n   * Expected to contain:\n   *\n   * ```js\n   * {\n   * \tbuilder: ModelConstructor,\n   * \tschema: SchemaModel,\n   * \tpkField: string[]\n   * }\n   * ```\n   */\n  model,\n  /**\n   * If populated, this group specifices a condition on a relationship.\n   *\n   * If `field` does *not* point to a related model, that's an error. It\n   * could indicate that the `GroupCondition` was instantiated with bad\n   * data, or that the model metadata is incorrect.\n   */\n  field,\n  /**\n   * If a `field` is given, whether the relationship is a `HAS_ONE`,\n   * 'HAS_MANY`, or `BELONGS_TO`.\n   *\n   * TODO: Remove this and replace with derivation using\n   * `ModelRelationship.from(this.model, this.field).relationship`;\n   */\n  relationshipType,\n  /**\n   *\n   */\n  operator,\n  /**\n   *\n   */\n  operands) {\n    this.model = model;\n    this.field = field;\n    this.relationshipType = relationshipType;\n    this.operator = operator;\n    this.operands = operands; // `groupId` was used for development/debugging.\n    // Should we leave this in for future troubleshooting?\n\n    this.groupId = getGroupId();\n  }\n  /**\n   * Returns a copy of a GroupCondition, which also returns the copy of a\n   * given reference node to \"extract\".\n   * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n   * @returns [The full copy, the copy of `extract` | undefined]\n   */\n\n\n  GroupCondition.prototype.copy = function (extract) {\n    var copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n    var extractedCopy = extract === this ? copied : undefined;\n    this.operands.forEach(function (o) {\n      var _a = __read(o.copy(extract), 2),\n          operandCopy = _a[0],\n          extractedFromOperand = _a[1];\n\n      copied.operands.push(operandCopy);\n      extractedCopy = extractedCopy || extractedFromOperand;\n    });\n    return [copied, extractedCopy];\n  };\n  /**\n   * Fetches matching records from a given storage adapter using legacy predicates (for now).\n   * @param storage The storage adapter this predicate will query against.\n   * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n   * GroupdCondition.fetch is nested within.\n   * @param negate Whether to match on the `NOT` of `this`.\n   * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n   */\n\n\n  GroupCondition.prototype.fetch = function (storage, breadcrumb, negate) {\n    if (breadcrumb === void 0) {\n      breadcrumb = [];\n    }\n\n    if (negate === void 0) {\n      negate = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var resultGroups, operator, negateChildren, groups, conditions, groups_1, groups_1_1, g, relatives, relationship, relativesPredicates, _loop_1, relatives_1, relatives_1_1, relative, predicate, _a, _b, e_3_1, predicate, _c, _d, _e, _f, getPKValue, resultIndex, resultGroups_1, resultGroups_1_1, group, intersectWith, _g, _h, k, resultGroups_2, resultGroups_2_1, group, group_1, group_1_1, item;\n\n      var e_3, _j, e_4, _k, e_5, _l, e_6, _m, e_7, _o, e_8, _p;\n\n      var _this = this;\n\n      return __generator(this, function (_q) {\n        switch (_q.label) {\n          case 0:\n            resultGroups = [];\n            operator = negate ? negations[this.operator] : this.operator;\n            negateChildren = negate !== (this.operator === 'not');\n            groups = this.operands.filter(function (op) {\n              return op instanceof GroupCondition;\n            });\n            conditions = this.operands.filter(function (op) {\n              return op instanceof FieldCondition;\n            });\n            _q.label = 1;\n\n          case 1:\n            _q.trys.push([1, 10, 11, 12]);\n\n            groups_1 = __values(groups), groups_1_1 = groups_1.next();\n            _q.label = 2;\n\n          case 2:\n            if (!!groups_1_1.done) return [3\n            /*break*/\n            , 9];\n            g = groups_1_1.value;\n            return [4\n            /*yield*/\n            , g.fetch(storage, __spread(breadcrumb, [this.groupId]), negateChildren)];\n\n          case 3:\n            relatives = _q.sent(); // no relatives -> no need to attempt to perform a \"join\" query for\n            // candidate results:\n            //\n            // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n            //\n            // Additionally, the entire (sub)-query can be short-circuited if\n            // the operator is `AND`. Illustrated in SQL:\n            //\n            // select a.* from a where\n            //   id in [a,b,c]\n            //     AND                        <\n            //   id in EMTPY_SET            <<< Look!\n            //     AND                        <\n            //   id in [x,y,z]\n            //\n            // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n            //\n\n            if (relatives.length === 0) {\n              // aggressively short-circuit as soon as we know the group condition will fail\n              if (operator === 'and') {\n                return [2\n                /*return*/\n                , []];\n              } // less aggressive short-circuit if we know the relatives will produce no\n              // candidate results; but aren't sure yet how this affects the group condition.\n\n\n              resultGroups.push([]);\n              return [3\n              /*break*/\n              , 8];\n            }\n\n            if (!g.field) return [3\n            /*break*/\n            , 7];\n            relationship = ModelRelationship.from(this.model, g.field);\n            if (!relationship) return [3\n            /*break*/\n            , 5];\n            relativesPredicates = [];\n\n            _loop_1 = function (relative) {\n              var individualRowJoinConditions = [];\n\n              for (var i = 0; i < relationship.localJoinFields.length; i++) {\n                // rightHandValue\n                individualRowJoinConditions.push(new FieldCondition(relationship.localJoinFields[i], 'eq', [relative[relationship.remoteJoinFields[i]]]));\n              }\n\n              var predicate_1 = function (p) {\n                return applyConditionsToV1Predicate(p, individualRowJoinConditions, false);\n              };\n\n              relativesPredicates.push(predicate_1);\n            };\n\n            try {\n              for (relatives_1 = (e_4 = void 0, __values(relatives)), relatives_1_1 = relatives_1.next(); !relatives_1_1.done; relatives_1_1 = relatives_1.next()) {\n                relative = relatives_1_1.value;\n\n                _loop_1(relative);\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (relatives_1_1 && !relatives_1_1.done && (_k = relatives_1.return)) _k.call(relatives_1);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n\n            predicate = FlatModelPredicateCreator.createGroupFromExisting(this.model.schema, 'or', relativesPredicates);\n            _b = (_a = resultGroups).push;\n            return [4\n            /*yield*/\n            , storage.query(this.model.builder, predicate)];\n\n          case 4:\n            _b.apply(_a, [_q.sent()]);\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            throw new Error('Missing field metadata.');\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            // relatives are not actually relatives. they're candidate results.\n            resultGroups.push(relatives);\n            _q.label = 8;\n\n          case 8:\n            groups_1_1 = groups_1.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 9:\n            return [3\n            /*break*/\n            , 12];\n\n          case 10:\n            e_3_1 = _q.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            try {\n              if (groups_1_1 && !groups_1_1.done && (_j = groups_1.return)) _j.call(groups_1);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            if (!(conditions.length > 0)) return [3\n            /*break*/\n            , 14];\n            predicate = FlatModelPredicateCreator.createFromExisting(this.model.schema, function (p) {\n              return p[operator](function (c) {\n                return applyConditionsToV1Predicate(c, conditions, negateChildren);\n              });\n            });\n            _d = (_c = resultGroups).push;\n            return [4\n            /*yield*/\n            , storage.query(this.model.builder, predicate)];\n\n          case 13:\n            _d.apply(_c, [_q.sent()]);\n\n            return [3\n            /*break*/\n            , 16];\n\n          case 14:\n            if (!(conditions.length === 0 && resultGroups.length === 0)) return [3\n            /*break*/\n            , 16];\n            _f = (_e = resultGroups).push;\n            return [4\n            /*yield*/\n            , storage.query(this.model.builder)];\n\n          case 15:\n            _f.apply(_e, [_q.sent()]);\n\n            _q.label = 16;\n\n          case 16:\n            getPKValue = function (item) {\n              return JSON.stringify(_this.model.pkField.map(function (name) {\n                return item[name];\n              }));\n            };\n\n            if (operator === 'and') {\n              if (resultGroups.length === 0) {\n                return [2\n                /*return*/\n                , []];\n              }\n\n              try {\n                // for each group, we intersect, removing items from the result index\n                // that aren't present in each subsequent group.\n                for (resultGroups_1 = __values(resultGroups), resultGroups_1_1 = resultGroups_1.next(); !resultGroups_1_1.done; resultGroups_1_1 = resultGroups_1.next()) {\n                  group = resultGroups_1_1.value;\n\n                  if (resultIndex === undefined) {\n                    resultIndex = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                  } else {\n                    intersectWith = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n\n                    try {\n                      for (_g = (e_6 = void 0, __values(resultIndex.keys())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        k = _h.value;\n\n                        if (!intersectWith.has(k)) {\n                          resultIndex.delete(k);\n                        }\n                      }\n                    } catch (e_6_1) {\n                      e_6 = {\n                        error: e_6_1\n                      };\n                    } finally {\n                      try {\n                        if (_h && !_h.done && (_m = _g.return)) _m.call(_g);\n                      } finally {\n                        if (e_6) throw e_6.error;\n                      }\n                    }\n                  }\n                }\n              } catch (e_5_1) {\n                e_5 = {\n                  error: e_5_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_1_1 && !resultGroups_1_1.done && (_l = resultGroups_1.return)) _l.call(resultGroups_1);\n                } finally {\n                  if (e_5) throw e_5.error;\n                }\n              }\n            } else if (operator === 'or' || operator === 'not') {\n              // it's OK to handle NOT here, because NOT must always only negate\n              // a single child predicate. NOT logic will have been distributed down\n              // to the leaf conditions already.\n              resultIndex = new Map();\n\n              try {\n                // just merge the groups, performing DISTINCT-ification by ID.\n                for (resultGroups_2 = __values(resultGroups), resultGroups_2_1 = resultGroups_2.next(); !resultGroups_2_1.done; resultGroups_2_1 = resultGroups_2.next()) {\n                  group = resultGroups_2_1.value;\n\n                  try {\n                    for (group_1 = (e_8 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {\n                      item = group_1_1.value;\n                      resultIndex.set(getPKValue(item), item);\n                    }\n                  } catch (e_8_1) {\n                    e_8 = {\n                      error: e_8_1\n                    };\n                  } finally {\n                    try {\n                      if (group_1_1 && !group_1_1.done && (_p = group_1.return)) _p.call(group_1);\n                    } finally {\n                      if (e_8) throw e_8.error;\n                    }\n                  }\n                }\n              } catch (e_7_1) {\n                e_7 = {\n                  error: e_7_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_2_1 && !resultGroups_2_1.done && (_o = resultGroups_2.return)) _o.call(resultGroups_2);\n                } finally {\n                  if (e_7) throw e_7.error;\n                }\n              }\n            }\n\n            return [2\n            /*return*/\n            , Array.from((resultIndex === null || resultIndex === void 0 ? void 0 : resultIndex.values()) || [])];\n        }\n      });\n    });\n  };\n  /**\n   * Determines whether a single item matches the conditions of `this`.\n   * When checking the target `item`'s properties, each property will be `await`'d\n   * to ensure lazy-loading is respected where applicable.\n   * @param item The item to match against.\n   * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n   * (Used for iterating over children on HAS_MANY checks.)\n   * @returns A boolean (promise): `true` if matched, `false` otherwise.\n   */\n\n\n  GroupCondition.prototype.matches = function (item, ignoreFieldName) {\n    if (ignoreFieldName === void 0) {\n      ignoreFieldName = false;\n    }\n\n    var e_9, _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var itemToCheck, _b, itemToCheck_1, itemToCheck_1_1, singleItem, e_9_1;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(this.field && !ignoreFieldName)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , item[this.field]];\n\n          case 1:\n            _b = _c.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _b = item;\n            _c.label = 3;\n\n          case 3:\n            itemToCheck = _b; // if there is no item to check, we can stop recursing immediately.\n            // a condition cannot match against an item that does not exist. this\n            // can occur when `item.field` is optional in the schema.\n\n            if (!itemToCheck) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            if (!(this.relationshipType === 'HAS_MANY' && typeof itemToCheck[Symbol.asyncIterator] === 'function')) return [3\n            /*break*/\n            , 17];\n            _c.label = 4;\n\n          case 4:\n            _c.trys.push([4, 10, 11, 16]);\n\n            itemToCheck_1 = __asyncValues(itemToCheck);\n            _c.label = 5;\n\n          case 5:\n            return [4\n            /*yield*/\n            , itemToCheck_1.next()];\n\n          case 6:\n            if (!(itemToCheck_1_1 = _c.sent(), !itemToCheck_1_1.done)) return [3\n            /*break*/\n            , 9];\n            singleItem = itemToCheck_1_1.value;\n            return [4\n            /*yield*/\n            , this.matches(singleItem, true)];\n\n          case 7:\n            if (_c.sent()) {\n              return [2\n              /*return*/\n              , true];\n            }\n\n            _c.label = 8;\n\n          case 8:\n            return [3\n            /*break*/\n            , 5];\n\n          case 9:\n            return [3\n            /*break*/\n            , 16];\n\n          case 10:\n            e_9_1 = _c.sent();\n            e_9 = {\n              error: e_9_1\n            };\n            return [3\n            /*break*/\n            , 16];\n\n          case 11:\n            _c.trys.push([11,, 14, 15]);\n\n            if (!(itemToCheck_1_1 && !itemToCheck_1_1.done && (_a = itemToCheck_1.return))) return [3\n            /*break*/\n            , 13];\n            return [4\n            /*yield*/\n            , _a.call(itemToCheck_1)];\n\n          case 12:\n            _c.sent();\n\n            _c.label = 13;\n\n          case 13:\n            return [3\n            /*break*/\n            , 15];\n\n          case 14:\n            if (e_9) throw e_9.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 16:\n            return [2\n            /*return*/\n            , false];\n\n          case 17:\n            if (!(this.operator === 'or')) return [3\n            /*break*/\n            , 18];\n            return [2\n            /*return*/\n            , asyncSome(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n\n          case 18:\n            if (!(this.operator === 'and')) return [3\n            /*break*/\n            , 19];\n            return [2\n            /*return*/\n            , asyncEvery(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n\n          case 19:\n            if (!(this.operator === 'not')) return [3\n            /*break*/\n            , 21];\n\n            if (this.operands.length !== 1) {\n              throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n            }\n\n            return [4\n            /*yield*/\n            , this.operands[0].matches(itemToCheck)];\n\n          case 20:\n            return [2\n            /*return*/\n            , !_c.sent()];\n\n          case 21:\n            throw new Error('Invalid group operator!');\n        }\n      });\n    });\n  };\n  /**\n   * Tranfsorm to a AppSync GraphQL compatible AST.\n   * (Does not support filtering in nested types.)\n   */\n\n\n  GroupCondition.prototype.toAST = function () {\n    var _a;\n\n    if (this.field) throw new Error('Nested type conditions are not supported!');\n    return _a = {}, _a[this.operator] = this.operands.map(function (operand) {\n      return operand.toAST();\n    }), _a;\n  };\n\n  GroupCondition.prototype.toStoragePredicate = function (baseCondition) {\n    return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n  };\n\n  return GroupCondition;\n}();\n\nexport { GroupCondition };\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * TODO: the sortof-immutable algorithm was originally done to support legacy style\n * predicate branching (`p => p.x.eq(value).y.eq(value)`). i'm not sure this is\n * necessary or beneficial at this point, since we decided that each field condition\n * must flly terminate a branch. is the strong mutation barrier between chain links\n * still necessary or helpful?\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\n\nexport function recursivePredicateFor(ModelType, allowRecursion, field, query, tail) {\n  if (allowRecursion === void 0) {\n    allowRecursion = true;\n  } // to be used if we don't have a base query or tail to build onto\n\n\n  var starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n  var baseCondition = query && tail ? query : starter;\n  var tailCondition = query && tail ? tail : starter; // our eventual return object, which can be built upon.\n  // next steps will be to add or(), and(), not(), and field.op() methods.\n\n  var link = {};\n  registerPredicateInternals(baseCondition, link);\n\n  var copyLink = function () {\n    var _a = __read(baseCondition.copy(tailCondition), 2),\n        query = _a[0],\n        newTail = _a[1];\n\n    var newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n    return {\n      query: query,\n      newTail: newTail,\n      newLink: newLink\n    };\n  }; // Adds .or() and .and() methods to the link.\n  // TODO: If revisiting this code, consider writing a Proxy instead.\n\n\n  ['and', 'or'].forEach(function (op) {\n    link[op] = function (builder) {\n      // or() and and() will return a copy of the original link\n      // to head off mutability concerns.\n      var _a = copyLink(),\n          query = _a.query,\n          newTail = _a.newTail;\n\n      var childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n\n      if (!Array.isArray(childConditions)) {\n        throw new Error(\"Invalid predicate. `\" + op + \"` groups must return an array of child conditions.\");\n      } // the customer will supply a child predicate, which apply to the `model.field`\n      // of the tail GroupCondition.\n\n\n      newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(function (c) {\n        return internals(c);\n      }))); // FinalPredicate\n\n      return registerPredicateInternals(query);\n    };\n  }); // TODO: If revisiting this code, consider proxy.\n\n  link.not = function (builder) {\n    // not() will return a copy of the original link\n    // to head off mutability concerns.\n    var _a = copyLink(),\n        query = _a.query,\n        newTail = _a.newTail; // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n    // the difference being: not() does not accept an array of predicate-like objects.\n    // it negates only a *single* predicate subtree.\n\n\n    newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [internals(builder(recursivePredicateFor(ModelType, allowRecursion)))])); // A `FinalModelPredicate`.\n    // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n    // or query storage: `.__query.fetch(storage)`.\n\n    return registerPredicateInternals(query);\n  };\n\n  var _loop_2 = function (fieldName) {\n    Object.defineProperty(link, fieldName, {\n      enumerable: true,\n      get: function () {\n        var def = ModelType.schema.fields[fieldName];\n\n        if (!def.association) {\n          // we're looking at a value field. we need to return a\n          // \"field matcher object\", which contains all of the comparison\n          // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n          // against the target field (fieldName).\n          return ops.reduce(function (fieldMatcher, operator) {\n            var _a;\n\n            return __assign(__assign({}, fieldMatcher), (_a = {}, _a[operator] = function () {\n              var operands = [];\n\n              for (var _i = 0; _i < arguments.length; _i++) {\n                operands[_i] = arguments[_i];\n              } // build off a fresh copy of the existing `link`, just in case\n              // the same link is being used elsewhere by the customer.\n\n\n              var _a = copyLink(),\n                  query = _a.query,\n                  newTail = _a.newTail; // add the given condition to the link's TAIL node.\n              // remember: the base link might go N nodes deep! e.g.,\n\n\n              newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new FieldCondition(fieldName, operator, operands)); // A `FinalModelPredicate`.\n              // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n              // or query storage: `.__query.fetch(storage)`.\n\n              return registerPredicateInternals(query);\n            }, _a));\n          }, {});\n        } else {\n          if (!allowRecursion) {\n            throw new Error('Predication on releated models is not supported in this context.');\n          } else if (def.association.connectionType === 'BELONGS_TO' || def.association.connectionType === 'HAS_ONE' || def.association.connectionType === 'HAS_MANY') {\n            // the use has just typed '.someRelatedModel'. we need to given them\n            // back a predicate chain.\n            var relatedMeta = def.type.modelConstructor;\n\n            if (!relatedMeta) {\n              throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n            } // `Model.reletedModelField` returns a copy of the original link,\n            // and will contains copies of internal GroupConditions\n            // to head off mutability concerns.\n\n\n            var _a = __read(baseCondition.copy(tailCondition), 2),\n                newquery = _a[0],\n                oldtail = _a[1];\n\n            var newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []); // `oldtail` here refers to the *copy* of the old tail.\n            // so, it's safe to modify at this point. and we need to modify\n            // it to push the *new* tail onto the end of it.\n\n            oldtail.operands.push(newtail);\n            var newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n            return newlink;\n          } else {\n            throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n          }\n        }\n      }\n    });\n  }; // For each field on the model schema, we want to add a getter\n  // that creates the appropriate new `link` in the query chain.\n  // TODO: If revisiting, consider a proxy.\n\n\n  for (var fieldName in ModelType.schema.fields) {\n    _loop_2(fieldName);\n  }\n\n  return link;\n}\nexport function predicateFor(ModelType) {\n  return recursivePredicateFor(ModelType, false);\n}","map":{"version":3,"mappings":"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","names":["PredicateInternalsKey","ModelPredicateCreator","FlatModelPredicateCreator","comparisonKeys","ModelRelationship","asyncSome","asyncEvery","ops","__spread","predicateInternalsMap","Map","registerPredicateInternals","condition","key","finalKey","set","internals","has","Error","get","negations","and","or","not","eq","ne","gt","ge","lt","le","contains","notContains","applyConditionsToV1Predicate","predicate","conditions","negateChildren","p","finalConditions","conditions_1_1","c","operator","push","FieldCondition","field","operands","finalConditions_1_1","validate","extract","undefined","_a","_b","storage","Promise","reject","item","v","operations","_this","indexOf","beginsWith","startsWith","between","operation","result","argumentCount","argsClause","count","length","validations","e","getGroupId","seed","model","relationshipType","GroupCondition","copied","extractedCopy","forEach","operandCopy","extractedFromOperand","breadcrumb","negate","resultGroups","groups","filter","groups_1","groups_1_1","g","fetch","groupId","relatives","_q","relationship","from","relativesPredicates","relative","individualRowJoinConditions","i","localJoinFields","remoteJoinFields","predicate_1","relatives_1","relatives_1_1","createGroupFromExisting","schema","query","builder","createFromExisting","_d","_f","getPKValue","stringify","pkField","map","name","resultGroups_1","resultGroups_1_1","group","resultIndex","intersectWith","_g","keys","_h","k","delete","resultGroups_2","resultGroups_2_1","group_1","group_1_1","Array","values","ignoreFieldName","itemToCheck","Symbol","asyncIterator","itemToCheck_1","singleItem","matches","_c","toAST","baseCondition","createFromAST","recursivePredicateFor","ModelType","allowRecursion","tail","starter","tailCondition","link","copyLink","newTail","newLink","op","childConditions","isArray","fieldName","Object","defineProperty","enumerable","def","fields","association","reduce","fieldMatcher","connectionType","relatedMeta","type","modelConstructor","newquery","oldtail","newtail","newlink","predicateFor"],"sources":["/home/dalienst/node_modules/@aws-amplify/datastore/src/predicates/next.ts"],"sourcesContent":["import {\n\tPersistentModel,\n\tModelFieldType,\n\tModelMeta,\n\tModelPredicate as StoragePredicate,\n\tAllFieldOperators,\n\tPredicateInternalsKey,\n\tV5ModelPredicate as ModelPredicate,\n\tRecursiveModelPredicate,\n\tRecursiveModelPredicateExtender,\n\tRecursiveModelPredicateAggregateExtender,\n} from '../types';\n\nimport {\n\tModelPredicateCreator as FlatModelPredicateCreator,\n\tcomparisonKeys,\n} from './index';\nimport { ExclusiveStorage as StorageAdapter } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\n\nconst ops = [...comparisonKeys] as AllFieldOperators[];\n\ntype GroupOperator = 'and' | 'or' | 'not';\n\ntype UntypedCondition = {\n\tfetch: (storage: StorageAdapter) => Promise<Record<string, any>[]>;\n\tmatches: (item: Record<string, any>) => Promise<boolean>;\n\tcopy(extract: GroupCondition): [UntypedCondition, GroupCondition | undefined];\n\ttoAST(): any;\n};\n\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nconst predicateInternalsMap = new Map<PredicateInternalsKey, GroupCondition>();\n\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nconst registerPredicateInternals = (condition: GroupCondition, key?: any) => {\n\tconst finalKey = key || new PredicateInternalsKey();\n\tpredicateInternalsMap.set(finalKey, condition);\n\treturn finalKey;\n};\n\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport const internals = (key: any) => {\n\tif (!predicateInternalsMap.has(key)) {\n\t\tthrow new Error(\n\t\t\t\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\"\n\t\t);\n\t}\n\treturn predicateInternalsMap.get(key)!;\n};\n\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nconst negations = {\n\tand: 'or',\n\tor: 'and',\n\tnot: 'and',\n\teq: 'ne',\n\tne: 'eq',\n\tgt: 'le',\n\tge: 'lt',\n\tlt: 'ge',\n\tle: 'gt',\n\tcontains: 'notContains',\n\tnotContains: 'contains',\n};\n\n/**\n * Given a V1 predicate \"seed\", applies a list of V2 field-level conditions\n * to the predicate, returning a new/final V1 predicate chain link.\n * @param predicate The base/seed V1 predicate to build on\n * @param conditions The V2 conditions to add to the predicate chain.\n * @param negateChildren Whether the conditions should be negated first.\n * @returns A V1 predicate, with conditions incorporated.\n */\nfunction applyConditionsToV1Predicate<T>(\n\tpredicate: T,\n\tconditions: FieldCondition[],\n\tnegateChildren: boolean\n): T {\n\tlet p = predicate;\n\tconst finalConditions: FieldCondition[] = [];\n\n\tfor (const c of conditions) {\n\t\tif (negateChildren) {\n\t\t\tif (c.operator === 'between') {\n\t\t\t\tfinalConditions.push(\n\t\t\t\t\tnew FieldCondition(c.field, 'lt', [c.operands[0]]),\n\t\t\t\t\tnew FieldCondition(c.field, 'gt', [c.operands[1]])\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfinalConditions.push(\n\t\t\t\t\tnew FieldCondition(c.field, negations[c.operator], c.operands)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tfinalConditions.push(c);\n\t\t}\n\t}\n\n\tfor (const c of finalConditions) {\n\t\tp = p[c.field](\n\t\t\tc.operator as never,\n\t\t\t(c.operator === 'between' ? c.operands : c.operands[0]) as never\n\t\t);\n\t}\n\treturn p;\n}\n\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nexport class FieldCondition {\n\tconstructor(\n\t\tpublic field: string,\n\t\tpublic operator: string,\n\t\tpublic operands: string[]\n\t) {\n\t\tthis.validate();\n\t}\n\n\t/**\n\t * Creates a copy of self.\n\t * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n\t * @returns A new, identitical `FieldCondition`.\n\t */\n\tcopy(extract: GroupCondition): [FieldCondition, GroupCondition | undefined] {\n\t\treturn [\n\t\t\tnew FieldCondition(this.field, this.operator, [...this.operands]),\n\t\t\tundefined,\n\t\t];\n\t}\n\n\ttoAST() {\n\t\treturn {\n\t\t\t[this.field]: {\n\t\t\t\t[this.operator]:\n\t\t\t\t\tthis.operator === 'between'\n\t\t\t\t\t\t? [this.operands[0], this.operands[1]]\n\t\t\t\t\t\t: this.operands[0],\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n\t * transforms them into legacy predicates. (*For now.*)\n\t * @param storage N/A. If ever implemented, the storage adapter to query.\n\t * @returns N/A. If ever implemented, return items from `storage` that match.\n\t */\n\tasync fetch(storage: StorageAdapter): Promise<Record<string, any>[]> {\n\t\treturn Promise.reject('No implementation needed [yet].');\n\t}\n\n\t/**\n\t * Determins whether a given item matches the expressed condition.\n\t * @param item The item to test.\n\t * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n\t */\n\tasync matches(item: Record<string, any>): Promise<boolean> {\n\t\tconst v = item[this.field];\n\t\tconst operations = {\n\t\t\teq: () => v === this.operands[0],\n\t\t\tne: () => v !== this.operands[0],\n\t\t\tgt: () => v > this.operands[0],\n\t\t\tge: () => v >= this.operands[0],\n\t\t\tlt: () => v < this.operands[0],\n\t\t\tle: () => v <= this.operands[0],\n\t\t\tcontains: () => v.indexOf(this.operands[0]) > -1,\n\t\t\tnotContains: () => v.indexOf(this.operands[0]) === -1,\n\t\t\tbeginsWith: () => v.startsWith(this.operands[0]),\n\t\t\tbetween: () => v >= this.operands[0] && v <= this.operands[1],\n\t\t};\n\t\tconst operation = operations[this.operator as keyof typeof operations];\n\t\tif (operation) {\n\t\t\tconst result = operation();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tthrow new Error(`Invalid operator given: ${this.operator}`);\n\t\t}\n\t}\n\n\t/**\n\t * Checks `this.operands` for compatibility with `this.operator`.\n\t */\n\tvalidate(): void {\n\t\t/**\n\t\t * Creates a validator that checks for a particular `operands` count.\n\t\t * Throws an exception if the `count` disagrees with `operands.length`.\n\t\t * @param count The number of `operands` expected.\n\t\t */\n\t\tconst argumentCount = count => {\n\t\t\tconst argsClause = count === 1 ? 'argument is' : 'arguments are';\n\t\t\treturn () => {\n\t\t\t\tif (this.operands.length !== count) {\n\t\t\t\t\treturn `Exactly ${count} ${argsClause} required.`;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t// NOTE: validations should return a message on failure.\n\t\t// hence, they should be \"joined\" together with logical OR's\n\t\t// as seen in the `between:` entry.\n\t\tconst validations = {\n\t\t\teq: argumentCount(1),\n\t\t\tne: argumentCount(1),\n\t\t\tgt: argumentCount(1),\n\t\t\tge: argumentCount(1),\n\t\t\tlt: argumentCount(1),\n\t\t\tle: argumentCount(1),\n\t\t\tcontains: argumentCount(1),\n\t\t\tnotContains: argumentCount(1),\n\t\t\tbeginsWith: argumentCount(1),\n\t\t\tbetween: () =>\n\t\t\t\targumentCount(2)() ||\n\t\t\t\t(this.operands[0] > this.operands[1]\n\t\t\t\t\t? 'The first argument must be less than or equal to the second argument.'\n\t\t\t\t\t: null),\n\t\t};\n\t\tconst validate = validations[this.operator as keyof typeof validations];\n\t\tif (validate) {\n\t\t\tconst e = validate();\n\t\t\tif (typeof e === 'string')\n\t\t\t\tthrow new Error(`Incorrect usage of \\`${this.operator}()\\`: ${e}`);\n\t\t} else {\n\t\t\tthrow new Error(`Non-existent operator: \\`${this.operator}()\\``);\n\t\t}\n\t}\n}\n\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nconst getGroupId = (() => {\n\tlet seed = 1;\n\treturn () => `group_${seed++}`;\n})();\n\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nexport class GroupCondition {\n\t// `groupId` was used for development/debugging.\n\t// Should we leave this in for future troubleshooting?\n\tpublic groupId = getGroupId();\n\n\tconstructor(\n\t\t/**\n\t\t * The `ModelMeta` of the model to query and/or filter against.\n\t\t * Expected to contain:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t * \tbuilder: ModelConstructor,\n\t\t * \tschema: SchemaModel,\n\t\t * \tpkField: string[]\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tpublic model: ModelMeta<any>,\n\n\t\t/**\n\t\t * If populated, this group specifices a condition on a relationship.\n\t\t *\n\t\t * If `field` does *not* point to a related model, that's an error. It\n\t\t * could indicate that the `GroupCondition` was instantiated with bad\n\t\t * data, or that the model metadata is incorrect.\n\t\t */\n\t\tpublic field: string | undefined,\n\n\t\t/**\n\t\t * If a `field` is given, whether the relationship is a `HAS_ONE`,\n\t\t * 'HAS_MANY`, or `BELONGS_TO`.\n\t\t *\n\t\t * TODO: Remove this and replace with derivation using\n\t\t * `ModelRelationship.from(this.model, this.field).relationship`;\n\t\t */\n\t\tpublic relationshipType: string | undefined,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operator: GroupOperator,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operands: UntypedCondition[]\n\t) {}\n\n\t/**\n\t * Returns a copy of a GroupCondition, which also returns the copy of a\n\t * given reference node to \"extract\".\n\t * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n\t * @returns [The full copy, the copy of `extract` | undefined]\n\t */\n\tcopy(extract: GroupCondition): [GroupCondition, GroupCondition | undefined] {\n\t\tconst copied = new GroupCondition(\n\t\t\tthis.model,\n\t\t\tthis.field,\n\t\t\tthis.relationshipType,\n\t\t\tthis.operator,\n\t\t\t[]\n\t\t);\n\n\t\tlet extractedCopy: GroupCondition | undefined =\n\t\t\textract === this ? copied : undefined;\n\n\t\tthis.operands.forEach(o => {\n\t\t\tconst [operandCopy, extractedFromOperand] = o.copy(extract);\n\t\t\tcopied.operands.push(operandCopy);\n\t\t\textractedCopy = extractedCopy || extractedFromOperand;\n\t\t});\n\n\t\treturn [copied, extractedCopy];\n\t}\n\n\t/**\n\t * Fetches matching records from a given storage adapter using legacy predicates (for now).\n\t * @param storage The storage adapter this predicate will query against.\n\t * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n\t * GroupdCondition.fetch is nested within.\n\t * @param negate Whether to match on the `NOT` of `this`.\n\t * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n\t */\n\tasync fetch(\n\t\tstorage: StorageAdapter,\n\t\tbreadcrumb: string[] = [],\n\t\tnegate = false\n\t): Promise<Record<string, any>[]> {\n\t\tconst resultGroups: Array<Record<string, any>[]> = [];\n\n\t\tconst operator = (negate ? negations[this.operator] : this.operator) as\n\t\t\t| 'or'\n\t\t\t| 'and'\n\t\t\t| 'not';\n\n\t\tconst negateChildren = negate !== (this.operator === 'not');\n\n\t\t/**\n\t\t * Conditions that must be branched out and used to generate a base, \"candidate\"\n\t\t * result set.\n\t\t *\n\t\t * If `field` is populated, these groups select *related* records, and the base,\n\t\t * candidate results are selected to match those.\n\t\t */\n\t\tconst groups = this.operands.filter(\n\t\t\top => op instanceof GroupCondition\n\t\t) as GroupCondition[];\n\n\t\t/**\n\t\t * Simple conditions that must match the target model of `this`.\n\t\t */\n\t\tconst conditions = this.operands.filter(\n\t\t\top => op instanceof FieldCondition\n\t\t) as FieldCondition[];\n\n\t\tfor (const g of groups) {\n\t\t\tconst relatives = await g.fetch(\n\t\t\t\tstorage,\n\t\t\t\t[...breadcrumb, this.groupId],\n\t\t\t\tnegateChildren\n\t\t\t);\n\n\t\t\t// no relatives -> no need to attempt to perform a \"join\" query for\n\t\t\t// candidate results:\n\t\t\t//\n\t\t\t// select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n\t\t\t//\n\t\t\t// Additionally, the entire (sub)-query can be short-circuited if\n\t\t\t// the operator is `AND`. Illustrated in SQL:\n\t\t\t//\n\t\t\t// select a.* from a where\n\t\t\t//   id in [a,b,c]\n\t\t\t//     AND                        <\n\t\t\t//   id in EMTPY_SET            <<< Look!\n\t\t\t//     AND                        <\n\t\t\t//   id in [x,y,z]\n\t\t\t//\n\t\t\t// YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n\t\t\t//\n\t\t\tif (relatives.length === 0) {\n\t\t\t\t// aggressively short-circuit as soon as we know the group condition will fail\n\t\t\t\tif (operator === 'and') {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// less aggressive short-circuit if we know the relatives will produce no\n\t\t\t\t// candidate results; but aren't sure yet how this affects the group condition.\n\t\t\t\tresultGroups.push([]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (g.field) {\n\t\t\t\t// `relatives` are actual relatives. We'll skim them for FK query values.\n\t\t\t\t// Use the relatives to add candidate result sets (`resultGroups`)\n\n\t\t\t\tconst relationship = ModelRelationship.from(this.model, g.field);\n\n\t\t\t\tif (relationship) {\n\t\t\t\t\tconst relativesPredicates: ((\n\t\t\t\t\t\tp: RecursiveModelPredicate<any>\n\t\t\t\t\t) => RecursiveModelPredicate<any>)[] = [];\n\t\t\t\t\tfor (const relative of relatives) {\n\t\t\t\t\t\tconst individualRowJoinConditions: FieldCondition[] = [];\n\n\t\t\t\t\t\tfor (let i = 0; i < relationship.localJoinFields.length; i++) {\n\t\t\t\t\t\t\t// rightHandValue\n\t\t\t\t\t\t\tindividualRowJoinConditions.push(\n\t\t\t\t\t\t\t\tnew FieldCondition(relationship.localJoinFields[i], 'eq', [\n\t\t\t\t\t\t\t\t\trelative[relationship.remoteJoinFields[i]],\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst predicate = p =>\n\t\t\t\t\t\t\tapplyConditionsToV1Predicate(\n\t\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\t\tindividualRowJoinConditions,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\trelativesPredicates.push(predicate as any);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = FlatModelPredicateCreator.createGroupFromExisting(\n\t\t\t\t\t\tthis.model.schema,\n\t\t\t\t\t\t'or',\n\t\t\t\t\t\trelativesPredicates as any\n\t\t\t\t\t);\n\n\t\t\t\t\tresultGroups.push(\n\t\t\t\t\t\tawait storage.query(this.model.builder, predicate as any)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Missing field metadata.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// relatives are not actually relatives. they're candidate results.\n\t\t\t\tresultGroups.push(relatives);\n\t\t\t}\n\t\t}\n\n\t\t// if conditions is empty at this point, child predicates found no matches.\n\t\t// i.e., we can stop looking and return empty.\n\t\tif (conditions.length > 0) {\n\t\t\tconst predicate = FlatModelPredicateCreator.createFromExisting(\n\t\t\t\tthis.model.schema,\n\t\t\t\tp =>\n\t\t\t\t\tp[operator](c =>\n\t\t\t\t\t\tapplyConditionsToV1Predicate(c, conditions, negateChildren)\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tresultGroups.push(\n\t\t\t\tawait storage.query(this.model.builder, predicate as any)\n\t\t\t);\n\t\t} else if (conditions.length === 0 && resultGroups.length === 0) {\n\t\t\tresultGroups.push(await storage.query(this.model.builder));\n\t\t}\n\n\t\t// PK might be a single field, like `id`, or it might be several fields.\n\t\t// so, we'll need to extract the list of PK fields from an object\n\t\t// and stringify the list for easy comparison / merging.\n\t\tconst getPKValue = item =>\n\t\t\tJSON.stringify(this.model.pkField.map(name => item[name]));\n\n\t\t// will be used for intersecting or unioning results\n\t\tlet resultIndex: Map<string, Record<string, any>> | undefined;\n\n\t\tif (operator === 'and') {\n\t\t\tif (resultGroups.length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// for each group, we intersect, removing items from the result index\n\t\t\t// that aren't present in each subsequent group.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tif (resultIndex === undefined) {\n\t\t\t\t\tresultIndex = new Map(group.map(item => [getPKValue(item), item]));\n\t\t\t\t} else {\n\t\t\t\t\tconst intersectWith = new Map<string, Record<string, any>>(\n\t\t\t\t\t\tgroup.map(item => [getPKValue(item), item])\n\t\t\t\t\t);\n\t\t\t\t\tfor (const k of resultIndex.keys()) {\n\t\t\t\t\t\tif (!intersectWith.has(k)) {\n\t\t\t\t\t\t\tresultIndex.delete(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (operator === 'or' || operator === 'not') {\n\t\t\t// it's OK to handle NOT here, because NOT must always only negate\n\t\t\t// a single child predicate. NOT logic will have been distributed down\n\t\t\t// to the leaf conditions already.\n\n\t\t\tresultIndex = new Map();\n\n\t\t\t// just merge the groups, performing DISTINCT-ification by ID.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tfor (const item of group) {\n\t\t\t\t\tresultIndex.set(getPKValue(item), item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(resultIndex?.values() || []);\n\t}\n\n\t/**\n\t * Determines whether a single item matches the conditions of `this`.\n\t * When checking the target `item`'s properties, each property will be `await`'d\n\t * to ensure lazy-loading is respected where applicable.\n\t * @param item The item to match against.\n\t * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n\t * (Used for iterating over children on HAS_MANY checks.)\n\t * @returns A boolean (promise): `true` if matched, `false` otherwise.\n\t */\n\tasync matches(\n\t\titem: Record<string, any>,\n\t\tignoreFieldName: boolean = false\n\t): Promise<boolean> {\n\t\tconst itemToCheck =\n\t\t\tthis.field && !ignoreFieldName ? await item[this.field] : item;\n\n\t\t// if there is no item to check, we can stop recursing immediately.\n\t\t// a condition cannot match against an item that does not exist. this\n\t\t// can occur when `item.field` is optional in the schema.\n\t\tif (!itemToCheck) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis.relationshipType === 'HAS_MANY' &&\n\t\t\ttypeof itemToCheck[Symbol.asyncIterator] === 'function'\n\t\t) {\n\t\t\tfor await (const singleItem of itemToCheck) {\n\t\t\t\tif (await this.matches(singleItem, true)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.operator === 'or') {\n\t\t\treturn asyncSome(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'and') {\n\t\t\treturn asyncEvery(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'not') {\n\t\t\tif (this.operands.length !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Invalid arguments! `not()` accepts exactly one predicate expression.'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn !(await this.operands[0].matches(itemToCheck));\n\t\t} else {\n\t\t\tthrow new Error('Invalid group operator!');\n\t\t}\n\t}\n\n\t/**\n\t * Tranfsorm to a AppSync GraphQL compatible AST.\n\t * (Does not support filtering in nested types.)\n\t */\n\ttoAST() {\n\t\tif (this.field)\n\t\t\tthrow new Error('Nested type conditions are not supported!');\n\n\t\treturn {\n\t\t\t[this.operator]: this.operands.map(operand => operand.toAST()),\n\t\t};\n\t}\n\n\ttoStoragePredicate<T>(\n\t\tbaseCondition?: StoragePredicate<T>\n\t): StoragePredicate<T> {\n\t\treturn FlatModelPredicateCreator.createFromAST(\n\t\t\tthis.model.schema,\n\t\t\tthis.toAST()\n\t\t) as unknown as StoragePredicate<T>;\n\t}\n}\n\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * TODO: the sortof-immutable algorithm was originally done to support legacy style\n * predicate branching (`p => p.x.eq(value).y.eq(value)`). i'm not sure this is\n * necessary or beneficial at this point, since we decided that each field condition\n * must flly terminate a branch. is the strong mutation barrier between chain links\n * still necessary or helpful?\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>,\n\tallowRecursion: boolean = true,\n\tfield?: string,\n\tquery?: GroupCondition,\n\ttail?: GroupCondition\n): RecursiveModelPredicate<T> & PredicateInternalsKey {\n\t// to be used if we don't have a base query or tail to build onto\n\tconst starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n\n\tconst baseCondition = query && tail ? query : starter;\n\tconst tailCondition = query && tail ? tail : starter;\n\n\t// our eventual return object, which can be built upon.\n\t// next steps will be to add or(), and(), not(), and field.op() methods.\n\tconst link = {} as any;\n\n\tregisterPredicateInternals(baseCondition, link);\n\n\tconst copyLink = () => {\n\t\tconst [query, newTail] = baseCondition.copy(tailCondition);\n\t\tconst newLink = recursivePredicateFor(\n\t\t\tModelType,\n\t\t\tallowRecursion,\n\t\t\tundefined,\n\t\t\tquery,\n\t\t\tnewTail\n\t\t);\n\t\treturn { query, newTail, newLink };\n\t};\n\n\t// Adds .or() and .and() methods to the link.\n\t// TODO: If revisiting this code, consider writing a Proxy instead.\n\t['and', 'or'].forEach(op => {\n\t\t(link as any)[op] = (\n\t\t\tbuilder: RecursiveModelPredicateAggregateExtender<T>\n\t\t) => {\n\t\t\t// or() and and() will return a copy of the original link\n\t\t\t// to head off mutability concerns.\n\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\tconst childConditions = builder(\n\t\t\t\trecursivePredicateFor(ModelType, allowRecursion)\n\t\t\t);\n\t\t\tif (!Array.isArray(childConditions)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid predicate. \\`${op}\\` groups must return an array of child conditions.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// the customer will supply a child predicate, which apply to the `model.field`\n\t\t\t// of the tail GroupCondition.\n\t\t\tnewTail?.operands.push(\n\t\t\t\tnew GroupCondition(\n\t\t\t\t\tModelType,\n\t\t\t\t\tfield,\n\t\t\t\t\tundefined,\n\t\t\t\t\top as 'and' | 'or',\n\t\t\t\t\tchildConditions.map(c => internals(c))\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// FinalPredicate\n\t\t\treturn registerPredicateInternals(query);\n\t\t};\n\t});\n\n\t// TODO: If revisiting this code, consider proxy.\n\tlink.not = (\n\t\tbuilder: RecursiveModelPredicateExtender<T>\n\t): PredicateInternalsKey => {\n\t\t// not() will return a copy of the original link\n\t\t// to head off mutability concerns.\n\t\tconst { query, newTail } = copyLink();\n\n\t\t// unlike and() and or(), the customer will supply a \"singular\" child predicate.\n\t\t// the difference being: not() does not accept an array of predicate-like objects.\n\t\t// it negates only a *single* predicate subtree.\n\t\tnewTail?.operands.push(\n\t\t\tnew GroupCondition(ModelType, field, undefined, 'not', [\n\t\t\t\tinternals(builder(recursivePredicateFor(ModelType, allowRecursion))),\n\t\t\t])\n\t\t);\n\n\t\t// A `FinalModelPredicate`.\n\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t// or query storage: `.__query.fetch(storage)`.\n\t\treturn registerPredicateInternals(query);\n\t};\n\n\t// For each field on the model schema, we want to add a getter\n\t// that creates the appropriate new `link` in the query chain.\n\t// TODO: If revisiting, consider a proxy.\n\tfor (const fieldName in ModelType.schema.fields) {\n\t\tObject.defineProperty(link, fieldName, {\n\t\t\tenumerable: true,\n\t\t\tget: () => {\n\t\t\t\tconst def = ModelType.schema.fields[fieldName];\n\n\t\t\t\tif (!def.association) {\n\t\t\t\t\t// we're looking at a value field. we need to return a\n\t\t\t\t\t// \"field matcher object\", which contains all of the comparison\n\t\t\t\t\t// functions ('eq', 'ne', 'gt', etc.), scoped to operate\n\t\t\t\t\t// against the target field (fieldName).\n\t\t\t\t\treturn ops.reduce((fieldMatcher, operator) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...fieldMatcher,\n\n\t\t\t\t\t\t\t// each operator on the fieldMatcher objcect is a function.\n\t\t\t\t\t\t\t// when the customer calls the function, it returns a new link\n\t\t\t\t\t\t\t// in the chain -- for now -- this is the \"leaf\" link that\n\t\t\t\t\t\t\t// cannot be further extended.\n\t\t\t\t\t\t\t[operator]: (...operands: any[]) => {\n\t\t\t\t\t\t\t\t// build off a fresh copy of the existing `link`, just in case\n\t\t\t\t\t\t\t\t// the same link is being used elsewhere by the customer.\n\t\t\t\t\t\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\t\t\t\t\t\t// add the given condition to the link's TAIL node.\n\t\t\t\t\t\t\t\t// remember: the base link might go N nodes deep! e.g.,\n\t\t\t\t\t\t\t\tnewTail?.operands.push(\n\t\t\t\t\t\t\t\t\tnew FieldCondition(fieldName, operator, operands)\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// A `FinalModelPredicate`.\n\t\t\t\t\t\t\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t\t\t\t\t\t\t// or query storage: `.__query.fetch(storage)`.\n\t\t\t\t\t\t\t\treturn registerPredicateInternals(query);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t}, {});\n\t\t\t\t} else {\n\t\t\t\t\tif (!allowRecursion) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Predication on releated models is not supported in this context.'\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tdef.association.connectionType === 'BELONGS_TO' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_ONE' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_MANY'\n\t\t\t\t\t) {\n\t\t\t\t\t\t// the use has just typed '.someRelatedModel'. we need to given them\n\t\t\t\t\t\t// back a predicate chain.\n\n\t\t\t\t\t\tconst relatedMeta = (def.type as ModelFieldType).modelConstructor;\n\t\t\t\t\t\tif (!relatedMeta) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t'Related model metadata is missing. This is a bug! Please report it.'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `Model.reletedModelField` returns a copy of the original link,\n\t\t\t\t\t\t// and will contains copies of internal GroupConditions\n\t\t\t\t\t\t// to head off mutability concerns.\n\t\t\t\t\t\tconst [newquery, oldtail] = baseCondition.copy(tailCondition);\n\t\t\t\t\t\tconst newtail = new GroupCondition(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tdef.association.connectionType,\n\t\t\t\t\t\t\t'and',\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// `oldtail` here refers to the *copy* of the old tail.\n\t\t\t\t\t\t// so, it's safe to modify at this point. and we need to modify\n\t\t\t\t\t\t// it to push the *new* tail onto the end of it.\n\t\t\t\t\t\t(oldtail as GroupCondition).operands.push(newtail);\n\t\t\t\t\t\tconst newlink = recursivePredicateFor(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tallowRecursion,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tnewquery,\n\t\t\t\t\t\t\tnewtail\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn newlink;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Related model definition doesn't have a typedef. This is a bug! Please report it.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n\n\treturn link;\n}\n\nexport function predicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>\n): ModelPredicate<T> & PredicateInternalsKey {\n\treturn recursivePredicateFor(ModelType, false) as any as ModelPredicate<T>;\n}\n"]},"metadata":{},"sourceType":"module"}