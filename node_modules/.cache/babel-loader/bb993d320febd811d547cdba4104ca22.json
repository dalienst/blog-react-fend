{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest, __values } from \"tslib\";\nimport { Logger, Mutex } from '@aws-amplify/core';\nimport PushStream from 'zen-push';\nimport { ModelPredicateCreator } from '../predicates';\nimport { OpType, QueryOne, isTargetNameAssociation } from '../types';\nimport { isModelConstructor, STORAGE, validatePredicate, valuesEqual } from '../util';\nimport { getIdentifierValue } from '../sync/utils';\nimport getDefaultAdapter from './adapter/getDefaultAdapter';\nvar logger = new Logger('DataStore');\n\nvar StorageClass =\n/** @class */\nfunction () {\n  function StorageClass(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId) {\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.getModelConstructorByModelName = getModelConstructorByModelName;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.adapter = adapter;\n    this.sessionId = sessionId;\n    this.adapter = this.adapter || getDefaultAdapter();\n    this.pushStream = new PushStream();\n  }\n\n  StorageClass.getNamespace = function () {\n    var namespace = {\n      name: STORAGE,\n      relationships: {},\n      enums: {},\n      models: {},\n      nonModels: {}\n    };\n    return namespace;\n  };\n\n  StorageClass.prototype.init = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var resolve, reject;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.initialized !== undefined)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.initialized];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n\n          case 2:\n            logger.debug('Starting Storage');\n            this.initialized = new Promise(function (res, rej) {\n              resolve = res;\n              reject = rej;\n            });\n            this.adapter.setUp(this.schema, this.namespaceResolver, this.modelInstanceCreator, this.getModelConstructorByModelName, this.sessionId).then(resolve, reject);\n            return [4\n            /*yield*/\n            , this.initialized];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  StorageClass.prototype.save = function (model, condition, mutator, patchesTuple) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.init()];\n\n          case 1:\n            _a.sent();\n\n            if (!this.adapter) {\n              throw new Error('Storage adapter is missing');\n            }\n\n            return [4\n            /*yield*/\n            , this.adapter.save(model, condition)];\n\n          case 2:\n            result = _a.sent();\n            result.forEach(function (r) {\n              var _a = __read(r, 2),\n                  savedElement = _a[0],\n                  opType = _a[1]; // truthy when save is called by the Merger\n\n\n              var syncResponse = !!mutator;\n              var updateMutationInput; // don't attempt to calc mutation input when storage.save\n              // is called by Merger, i.e., when processing an AppSync response\n\n              if (opType === OpType.UPDATE && !syncResponse) {\n                //\n                // TODO: LOOK!!!\n                // the `model` used here is in effect regardless of what model\n                // comes back from adapter.save().\n                // Prior to fix, SQLite adapter had been returning two models\n                // of different types, resulting in invalid outbox entries.\n                //\n                // the bug is essentially fixed in SQLite adapter.\n                // leaving as-is, because it's currently unclear whether anything\n                // depends on this remaining as-is.\n                //\n                updateMutationInput = _this.getUpdateMutationInput(model, savedElement, patchesTuple); // // an update without changed user fields\n                // => don't create mutationEvent\n\n                if (updateMutationInput === null) {\n                  return result;\n                }\n              }\n\n              var element = updateMutationInput || savedElement;\n              var modelConstructor = Object.getPrototypeOf(savedElement).constructor;\n\n              _this.pushStream.next({\n                model: modelConstructor,\n                opType: opType,\n                element: element,\n                mutator: mutator,\n                condition: condition && ModelPredicateCreator.getPredicates(condition, false) || null,\n                savedElement: savedElement\n              });\n            });\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  StorageClass.prototype.delete = function (modelOrModelConstructor, condition, mutator) {\n    return __awaiter(this, void 0, void 0, function () {\n      var models, deleted, modelConstructor, namespaceName, modelDefinition, modelIds;\n\n      var _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.init()];\n\n          case 1:\n            _b.sent();\n\n            if (!this.adapter) {\n              throw new Error('Storage adapter is missing');\n            }\n\n            return [4\n            /*yield*/\n            , this.adapter.delete(modelOrModelConstructor, condition)];\n\n          case 2:\n            _a = __read.apply(void 0, [_b.sent(), 2]), models = _a[0], deleted = _a[1];\n            modelConstructor = isModelConstructor(modelOrModelConstructor) ? modelOrModelConstructor : Object.getPrototypeOf(modelOrModelConstructor || {}).constructor;\n            namespaceName = this.namespaceResolver(modelConstructor);\n            modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n            modelIds = new Set(models.map(function (model) {\n              var modelId = getIdentifierValue(modelDefinition, model);\n              return modelId;\n            }));\n\n            if (!isModelConstructor(modelOrModelConstructor) && !Array.isArray(deleted)) {\n              deleted = [deleted];\n            }\n\n            deleted.forEach(function (model) {\n              var modelConstructor = Object.getPrototypeOf(model).constructor;\n              var theCondition;\n\n              if (!isModelConstructor(modelOrModelConstructor)) {\n                var modelId = getIdentifierValue(modelDefinition, model);\n                theCondition = modelIds.has(modelId) ? ModelPredicateCreator.getPredicates(condition, false) : undefined;\n              }\n\n              _this.pushStream.next({\n                model: modelConstructor,\n                opType: OpType.DELETE,\n                element: model,\n                mutator: mutator,\n                condition: theCondition || null\n              });\n            });\n            return [2\n            /*return*/\n            , [models, deleted]];\n        }\n      });\n    });\n  };\n\n  StorageClass.prototype.query = function (modelConstructor, predicate, pagination) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.init()];\n\n          case 1:\n            _a.sent();\n\n            if (!this.adapter) {\n              throw new Error('Storage adapter is missing');\n            }\n\n            return [4\n            /*yield*/\n            , this.adapter.query(modelConstructor, predicate, pagination)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  StorageClass.prototype.queryOne = function (modelConstructor, firstOrLast) {\n    if (firstOrLast === void 0) {\n      firstOrLast = QueryOne.FIRST;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.init()];\n\n          case 1:\n            _a.sent();\n\n            if (!this.adapter) {\n              throw new Error('Storage adapter is missing');\n            }\n\n            return [4\n            /*yield*/\n            , this.adapter.queryOne(modelConstructor, firstOrLast)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  StorageClass.prototype.observe = function (modelConstructor, predicate, skipOwn) {\n    var listenToAll = !modelConstructor;\n\n    var _a = predicate && ModelPredicateCreator.getPredicates(predicate, false) || {},\n        predicates = _a.predicates,\n        type = _a.type;\n\n    var result = this.pushStream.observable.filter(function (_a) {\n      var mutator = _a.mutator;\n      return !skipOwn || mutator !== skipOwn;\n    }).map(function (_a) {\n      var _mutator = _a.mutator,\n          message = __rest(_a, [\"mutator\"]);\n\n      return message;\n    });\n\n    if (!listenToAll) {\n      result = result.filter(function (_a) {\n        var model = _a.model,\n            element = _a.element;\n\n        if (modelConstructor !== model) {\n          return false;\n        }\n\n        if (!!predicates && !!type) {\n          return validatePredicate(element, type, predicates);\n        }\n\n        return true;\n      });\n    }\n\n    return result;\n  };\n\n  StorageClass.prototype.clear = function (completeObservable) {\n    if (completeObservable === void 0) {\n      completeObservable = true;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.initialized = undefined;\n\n            if (!this.adapter) {\n              throw new Error('Storage adapter is missing');\n            }\n\n            return [4\n            /*yield*/\n            , this.adapter.clear()];\n\n          case 1:\n            _a.sent();\n\n            if (completeObservable) {\n              this.pushStream.complete();\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  StorageClass.prototype.batchSave = function (modelConstructor, items, mutator) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.init()];\n\n          case 1:\n            _a.sent();\n\n            if (!this.adapter) {\n              throw new Error('Storage adapter is missing');\n            }\n\n            return [4\n            /*yield*/\n            , this.adapter.batchSave(modelConstructor, items)];\n\n          case 2:\n            result = _a.sent();\n            result.forEach(function (_a) {\n              var _b = __read(_a, 2),\n                  element = _b[0],\n                  opType = _b[1];\n\n              _this.pushStream.next({\n                model: modelConstructor,\n                opType: opType,\n                element: element,\n                mutator: mutator,\n                condition: null\n              });\n            });\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  }; // returns null if no user fields were changed (determined by value comparison)\n\n\n  StorageClass.prototype.getUpdateMutationInput = function (model, originalElement, patchesTuple) {\n    var e_1, _a;\n\n    var _b;\n\n    var containsPatches = patchesTuple && patchesTuple.length;\n\n    if (!containsPatches) {\n      return null;\n    }\n\n    var _c = __read(patchesTuple, 2),\n        patches = _c[0],\n        source = _c[1];\n\n    var updatedElement = {}; // extract array of updated fields from patches\n\n    var updatedFields = patches.map(function (patch) {\n      return patch.path && patch.path[0];\n    }); // check model def for association and replace with targetName if exists\n\n    var modelConstructor = Object.getPrototypeOf(model).constructor;\n    var namespace = this.namespaceResolver(modelConstructor);\n    var fields = this.schema.namespaces[namespace].models[modelConstructor.name].fields;\n\n    var _d = ((_b = this.schema.namespaces[namespace].keys) === null || _b === void 0 ? void 0 : _b[modelConstructor.name]) || {},\n        primaryKey = _d.primaryKey,\n        _e = _d.compositeKeys,\n        compositeKeys = _e === void 0 ? [] : _e; // set original values for these fields\n\n\n    updatedFields.forEach(function (field) {\n      var e_2, _a, e_3, _b, e_4, _c, e_5, _d, e_6, _e;\n\n      var _f;\n\n      var targetNames = isTargetNameAssociation((_f = fields[field]) === null || _f === void 0 ? void 0 : _f.association);\n\n      if (Array.isArray(targetNames)) {\n        try {\n          // if field refers to a belongsTo relation, use the target field instead\n          for (var targetNames_1 = __values(targetNames), targetNames_1_1 = targetNames_1.next(); !targetNames_1_1.done; targetNames_1_1 = targetNames_1.next()) {\n            var targetName = targetNames_1_1.value; // check field values by value. Ignore unchanged fields\n\n            if (!valuesEqual(source[targetName], originalElement[targetName])) {\n              // if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n              updatedElement[targetName] = originalElement[targetName] === undefined ? null : originalElement[targetName];\n\n              try {\n                for (var compositeKeys_1 = (e_3 = void 0, __values(compositeKeys)), compositeKeys_1_1 = compositeKeys_1.next(); !compositeKeys_1_1.done; compositeKeys_1_1 = compositeKeys_1.next()) {\n                  var fieldSet = compositeKeys_1_1.value; // include all of the fields that comprise the composite key\n\n                  if (fieldSet.has(targetName)) {\n                    try {\n                      for (var fieldSet_1 = (e_4 = void 0, __values(fieldSet)), fieldSet_1_1 = fieldSet_1.next(); !fieldSet_1_1.done; fieldSet_1_1 = fieldSet_1.next()) {\n                        var compositeField = fieldSet_1_1.value;\n                        updatedElement[compositeField] = originalElement[compositeField];\n                      }\n                    } catch (e_4_1) {\n                      e_4 = {\n                        error: e_4_1\n                      };\n                    } finally {\n                      try {\n                        if (fieldSet_1_1 && !fieldSet_1_1.done && (_c = fieldSet_1.return)) _c.call(fieldSet_1);\n                      } finally {\n                        if (e_4) throw e_4.error;\n                      }\n                    }\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (compositeKeys_1_1 && !compositeKeys_1_1.done && (_b = compositeKeys_1.return)) _b.call(compositeKeys_1);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (targetNames_1_1 && !targetNames_1_1.done && (_a = targetNames_1.return)) _a.call(targetNames_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      } else {\n        // Backwards compatibility pre-CPK\n        // if field refers to a belongsTo relation, use the target field instead\n        var key = targetNames || field; // check field values by value. Ignore unchanged fields\n\n        if (!valuesEqual(source[key], originalElement[key])) {\n          // if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n          updatedElement[key] = originalElement[key] === undefined ? null : originalElement[key];\n\n          try {\n            for (var compositeKeys_2 = __values(compositeKeys), compositeKeys_2_1 = compositeKeys_2.next(); !compositeKeys_2_1.done; compositeKeys_2_1 = compositeKeys_2.next()) {\n              var fieldSet = compositeKeys_2_1.value; // include all of the fields that comprise the composite key\n\n              if (fieldSet.has(key)) {\n                try {\n                  for (var fieldSet_2 = (e_6 = void 0, __values(fieldSet)), fieldSet_2_1 = fieldSet_2.next(); !fieldSet_2_1.done; fieldSet_2_1 = fieldSet_2.next()) {\n                    var compositeField = fieldSet_2_1.value;\n                    updatedElement[compositeField] = originalElement[compositeField];\n                  }\n                } catch (e_6_1) {\n                  e_6 = {\n                    error: e_6_1\n                  };\n                } finally {\n                  try {\n                    if (fieldSet_2_1 && !fieldSet_2_1.done && (_e = fieldSet_2.return)) _e.call(fieldSet_2);\n                  } finally {\n                    if (e_6) throw e_6.error;\n                  }\n                }\n              }\n            }\n          } catch (e_5_1) {\n            e_5 = {\n              error: e_5_1\n            };\n          } finally {\n            try {\n              if (compositeKeys_2_1 && !compositeKeys_2_1.done && (_d = compositeKeys_2.return)) _d.call(compositeKeys_2);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n          }\n        }\n      }\n    }); // Exit early when there are no changes introduced in the update mutation\n\n    if (Object.keys(updatedElement).length === 0) {\n      return null;\n    } // include field(s) from custom PK if one is specified for the model\n\n\n    if (primaryKey && primaryKey.length) {\n      try {\n        for (var primaryKey_1 = __values(primaryKey), primaryKey_1_1 = primaryKey_1.next(); !primaryKey_1_1.done; primaryKey_1_1 = primaryKey_1.next()) {\n          var pkField = primaryKey_1_1.value;\n          updatedElement[pkField] = originalElement[pkField];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (primaryKey_1_1 && !primaryKey_1_1.done && (_a = primaryKey_1.return)) _a.call(primaryKey_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    var id = originalElement.id,\n        _version = originalElement._version,\n        _lastChangedAt = originalElement._lastChangedAt,\n        _deleted = originalElement._deleted; // For update mutations we only want to send fields with changes\n    // and the required internal fields\n\n    return __assign(__assign({}, updatedElement), {\n      id: id,\n      _version: _version,\n      _lastChangedAt: _lastChangedAt,\n      _deleted: _deleted\n    });\n  };\n\n  return StorageClass;\n}();\n\nvar ExclusiveStorage =\n/** @class */\nfunction () {\n  function ExclusiveStorage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId) {\n    this.mutex = new Mutex();\n    this.storage = new StorageClass(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, adapter, sessionId);\n  }\n\n  ExclusiveStorage.prototype.runExclusive = function (fn) {\n    return this.mutex.runExclusive(fn.bind(this, this.storage));\n  };\n\n  ExclusiveStorage.prototype.save = function (model, condition, mutator, patchesTuple) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.runExclusive(function (storage) {\n          return storage.save(model, condition, mutator, patchesTuple);\n        })];\n      });\n    });\n  };\n\n  ExclusiveStorage.prototype.delete = function (modelOrModelConstructor, condition, mutator) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.runExclusive(function (storage) {\n          if (isModelConstructor(modelOrModelConstructor)) {\n            var modelConstructor = modelOrModelConstructor;\n            return storage.delete(modelConstructor, condition, mutator);\n          } else {\n            var model = modelOrModelConstructor;\n            return storage.delete(model, condition, mutator);\n          }\n        })];\n      });\n    });\n  };\n\n  ExclusiveStorage.prototype.query = function (modelConstructor, predicate, pagination) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.runExclusive(function (storage) {\n          return storage.query(modelConstructor, predicate, pagination);\n        })];\n      });\n    });\n  };\n\n  ExclusiveStorage.prototype.queryOne = function (modelConstructor, firstOrLast) {\n    if (firstOrLast === void 0) {\n      firstOrLast = QueryOne.FIRST;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.runExclusive(function (storage) {\n          return storage.queryOne(modelConstructor, firstOrLast);\n        })];\n      });\n    });\n  };\n\n  ExclusiveStorage.getNamespace = function () {\n    return StorageClass.getNamespace();\n  };\n\n  ExclusiveStorage.prototype.observe = function (modelConstructor, predicate, skipOwn) {\n    return this.storage.observe(modelConstructor, predicate, skipOwn);\n  };\n\n  ExclusiveStorage.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.runExclusive(function (storage) {\n              return storage.clear();\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  ExclusiveStorage.prototype.batchSave = function (modelConstructor, items) {\n    return this.storage.batchSave(modelConstructor, items);\n  };\n\n  ExclusiveStorage.prototype.init = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.storage.init()];\n      });\n    });\n  };\n\n  return ExclusiveStorage;\n}();\n\nexport { ExclusiveStorage };","map":{"version":3,"mappings":"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","names":["Logger","Mutex","PushStream","ModelPredicateCreator","OpType","QueryOne","isTargetNameAssociation","isModelConstructor","STORAGE","validatePredicate","valuesEqual","getIdentifierValue","getDefaultAdapter","logger","schema","namespaceResolver","getModelConstructorByModelName","modelInstanceCreator","adapter","sessionId","pushStream","StorageClass","namespace","name","relationships","enums","models","nonModels","initialized","undefined","_a","debug","Promise","res","rej","resolve","reject","setUp","then","model","condition","mutator","patchesTuple","init","Error","save","result","forEach","savedElement","opType","syncResponse","updateMutationInput","UPDATE","_this","getUpdateMutationInput","element","modelConstructor","Object","getPrototypeOf","constructor","next","getPredicates","modelOrModelConstructor","_b","delete","deleted","namespaceName","modelDefinition","namespaces","modelIds","Set","map","modelId","Array","isArray","theCondition","has","DELETE","predicate","pagination","query","firstOrLast","FIRST","queryOne","skipOwn","listenToAll","predicates","type","observable","filter","message","completeObservable","clear","complete","items","batchSave","originalElement","containsPatches","length","patches","source","updatedElement","updatedFields","path","patch","primaryKey","_e","compositeKeys","field","targetNames","fields","_f","association","targetNames_1_1","targetName","compositeKeys_1_1","fieldSet","fieldSet_1_1","compositeField","key","compositeKeys_2_1","fieldSet_2_1","keys","primaryKey_1_1","pkField","_version","_lastChangedAt","_deleted","id","storage","ExclusiveStorage","fn","mutex","runExclusive","bind","getNamespace","observe"],"sources":["/home/dalienst/node_modules/@aws-amplify/datastore/src/storage/storage.ts"],"sourcesContent":["import { Logger, Mutex } from '@aws-amplify/core';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport PushStream from 'zen-push';\nimport { Patch } from 'immer';\nimport { ModelInstanceCreator } from '../datastore/datastore';\nimport { ModelPredicateCreator } from '../predicates';\nimport {\n\tInternalSchema,\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tNamespaceResolver,\n\tOpType,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicatesGroup,\n\tQueryOne,\n\tSchemaNamespace,\n\tInternalSubscriptionMessage,\n\tSubscriptionMessage,\n\tisTargetNameAssociation,\n} from '../types';\nimport {\n\tisModelConstructor,\n\tSTORAGE,\n\tvalidatePredicate,\n\tvaluesEqual,\n\tNAMESPACES,\n} from '../util';\nimport { getIdentifierValue } from '../sync/utils';\nimport { Adapter } from './adapter';\nimport getDefaultAdapter from './adapter/getDefaultAdapter';\n\nexport type StorageSubscriptionMessage<T extends PersistentModel> =\n\tInternalSubscriptionMessage<T> & {\n\t\tmutator?: Symbol;\n\t};\n\nexport type StorageFacade = Omit<Adapter, 'setUp'>;\nexport type Storage = InstanceType<typeof StorageClass>;\n\nconst logger = new Logger('DataStore');\nclass StorageClass implements StorageFacade {\n\tprivate initialized: Promise<void> | undefined;\n\tprivate readonly pushStream: {\n\t\tobservable: Observable<StorageSubscriptionMessage<PersistentModel>>;\n\t} & Required<\n\t\tZenObservable.Observer<StorageSubscriptionMessage<PersistentModel>>\n\t>;\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly namespaceResolver: NamespaceResolver,\n\t\tprivate readonly getModelConstructorByModelName: (\n\t\t\tnamsespaceName: NAMESPACES,\n\t\t\tmodelName: string\n\t\t) => PersistentModelConstructor<any>,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly adapter?: Adapter,\n\t\tprivate readonly sessionId?: string\n\t) {\n\t\tthis.adapter = this.adapter || getDefaultAdapter();\n\t\tthis.pushStream = new PushStream() as any;\n\t}\n\n\tstatic getNamespace() {\n\t\tconst namespace: SchemaNamespace = {\n\t\t\tname: STORAGE,\n\t\t\trelationships: {},\n\t\t\tenums: {},\n\t\t\tmodels: {},\n\t\t\tnonModels: {},\n\t\t};\n\n\t\treturn namespace;\n\t}\n\n\tasync init() {\n\t\tif (this.initialized !== undefined) {\n\t\t\tawait this.initialized;\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug('Starting Storage');\n\n\t\tlet resolve: (value?: void | PromiseLike<void>) => void;\n\t\tlet reject: (value?: void | PromiseLike<void>) => void;\n\n\t\tthis.initialized = new Promise<void>((res, rej) => {\n\t\t\tresolve = res;\n\t\t\treject = rej;\n\t\t});\n\n\t\tthis.adapter!.setUp(\n\t\t\tthis.schema,\n\t\t\tthis.namespaceResolver,\n\t\t\tthis.modelInstanceCreator,\n\t\t\tthis.getModelConstructorByModelName,\n\t\t\tthis.sessionId\n\t\t).then(resolve!, reject!);\n\n\t\tawait this.initialized;\n\t}\n\n\tasync save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol,\n\t\tpatchesTuple?: [Patch[], PersistentModel]\n\t): Promise<[T, OpType.INSERT | OpType.UPDATE][]> {\n\t\tawait this.init();\n\t\tif (!this.adapter) {\n\t\t\tthrow new Error('Storage adapter is missing');\n\t\t}\n\n\t\tconst result = await this.adapter.save(model, condition);\n\n\t\tresult.forEach(r => {\n\t\t\tconst [savedElement, opType] = r;\n\n\t\t\t// truthy when save is called by the Merger\n\t\t\tconst syncResponse = !!mutator;\n\n\t\t\tlet updateMutationInput;\n\t\t\t// don't attempt to calc mutation input when storage.save\n\t\t\t// is called by Merger, i.e., when processing an AppSync response\n\t\t\tif (opType === OpType.UPDATE && !syncResponse) {\n\t\t\t\t//\n\t\t\t\t// TODO: LOOK!!!\n\t\t\t\t// the `model` used here is in effect regardless of what model\n\t\t\t\t// comes back from adapter.save().\n\t\t\t\t// Prior to fix, SQLite adapter had been returning two models\n\t\t\t\t// of different types, resulting in invalid outbox entries.\n\t\t\t\t//\n\t\t\t\t// the bug is essentially fixed in SQLite adapter.\n\t\t\t\t// leaving as-is, because it's currently unclear whether anything\n\t\t\t\t// depends on this remaining as-is.\n\t\t\t\t//\n\n\t\t\t\tupdateMutationInput = this.getUpdateMutationInput(\n\t\t\t\t\tmodel,\n\t\t\t\t\tsavedElement,\n\t\t\t\t\tpatchesTuple\n\t\t\t\t);\n\t\t\t\t// // an update without changed user fields\n\t\t\t\t// => don't create mutationEvent\n\t\t\t\tif (updateMutationInput === null) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst element = updateMutationInput || savedElement;\n\n\t\t\tconst modelConstructor = (Object.getPrototypeOf(savedElement) as Object)\n\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\tthis.pushStream.next({\n\t\t\t\tmodel: modelConstructor as any,\n\t\t\t\topType,\n\t\t\t\telement,\n\t\t\t\tmutator,\n\t\t\t\tcondition:\n\t\t\t\t\t(condition &&\n\t\t\t\t\t\tModelPredicateCreator.getPredicates(condition, false)) ||\n\t\t\t\t\tnull,\n\t\t\t\tsavedElement,\n\t\t\t});\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tdelete<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol\n\t): Promise<[T[], T[]]>;\n\tdelete<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol\n\t): Promise<[T[], T[]]>;\n\tasync delete<T extends PersistentModel>(\n\t\tmodelOrModelConstructor: T | PersistentModelConstructor<T>,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol\n\t): Promise<[T[], T[]]> {\n\t\tawait this.init();\n\t\tif (!this.adapter) {\n\t\t\tthrow new Error('Storage adapter is missing');\n\t\t}\n\n\t\tlet models: T[];\n\t\tlet deleted: T[] | undefined;\n\n\t\t[models, deleted] = await this.adapter.delete(\n\t\t\tmodelOrModelConstructor,\n\t\t\tcondition\n\t\t);\n\n\t\tconst modelConstructor = isModelConstructor(modelOrModelConstructor)\n\t\t\t? modelOrModelConstructor\n\t\t\t: (Object.getPrototypeOf(modelOrModelConstructor || {})\n\t\t\t\t\t.constructor as PersistentModelConstructor<T>);\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst modelDefinition =\n\t\t\tthis.schema.namespaces[namespaceName].models[modelConstructor.name];\n\n\t\tconst modelIds = new Set(\n\t\t\tmodels.map(model => {\n\t\t\t\tconst modelId = getIdentifierValue(modelDefinition, model);\n\t\t\t\treturn modelId;\n\t\t\t})\n\t\t);\n\n\t\tif (\n\t\t\t!isModelConstructor(modelOrModelConstructor) &&\n\t\t\t!Array.isArray(deleted)\n\t\t) {\n\t\t\tdeleted = [deleted];\n\t\t}\n\n\t\tdeleted.forEach(model => {\n\t\t\tconst modelConstructor = (Object.getPrototypeOf(model) as Object)\n\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\tlet theCondition: PredicatesGroup<any> | undefined;\n\n\t\t\tif (!isModelConstructor(modelOrModelConstructor)) {\n\t\t\t\tconst modelId = getIdentifierValue(modelDefinition, model);\n\t\t\t\ttheCondition = modelIds.has(modelId)\n\t\t\t\t\t? ModelPredicateCreator.getPredicates(condition!, false)\n\t\t\t\t\t: undefined;\n\t\t\t}\n\n\t\t\tthis.pushStream.next({\n\t\t\t\tmodel: modelConstructor as any,\n\t\t\t\topType: OpType.DELETE,\n\t\t\t\telement: model,\n\t\t\t\tmutator,\n\t\t\t\tcondition: theCondition || null,\n\t\t\t});\n\t\t});\n\n\t\treturn [models, deleted];\n\t}\n\n\tasync query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]> {\n\t\tawait this.init();\n\t\tif (!this.adapter) {\n\t\t\tthrow new Error('Storage adapter is missing');\n\t\t}\n\n\t\treturn await this.adapter.query(modelConstructor, predicate, pagination);\n\t}\n\n\tasync queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne = QueryOne.FIRST\n\t): Promise<T | undefined> {\n\t\tawait this.init();\n\t\tif (!this.adapter) {\n\t\t\tthrow new Error('Storage adapter is missing');\n\t\t}\n\n\t\treturn await this.adapter.queryOne(modelConstructor, firstOrLast);\n\t}\n\n\tobserve<T extends PersistentModel>(\n\t\tmodelConstructor?: PersistentModelConstructor<T> | null,\n\t\tpredicate?: ModelPredicate<T> | null,\n\t\tskipOwn?: Symbol\n\t): Observable<SubscriptionMessage<T>> {\n\t\tconst listenToAll = !modelConstructor;\n\t\tconst { predicates, type } =\n\t\t\t(predicate && ModelPredicateCreator.getPredicates(predicate, false)) ||\n\t\t\t{};\n\n\t\tlet result = this.pushStream.observable\n\t\t\t.filter(({ mutator }) => {\n\t\t\t\treturn !skipOwn || mutator !== skipOwn;\n\t\t\t})\n\t\t\t.map(\n\t\t\t\t({ mutator: _mutator, ...message }) => message as SubscriptionMessage<T>\n\t\t\t);\n\n\t\tif (!listenToAll) {\n\t\t\tresult = result.filter(({ model, element }) => {\n\t\t\t\tif (modelConstructor !== model) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (!!predicates && !!type) {\n\t\t\t\t\treturn validatePredicate(element, type, predicates);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync clear(completeObservable = true) {\n\t\tthis.initialized = undefined;\n\t\tif (!this.adapter) {\n\t\t\tthrow new Error('Storage adapter is missing');\n\t\t}\n\n\t\tawait this.adapter.clear();\n\n\t\tif (completeObservable) {\n\t\t\tthis.pushStream.complete();\n\t\t}\n\t}\n\n\tasync batchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<any>,\n\t\titems: ModelInstanceMetadata[],\n\t\tmutator?: Symbol\n\t): Promise<[T, OpType][]> {\n\t\tawait this.init();\n\t\tif (!this.adapter) {\n\t\t\tthrow new Error('Storage adapter is missing');\n\t\t}\n\n\t\tconst result = await this.adapter.batchSave(modelConstructor, items);\n\n\t\tresult.forEach(([element, opType]) => {\n\t\t\tthis.pushStream.next({\n\t\t\t\tmodel: modelConstructor,\n\t\t\t\topType,\n\t\t\t\telement,\n\t\t\t\tmutator,\n\t\t\t\tcondition: null,\n\t\t\t});\n\t\t});\n\n\t\treturn result as any;\n\t}\n\n\t// returns null if no user fields were changed (determined by value comparison)\n\tprivate getUpdateMutationInput<T extends PersistentModel>(\n\t\tmodel: T,\n\t\toriginalElement: T,\n\t\tpatchesTuple?: [Patch[], PersistentModel]\n\t): PersistentModel | null {\n\t\tconst containsPatches = patchesTuple && patchesTuple.length;\n\t\tif (!containsPatches) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst [patches, source] = patchesTuple!;\n\t\tconst updatedElement = {};\n\t\t// extract array of updated fields from patches\n\t\tconst updatedFields = <string[]>(\n\t\t\tpatches.map(patch => patch.path && patch.path[0])\n\t\t);\n\n\t\t// check model def for association and replace with targetName if exists\n\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\tconst namespace = this.namespaceResolver(modelConstructor);\n\t\tconst { fields } =\n\t\t\tthis.schema.namespaces[namespace].models[modelConstructor.name];\n\t\tconst { primaryKey, compositeKeys = [] } =\n\t\t\tthis.schema.namespaces[namespace].keys?.[modelConstructor.name] || {};\n\n\t\t// set original values for these fields\n\t\tupdatedFields.forEach((field: string) => {\n\t\t\tconst targetNames: any = isTargetNameAssociation(\n\t\t\t\tfields[field]?.association\n\t\t\t);\n\n\t\t\tif (Array.isArray(targetNames)) {\n\t\t\t\t// if field refers to a belongsTo relation, use the target field instead\n\n\t\t\t\tfor (const targetName of targetNames) {\n\t\t\t\t\t// check field values by value. Ignore unchanged fields\n\t\t\t\t\tif (!valuesEqual(source[targetName], originalElement[targetName])) {\n\t\t\t\t\t\t// if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n\n\t\t\t\t\t\tupdatedElement[targetName] =\n\t\t\t\t\t\t\toriginalElement[targetName] === undefined\n\t\t\t\t\t\t\t\t? null\n\t\t\t\t\t\t\t\t: originalElement[targetName];\n\n\t\t\t\t\t\tfor (const fieldSet of compositeKeys) {\n\t\t\t\t\t\t\t// include all of the fields that comprise the composite key\n\t\t\t\t\t\t\tif (fieldSet.has(targetName)) {\n\t\t\t\t\t\t\t\tfor (const compositeField of fieldSet) {\n\t\t\t\t\t\t\t\t\tupdatedElement[compositeField] =\n\t\t\t\t\t\t\t\t\t\toriginalElement[compositeField];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Backwards compatibility pre-CPK\n\n\t\t\t\t// if field refers to a belongsTo relation, use the target field instead\n\t\t\t\tconst key = targetNames || field;\n\n\t\t\t\t// check field values by value. Ignore unchanged fields\n\t\t\t\tif (!valuesEqual(source[key], originalElement[key])) {\n\t\t\t\t\t// if the field was updated to 'undefined', replace with 'null' for compatibility with JSON and GraphQL\n\n\t\t\t\t\tupdatedElement[key] =\n\t\t\t\t\t\toriginalElement[key] === undefined ? null : originalElement[key];\n\n\t\t\t\t\tfor (const fieldSet of compositeKeys) {\n\t\t\t\t\t\t// include all of the fields that comprise the composite key\n\t\t\t\t\t\tif (fieldSet.has(key)) {\n\t\t\t\t\t\t\tfor (const compositeField of fieldSet) {\n\t\t\t\t\t\t\t\tupdatedElement[compositeField] =\n\t\t\t\t\t\t\t\t\toriginalElement[compositeField];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Exit early when there are no changes introduced in the update mutation\n\t\tif (Object.keys(updatedElement).length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// include field(s) from custom PK if one is specified for the model\n\t\tif (primaryKey && primaryKey.length) {\n\t\t\tfor (const pkField of primaryKey) {\n\t\t\t\tupdatedElement[pkField] = originalElement[pkField];\n\t\t\t}\n\t\t}\n\n\t\tconst { id, _version, _lastChangedAt, _deleted } = originalElement;\n\n\t\t// For update mutations we only want to send fields with changes\n\t\t// and the required internal fields\n\t\treturn {\n\t\t\t...updatedElement,\n\t\t\tid,\n\t\t\t_version,\n\t\t\t_lastChangedAt,\n\t\t\t_deleted,\n\t\t};\n\t}\n}\n\nclass ExclusiveStorage implements StorageFacade {\n\tprivate storage: StorageClass;\n\tprivate readonly mutex = new Mutex();\n\tconstructor(\n\t\tschema: InternalSchema,\n\t\tnamespaceResolver: NamespaceResolver,\n\t\tgetModelConstructorByModelName: (\n\t\t\tnamsespaceName: NAMESPACES,\n\t\t\tmodelName: string\n\t\t) => PersistentModelConstructor<any>,\n\t\tmodelInstanceCreator: ModelInstanceCreator,\n\t\tadapter?: Adapter,\n\t\tsessionId?: string\n\t) {\n\t\tthis.storage = new StorageClass(\n\t\t\tschema,\n\t\t\tnamespaceResolver,\n\t\t\tgetModelConstructorByModelName,\n\t\t\tmodelInstanceCreator,\n\t\t\tadapter,\n\t\t\tsessionId\n\t\t);\n\t}\n\n\trunExclusive<T>(fn: (storage: StorageClass) => Promise<T>) {\n\t\treturn <Promise<T>>this.mutex.runExclusive(fn.bind(this, this.storage));\n\t}\n\n\tasync save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol,\n\t\tpatchesTuple?: [Patch[], PersistentModel]\n\t): Promise<[T, OpType.INSERT | OpType.UPDATE][]> {\n\t\treturn this.runExclusive<[T, OpType.INSERT | OpType.UPDATE][]>(storage =>\n\t\t\tstorage.save(model, condition, mutator, patchesTuple)\n\t\t);\n\t}\n\n\tasync delete<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol\n\t): Promise<[T[], T[]]>;\n\tasync delete<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol\n\t): Promise<[T[], T[]]>;\n\tasync delete<T extends PersistentModel>(\n\t\tmodelOrModelConstructor: T | PersistentModelConstructor<T>,\n\t\tcondition?: ModelPredicate<T>,\n\t\tmutator?: Symbol\n\t): Promise<[T[], T[]]> {\n\t\treturn this.runExclusive<[T[], T[]]>(storage => {\n\t\t\tif (isModelConstructor(modelOrModelConstructor)) {\n\t\t\t\tconst modelConstructor = modelOrModelConstructor;\n\n\t\t\t\treturn storage.delete(modelConstructor as any, condition, mutator);\n\t\t\t} else {\n\t\t\t\tconst model = modelOrModelConstructor;\n\n\t\t\t\treturn storage.delete(model as any, condition, mutator);\n\t\t\t}\n\t\t});\n\t}\n\n\tasync query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]> {\n\t\treturn this.runExclusive<T[]>(storage =>\n\t\t\tstorage.query<T>(modelConstructor, predicate, pagination)\n\t\t);\n\t}\n\n\tasync queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne = QueryOne.FIRST\n\t): Promise<T | undefined> {\n\t\treturn this.runExclusive<T | undefined>(storage =>\n\t\t\tstorage.queryOne<T>(modelConstructor, firstOrLast)\n\t\t);\n\t}\n\n\tstatic getNamespace() {\n\t\treturn StorageClass.getNamespace();\n\t}\n\n\tobserve<T extends PersistentModel>(\n\t\tmodelConstructor?: PersistentModelConstructor<T> | null,\n\t\tpredicate?: ModelPredicate<T> | null,\n\t\tskipOwn?: Symbol\n\t): Observable<SubscriptionMessage<T>> {\n\t\treturn this.storage.observe(modelConstructor, predicate, skipOwn);\n\t}\n\n\tasync clear() {\n\t\tawait this.runExclusive(storage => storage.clear());\n\t}\n\n\tbatchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\titems: ModelInstanceMetadata[]\n\t): Promise<[T, OpType][]> {\n\t\treturn this.storage.batchSave(modelConstructor, items);\n\t}\n\n\tasync init() {\n\t\treturn this.storage.init();\n\t}\n}\n\nexport { ExclusiveStorage };\n"]},"metadata":{},"sourceType":"module"}