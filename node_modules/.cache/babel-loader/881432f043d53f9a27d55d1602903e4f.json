{"ast":null,"code":"import { __awaiter, __extends, __generator, __read, __spread } from \"tslib\";\nimport { ConsoleLogger as Logger } from '../Logger/ConsoleLogger';\nvar logger = new Logger('Util');\n\nvar NonRetryableError =\n/** @class */\nfunction (_super) {\n  __extends(NonRetryableError, _super);\n\n  function NonRetryableError(message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.nonRetryable = true;\n    return _this;\n  }\n\n  return NonRetryableError;\n}(Error);\n\nexport { NonRetryableError };\nexport var isNonRetryableError = function (obj) {\n  var key = 'nonRetryable';\n  return obj && obj[key];\n};\n/**\n * @private\n * Internal use of Amplify only\n */\n\nexport function retry(functionToRetry, args, delayFn, onTerminate) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      if (typeof functionToRetry !== 'function') {\n        throw Error('functionToRetry must be a function');\n      }\n\n      return [2\n      /*return*/\n      , new Promise(function (resolve, reject) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var attempt, terminated, timeout, wakeUp, lastError, _loop_1, state_1;\n\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                attempt = 0;\n                terminated = false;\n\n                wakeUp = function () {};\n\n                onTerminate && onTerminate.then(function () {\n                  // signal not to try anymore.\n                  terminated = true; // stop sleeping if we're sleeping.\n\n                  clearTimeout(timeout);\n                  wakeUp();\n                });\n\n                _loop_1 = function () {\n                  var _a, _b, err_1, retryIn_1;\n\n                  return __generator(this, function (_c) {\n                    switch (_c.label) {\n                      case 0:\n                        attempt++;\n                        logger.debug(functionToRetry.name + \" attempt #\" + attempt + \" with this vars: \" + JSON.stringify(args));\n                        _c.label = 1;\n\n                      case 1:\n                        _c.trys.push([1, 3,, 7]);\n\n                        _a = {};\n                        _b = resolve;\n                        return [4\n                        /*yield*/\n                        , functionToRetry.apply(void 0, __spread(args))];\n\n                      case 2:\n                        return [2\n                        /*return*/\n                        , (_a.value = _b.apply(void 0, [_c.sent()]), _a)];\n\n                      case 3:\n                        err_1 = _c.sent();\n                        lastError = err_1;\n                        logger.debug(\"error on \" + functionToRetry.name, err_1);\n\n                        if (isNonRetryableError(err_1)) {\n                          logger.debug(functionToRetry.name + \" non retryable error\", err_1);\n                          return [2\n                          /*return*/\n                          , {\n                            value: reject(err_1)\n                          }];\n                        }\n\n                        retryIn_1 = delayFn(attempt, args, err_1);\n                        logger.debug(functionToRetry.name + \" retrying in \" + retryIn_1 + \" ms\");\n                        if (!(retryIn_1 === false || terminated)) return [3\n                        /*break*/\n                        , 4];\n                        return [2\n                        /*return*/\n                        , {\n                          value: reject(err_1)\n                        }];\n\n                      case 4:\n                        return [4\n                        /*yield*/\n                        , new Promise(function (r) {\n                          wakeUp = r; // export wakeUp for onTerminate handling\n\n                          timeout = setTimeout(wakeUp, retryIn_1);\n                        })];\n\n                      case 5:\n                        _c.sent();\n\n                        _c.label = 6;\n\n                      case 6:\n                        return [3\n                        /*break*/\n                        , 7];\n\n                      case 7:\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                };\n\n                _a.label = 1;\n\n              case 1:\n                if (!!terminated) return [3\n                /*break*/\n                , 3];\n                return [5\n                /*yield**/\n                , _loop_1()];\n\n              case 2:\n                state_1 = _a.sent();\n                if (typeof state_1 === \"object\") return [2\n                /*return*/\n                , state_1.value];\n                return [3\n                /*break*/\n                , 1];\n\n              case 3:\n                // reached if terminated while waiting for a timer.\n                reject(lastError);\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      })];\n    });\n  });\n}\nvar MAX_DELAY_MS = 5 * 60 * 1000;\n/**\n * @private\n * Internal use of Amplify only\n */\n\nexport function jitteredBackoff(maxDelayMs) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n\n  var BASE_TIME_MS = 100;\n  var JITTER_FACTOR = 100;\n  return function (attempt) {\n    var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n    return delay > maxDelayMs ? false : delay;\n  };\n}\n/**\n * @private\n * Internal use of Amplify only\n */\n\nexport var jitteredExponentialRetry = function (functionToRetry, args, maxDelayMs, onTerminate) {\n  if (maxDelayMs === void 0) {\n    maxDelayMs = MAX_DELAY_MS;\n  }\n\n  return retry(functionToRetry, args, jitteredBackoff(maxDelayMs), onTerminate);\n};","map":{"version":3,"mappings":"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","names":["ConsoleLogger","Logger","logger","__extends","message","_super","_this","Error","isNonRetryableError","obj","key","retry","functionToRetry","args","delayFn","onTerminate","Promise","resolve","reject","attempt","terminated","wakeUp","then","clearTimeout","timeout","debug","name","JSON","stringify","_b","__spread","_c","_a","lastError","err_1","retryIn_1","r","setTimeout","MAX_DELAY_MS","jitteredBackoff","maxDelayMs","BASE_TIME_MS","JITTER_FACTOR","delay","Math","random","jitteredExponentialRetry"],"sources":["/home/dalienst/node_modules/@aws-amplify/core/src/Util/Retry.ts"],"sourcesContent":["import { DelayFunction } from '../types';\nimport { ConsoleLogger as Logger } from '../Logger/ConsoleLogger';\nconst logger = new Logger('Util');\n\nexport class NonRetryableError extends Error {\n\tpublic readonly nonRetryable = true;\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t}\n}\n\nexport const isNonRetryableError = (obj: any): obj is NonRetryableError => {\n\tconst key: keyof NonRetryableError = 'nonRetryable';\n\treturn obj && obj[key];\n};\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport async function retry<T>(\n\tfunctionToRetry: (...args: any[]) => T,\n\targs: any[],\n\tdelayFn: DelayFunction,\n\tonTerminate?: Promise<void>\n): Promise<T> {\n\tif (typeof functionToRetry !== 'function') {\n\t\tthrow Error('functionToRetry must be a function');\n\t}\n\n\treturn new Promise(async (resolve, reject) => {\n\t\tlet attempt = 0;\n\t\tlet terminated = false;\n\t\tlet timeout: any;\n\t\tlet wakeUp: any = () => {}; // will be replaced with a resolver()\n\n\t\t// used after the loop if terminated while waiting for a timer.\n\t\tlet lastError: Error;\n\n\t\tonTerminate &&\n\t\t\tonTerminate.then(() => {\n\t\t\t\t// signal not to try anymore.\n\t\t\t\tterminated = true;\n\n\t\t\t\t// stop sleeping if we're sleeping.\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\twakeUp();\n\t\t\t});\n\n\t\twhile (!terminated) {\n\t\t\tattempt++;\n\n\t\t\tlogger.debug(\n\t\t\t\t`${\n\t\t\t\t\tfunctionToRetry.name\n\t\t\t\t} attempt #${attempt} with this vars: ${JSON.stringify(args)}`\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\treturn resolve(await functionToRetry(...args));\n\t\t\t} catch (err) {\n\t\t\t\tlastError = err;\n\t\t\t\tlogger.debug(`error on ${functionToRetry.name}`, err);\n\n\t\t\t\tif (isNonRetryableError(err)) {\n\t\t\t\t\tlogger.debug(`${functionToRetry.name} non retryable error`, err);\n\t\t\t\t\treturn reject(err);\n\t\t\t\t}\n\n\t\t\t\tconst retryIn = delayFn(attempt, args, err);\n\t\t\t\tlogger.debug(`${functionToRetry.name} retrying in ${retryIn} ms`);\n\n\t\t\t\t// we check `terminated` again here because it could have flipped\n\t\t\t\t// in the time it took `functionToRetry` to return.\n\t\t\t\tif (retryIn === false || terminated) {\n\t\t\t\t\treturn reject(err);\n\t\t\t\t} else {\n\t\t\t\t\tawait new Promise(r => {\n\t\t\t\t\t\twakeUp = r; // export wakeUp for onTerminate handling\n\t\t\t\t\t\ttimeout = setTimeout(wakeUp, retryIn);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// reached if terminated while waiting for a timer.\n\t\treject(lastError);\n\t});\n}\n\nconst MAX_DELAY_MS = 5 * 60 * 1000;\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport function jitteredBackoff(\n\tmaxDelayMs: number = MAX_DELAY_MS\n): DelayFunction {\n\tconst BASE_TIME_MS = 100;\n\tconst JITTER_FACTOR = 100;\n\n\treturn attempt => {\n\t\tconst delay = 2 ** attempt * BASE_TIME_MS + JITTER_FACTOR * Math.random();\n\t\treturn delay > maxDelayMs ? false : delay;\n\t};\n}\n\n/**\n * @private\n * Internal use of Amplify only\n */\nexport const jitteredExponentialRetry = <T>(\n\tfunctionToRetry: (...args: any[]) => T,\n\targs: any[],\n\tmaxDelayMs: number = MAX_DELAY_MS,\n\tonTerminate?: Promise<void>\n): Promise<T> =>\n\tretry(functionToRetry, args, jitteredBackoff(maxDelayMs), onTerminate);\n"]},"metadata":{},"sourceType":"module"}