{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __extends, __generator, __read, __rest, __spread, __values } from \"tslib\";\nimport { API } from '@aws-amplify/api';\nimport { Auth } from '@aws-amplify/auth';\nimport { Cache } from '@aws-amplify/cache';\nimport { Amplify, ConsoleLogger as Logger, Hub, browserOrNode, BackgroundProcessManager } from '@aws-amplify/core';\nimport { immerable, produce, setAutoFreeze, enablePatches } from 'immer';\nimport { v4 as uuid4 } from 'uuid';\nimport Observable from 'zen-observable-ts';\nimport { defaultAuthStrategy, multiAuthStrategy } from '../authModeStrategies';\nimport { isPredicatesAll, ModelPredicateCreator, ModelSortPredicateCreator } from '../predicates';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport { GraphQLScalarType, isGraphQLScalarType, isSchemaModelWithAttributes, AuthModeStrategyType, isNonModelFieldType, isModelFieldType, isIdentifierObject, isFieldAssociation } from '../types';\nimport { DATASTORE, errorMessages, establishRelationAndKeys, isModelConstructor, monotonicUlidFactory, STORAGE, SYNC, USER, isNullOrUndefined, registerNonModelClass, sortCompareFunction, DeferredCallbackResolver, inMemoryPagination, extractPrimaryKeyFieldNames, extractPrimaryKeysAndValues, isIdManaged, isIdOptionallyManaged, mergePatches } from '../util';\nimport { recursivePredicateFor, predicateFor, internals } from '../predicates/next';\nimport { getIdentifierValue } from '../sync/utils';\nsetAutoFreeze(true);\nenablePatches();\nvar logger = new Logger('DataStore');\nvar ulid = monotonicUlidFactory(Date.now());\nvar isNode = browserOrNode().isNode;\nvar SETTING_SCHEMA_VERSION = 'schemaVersion';\nvar schema;\nvar modelNamespaceMap = new WeakMap(); // stores data for crafting the correct update mutation input for a model\n// Patch[] - array of changed fields and metadata\n// PersistentModel - the source model, used for diffing object-type fields\n\nvar modelPatchesMap = new WeakMap();\n\nvar getModelDefinition = function (modelConstructor) {\n  var e_1, _a, e_2, _b;\n\n  var namespace = modelNamespaceMap.get(modelConstructor);\n  var definition = namespace ? schema.namespaces[namespace].models[modelConstructor.name] : undefined; // compatibility with legacy/pre-PK codegen for lazy loading to inject\n  // index fields into the model definition.\n\n  if (definition) {\n    var indexes = schema.namespaces[namespace].relationships[modelConstructor.name].indexes;\n    var indexFields = new Set();\n\n    try {\n      for (var indexes_1 = __values(indexes), indexes_1_1 = indexes_1.next(); !indexes_1_1.done; indexes_1_1 = indexes_1.next()) {\n        var index = indexes_1_1.value;\n\n        try {\n          for (var _c = (e_2 = void 0, __values(index[1])), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var indexField = _d.value;\n            indexFields.add(indexField);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (indexes_1_1 && !indexes_1_1.done && (_a = indexes_1.return)) _a.call(indexes_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    definition.fields = __assign(__assign({}, Object.fromEntries(__spread(indexFields.values()).map(function (name) {\n      return [name, {\n        name: name,\n        type: 'ID',\n        isArray: false\n      }];\n    }, []))), definition.fields);\n  }\n\n  return definition;\n};\n\nvar getModelPKFieldName = function (modelConstructor) {\n  var _a, _b, _c;\n\n  var namespace = modelNamespaceMap.get(modelConstructor);\n  return namespace && ((_c = (_b = (_a = schema.namespaces) === null || _a === void 0 ? void 0 : _a[namespace]) === null || _b === void 0 ? void 0 : _b.keys) === null || _c === void 0 ? void 0 : _c[modelConstructor.name].primaryKey) || ['id'];\n};\n\nvar isValidModelConstructor = function (obj) {\n  if (isModelConstructor(obj) && modelNamespaceMap.has(obj)) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nvar namespaceResolver = function (modelConstructor) {\n  var resolver = modelNamespaceMap.get(modelConstructor);\n\n  if (!resolver) {\n    throw new Error(\"Namespace Resolver for '\" + modelConstructor.name + \"' not found! This is probably a bug in '@amplify-js/datastore'.\");\n  }\n\n  return resolver;\n};\n\nvar buildSeedPredicate = function (modelConstructor) {\n  if (!modelConstructor) throw new Error('Missing modelConstructor');\n  var modelSchema = getModelDefinition(modelConstructor);\n  if (!modelSchema) throw new Error('Missing modelSchema');\n  var pks = getModelPKFieldName(modelConstructor);\n  if (!pks) throw new Error('Could not determine PK');\n  return recursivePredicateFor({\n    builder: modelConstructor,\n    schema: modelSchema,\n    pkField: pks\n  });\n}; // exporting syncClasses for testing outbox.test.ts\n\n\nexport var syncClasses;\nvar userClasses;\nvar dataStoreClasses;\nvar storageClasses;\n/**\n * Maps a model to its related models for memoization/immutability.\n */\n\nvar modelInstanceAssociationsMap = new WeakMap();\n/**\n * Describes whether and to what a model is attached for lazy loading purposes.\n */\n\nvar ModelAttachment;\n\n(function (ModelAttachment) {\n  /**\n   * Model doesn't lazy load from any data source.\n   *\n   * Related entity properties provided at instantiation are returned\n   * via the respective lazy interfaces when their properties are invoked.\n   */\n  ModelAttachment[\"Detached\"] = \"Detached\";\n  /**\n   * Model lazy loads from the global DataStore.\n   */\n\n  ModelAttachment[\"DataStore\"] = \"DataStore\";\n  /**\n   * Demonstrative. Not yet implemented.\n   */\n\n  ModelAttachment[\"API\"] = \"API\";\n})(ModelAttachment || (ModelAttachment = {}));\n/**\n * Tells us which data source a model is attached to (lazy loads from).\n *\n * If `Deatched`, the model's lazy properties will only ever return properties\n * from memory provided at construction time.\n */\n\n\nvar attachedModelInstances = new WeakMap();\n/**\n * Registers a model instance against a data source (DataStore, API, or\n * Detached/None).\n *\n * The API option is demonstrative. Lazy loading against API is not yet\n * implemented.\n *\n * @param result A model instance or array of instances\n * @param attachment A ModelAttachment data source\n * @returns passes the `result` back through after attachment\n */\n\nexport function attached(result, attachment) {\n  if (Array.isArray(result)) {\n    result.map(function (record) {\n      return attached(record, attachment);\n    });\n  } else {\n    result && attachedModelInstances.set(result, attachment);\n  }\n\n  return result;\n}\n/**\n * Determines what source a model instance should lazy load from.\n *\n * If the instace was never explicitly registered, it is detached by default.\n *\n * @param instance A model instance\n */\n\nexport var getAttachment = function (instance) {\n  return attachedModelInstances.has(instance) ? attachedModelInstances.get(instance) : ModelAttachment.Detached;\n};\n\nvar initSchema = function (userSchema) {\n  var _a;\n\n  if (schema !== undefined) {\n    console.warn('The schema has already been initialized');\n    return userClasses;\n  }\n\n  logger.log('validating schema', {\n    schema: userSchema\n  });\n  checkSchemaCodegenVersion(userSchema.codegenVersion);\n\n  var internalUserNamespace = __assign({\n    name: USER\n  }, userSchema);\n\n  logger.log('DataStore', 'Init models');\n  userClasses = createTypeClasses(internalUserNamespace);\n  logger.log('DataStore', 'Models initialized');\n  var dataStoreNamespace = getNamespace();\n  var storageNamespace = Storage.getNamespace();\n  var syncNamespace = SyncEngine.getNamespace();\n  dataStoreClasses = createTypeClasses(dataStoreNamespace);\n  storageClasses = createTypeClasses(storageNamespace);\n  syncClasses = createTypeClasses(syncNamespace);\n  schema = {\n    namespaces: (_a = {}, _a[dataStoreNamespace.name] = dataStoreNamespace, _a[internalUserNamespace.name] = internalUserNamespace, _a[storageNamespace.name] = storageNamespace, _a[syncNamespace.name] = syncNamespace, _a),\n    version: userSchema.version,\n    codegenVersion: userSchema.codegenVersion\n  };\n  Object.keys(schema.namespaces).forEach(function (namespace) {\n    var e_3, _a;\n\n    var _b = __read(establishRelationAndKeys(schema.namespaces[namespace]), 2),\n        relations = _b[0],\n        keys = _b[1];\n\n    schema.namespaces[namespace].relationships = relations;\n    schema.namespaces[namespace].keys = keys;\n    var modelAssociations = new Map();\n    Object.values(schema.namespaces[namespace].models).forEach(function (model) {\n      var connectedModels = [];\n      Object.values(model.fields).filter(function (field) {\n        return field.association && field.association.connectionType === 'BELONGS_TO' && field.type.model !== model.name;\n      }).forEach(function (field) {\n        return connectedModels.push(field.type.model);\n      });\n      modelAssociations.set(model.name, connectedModels);\n      Object.values(model.fields).forEach(function (field) {\n        if (typeof field.type === 'object' && !Object.getOwnPropertyDescriptor(field.type, 'modelConstructor')) {\n          Object.defineProperty(field.type, 'modelConstructor', {\n            get: function () {\n              return {\n                builder: userClasses[field.type.model],\n                schema: schema.namespaces[namespace].models[field.type.model],\n                pkField: getModelPKFieldName(userClasses[field.type.model])\n              };\n            }\n          });\n        }\n      });\n    });\n    var result = new Map();\n    var count = 1000;\n\n    while (true && count > 0) {\n      if (modelAssociations.size === 0) {\n        break;\n      }\n\n      count--;\n\n      if (count === 0) {\n        throw new Error('Models are not topologically sortable. Please verify your schema.');\n      }\n\n      try {\n        for (var _c = (e_3 = void 0, __values(Array.from(modelAssociations.keys()))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var modelName = _d.value;\n          var parents = modelAssociations.get(modelName);\n\n          if (parents === null || parents === void 0 ? void 0 : parents.every(function (x) {\n            return result.has(x);\n          })) {\n            result.set(modelName, parents);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      Array.from(result.keys()).forEach(function (x) {\n        return modelAssociations.delete(x);\n      });\n    }\n\n    schema.namespaces[namespace].modelTopologicalOrdering = result;\n  });\n  return userClasses;\n};\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\n\n\nvar checkSchemaInitialized = function () {\n  if (schema === undefined) {\n    var message = 'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n    logger.error(message);\n    throw new Error(message);\n  }\n};\n/**\n * Throws an exception if the schema is using a codegen version that is not supported.\n *\n * Set the supported version by setting majorVersion and minorVersion\n * This functions similar to ^ version range.\n * The tested codegenVersion major version must exactly match the set majorVersion\n * The tested codegenVersion minor version must be gt or equal to the set minorVersion\n * Example: For a min supported version of 5.4.0 set majorVersion = 5 and minorVersion = 4\n *\n * This regex will not work when setting a supported range with minor version\n * of 2 or more digits.\n * i.e. minorVersion = 10 will not work\n * The regex will work for testing a codegenVersion with multi digit minor\n * versions as long as the minimum minorVersion is single digit.\n * i.e. codegenVersion = 5.30.1, majorVersion = 5, minorVersion = 4 PASSES\n *\n * @param codegenVersion schema codegenVersion\n */\n\n\nvar checkSchemaCodegenVersion = function (codegenVersion) {\n  // TODO: set to correct version when released in codegen\n  var majorVersion = 3;\n  var minorVersion = 2;\n  var isValid = false;\n\n  try {\n    var versionParts = codegenVersion.split('.');\n\n    var _a = __read(versionParts, 4),\n        major = _a[0],\n        minor = _a[1],\n        patch = _a[2],\n        patchrevision = _a[3];\n\n    isValid = Number(major) === majorVersion && Number(minor) >= minorVersion;\n  } catch (err) {\n    console.log(\"Error parsing codegen version: \" + codegenVersion + \"\\n\" + err);\n  }\n\n  if (!isValid) {\n    var message = \"Models were generated with an unsupported version of codegen. Codegen artifacts are from \" + (codegenVersion || 'an unknown version') + \", whereas ^\" + majorVersion + \".\" + minorVersion + \".0 is required. \" + \"Update to the latest CLI and run 'amplify codegen models'.\";\n    logger.error(message);\n    throw new Error(message);\n  }\n};\n\nvar createTypeClasses = function (namespace) {\n  var classes = {};\n  Object.entries(namespace.models).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        modelName = _b[0],\n        modelDefinition = _b[1];\n\n    var clazz = createModelClass(modelDefinition);\n    classes[modelName] = clazz;\n    modelNamespaceMap.set(clazz, namespace.name);\n  });\n  Object.entries(namespace.nonModels || {}).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        typeName = _b[0],\n        typeDefinition = _b[1];\n\n    var clazz = createNonModelClass(typeDefinition);\n    classes[typeName] = clazz;\n  });\n  return classes;\n};\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\n\n\nvar instancesMetadata = new WeakSet();\n\nfunction modelInstanceCreator(modelConstructor, init) {\n  instancesMetadata.add(init);\n  return new modelConstructor(init);\n}\n\nvar validateModelFields = function (modelDefinition) {\n  return function (k, v) {\n    var fieldDefinition = modelDefinition.fields[k];\n\n    if (fieldDefinition !== undefined) {\n      var type_1 = fieldDefinition.type,\n          isRequired_1 = fieldDefinition.isRequired,\n          isArrayNullable = fieldDefinition.isArrayNullable,\n          name_1 = fieldDefinition.name,\n          isArray = fieldDefinition.isArray;\n\n      if ((!isArray && isRequired_1 || isArray && !isArrayNullable) && (v === null || v === undefined)) {\n        throw new Error(\"Field \" + name_1 + \" is required\");\n      }\n\n      if (isSchemaModelWithAttributes(modelDefinition) && !isIdManaged(modelDefinition)) {\n        var keys = extractPrimaryKeyFieldNames(modelDefinition);\n\n        if (keys.includes(k) && v === '') {\n          logger.error(errorMessages.idEmptyString, {\n            k: k,\n            value: v\n          });\n          throw new Error(errorMessages.idEmptyString);\n        }\n      }\n\n      if (isGraphQLScalarType(type_1)) {\n        var jsType_1 = GraphQLScalarType.getJSType(type_1);\n        var validateScalar_1 = GraphQLScalarType.getValidationFunction(type_1);\n\n        if (type_1 === 'AWSJSON') {\n          if (typeof v === jsType_1) {\n            return;\n          }\n\n          if (typeof v === 'string') {\n            try {\n              JSON.parse(v);\n              return;\n            } catch (error) {\n              throw new Error(\"Field \" + name_1 + \" is an invalid JSON object. \" + v);\n            }\n          }\n        }\n\n        if (isArray) {\n          var errorTypeText = jsType_1;\n\n          if (!isRequired_1) {\n            errorTypeText = jsType_1 + \" | null | undefined\";\n          }\n\n          if (!Array.isArray(v) && !isArrayNullable) {\n            throw new Error(\"Field \" + name_1 + \" should be of type [\" + errorTypeText + \"], \" + typeof v + \" received. \" + v);\n          }\n\n          if (!isNullOrUndefined(v) && v.some(function (e) {\n            return isNullOrUndefined(e) ? isRequired_1 : typeof e !== jsType_1;\n          })) {\n            var elemTypes = v.map(function (e) {\n              return e === null ? 'null' : typeof e;\n            }).join(',');\n            throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + errorTypeText + \", [\" + elemTypes + \"] received. \" + v);\n          }\n\n          if (validateScalar_1 && !isNullOrUndefined(v)) {\n            var validationStatus = v.map(function (e) {\n              if (!isNullOrUndefined(e)) {\n                return validateScalar_1(e);\n              } else if (isNullOrUndefined(e) && !isRequired_1) {\n                return true;\n              } else {\n                return false;\n              }\n            });\n\n            if (!validationStatus.every(function (s) {\n              return s;\n            })) {\n              throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + type_1 + \", validation failed for one or more elements. \" + v);\n            }\n          }\n        } else if (!isRequired_1 && v === undefined) {\n          return;\n        } else if (typeof v !== jsType_1 && v !== null) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + jsType_1 + \", \" + typeof v + \" received. \" + v);\n        } else if (!isNullOrUndefined(v) && validateScalar_1 && !validateScalar_1(v) // TODO: why never, TS ... why ...\n        ) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + type_1 + \", validation failed. \" + v);\n        }\n      } else if (isNonModelFieldType(type_1)) {\n        // do not check non model fields if undefined or null\n        if (!isNullOrUndefined(v)) {\n          var subNonModelDefinition_1 = schema.namespaces.user.nonModels[type_1.nonModel];\n          var modelValidator_1 = validateModelFields(subNonModelDefinition_1);\n\n          if (isArray) {\n            var errorTypeText = type_1.nonModel;\n\n            if (!isRequired_1) {\n              errorTypeText = type_1.nonModel + \" | null | undefined\";\n            }\n\n            if (!Array.isArray(v)) {\n              throw new Error(\"Field \" + name_1 + \" should be of type [\" + errorTypeText + \"], \" + typeof v + \" received. \" + v);\n            }\n\n            v.forEach(function (item) {\n              if (isNullOrUndefined(item) && isRequired_1 || typeof item !== 'object' && typeof item !== 'undefined') {\n                throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + type_1.nonModel + \", [\" + typeof item + \"] received. \" + item);\n              }\n\n              if (!isNullOrUndefined(item)) {\n                Object.keys(subNonModelDefinition_1.fields).forEach(function (subKey) {\n                  modelValidator_1(subKey, item[subKey]);\n                });\n              }\n            });\n          } else {\n            if (typeof v !== 'object') {\n              throw new Error(\"Field \" + name_1 + \" should be of type \" + type_1.nonModel + \", \" + typeof v + \" recieved. \" + v);\n            }\n\n            Object.keys(subNonModelDefinition_1.fields).forEach(function (subKey) {\n              modelValidator_1(subKey, v[subKey]);\n            });\n          }\n        }\n      }\n    }\n  };\n};\n\nvar castInstanceType = function (modelDefinition, k, v) {\n  var _a = modelDefinition.fields[k] || {},\n      isArray = _a.isArray,\n      type = _a.type; // attempt to parse stringified JSON\n\n\n  if (typeof v === 'string' && (isArray || type === 'AWSJSON' || isNonModelFieldType(type) || isModelFieldType(type))) {\n    try {\n      return JSON.parse(v);\n    } catch (_b) {// if JSON is invalid, don't throw and let modelValidator handle it\n    }\n  } // cast from numeric representation of boolean to JS boolean\n\n\n  if (typeof v === 'number' && type === 'Boolean') {\n    return Boolean(v);\n  }\n\n  return v;\n};\n\nvar initializeInstance = function (init, modelDefinition, draft) {\n  var modelValidator = validateModelFields(modelDefinition);\n  Object.entries(init).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        k = _b[0],\n        v = _b[1];\n\n    var parsedValue = castInstanceType(modelDefinition, k, v);\n    modelValidator(k, parsedValue);\n    draft[k] = parsedValue;\n  });\n};\n\nvar createModelClass = function (modelDefinition) {\n  var clazz =\n  /** @class */\n  function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, modelDefinition, draft); // model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n\n        var isInternallyInitialized = instancesMetadata.has(init);\n        var modelInstanceMetadata = isInternallyInitialized ? init : {};\n        var _id = modelInstanceMetadata.id;\n\n        if (isIdManaged(modelDefinition)) {\n          var isInternalModel = _id !== null && _id !== undefined;\n          var id = isInternalModel ? _id : modelDefinition.syncable ? uuid4() : ulid();\n          draft.id = id;\n        } else if (isIdOptionallyManaged(modelDefinition)) {\n          // only auto-populate if the id was not provided\n          draft.id = draft.id || uuid4();\n        }\n\n        if (!isInternallyInitialized) {\n          checkReadOnlyPropertyOnCreate(draft, modelDefinition);\n        }\n\n        var _version = modelInstanceMetadata._version,\n            _lastChangedAt = modelInstanceMetadata._lastChangedAt,\n            _deleted = modelInstanceMetadata._deleted;\n\n        if (modelDefinition.syncable) {\n          draft._version = _version;\n          draft._lastChangedAt = _lastChangedAt;\n          draft._deleted = _deleted;\n        }\n      });\n      return instance;\n    }\n\n    Model.copyOf = function (source, fn) {\n      var modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n\n      if (!isValidModelConstructor(modelConstructor)) {\n        var msg = 'The source object is not a valid model';\n        logger.error(msg, {\n          source: source\n        });\n        throw new Error(msg);\n      }\n\n      var patches;\n      var model = produce(source, function (draft) {\n        fn(draft);\n        var keyNames = extractPrimaryKeyFieldNames(modelDefinition); // Keys are immutable\n\n        keyNames.forEach(function (key) {\n          return draft[key] = source[key];\n        });\n        var modelValidator = validateModelFields(modelDefinition);\n        Object.entries(draft).forEach(function (_a) {\n          var _b = __read(_a, 2),\n              k = _b[0],\n              v = _b[1];\n\n          var parsedValue = castInstanceType(modelDefinition, k, v);\n          modelValidator(k, parsedValue);\n        });\n      }, function (p) {\n        return patches = p;\n      });\n      var hasExistingPatches = modelPatchesMap.has(source);\n\n      if (patches.length || hasExistingPatches) {\n        if (hasExistingPatches) {\n          var _a = __read(modelPatchesMap.get(source), 2),\n              existingPatches = _a[0],\n              existingSource = _a[1];\n\n          var mergedPatches = mergePatches(existingSource, existingPatches, patches);\n          modelPatchesMap.set(model, [mergedPatches, existingSource]);\n          checkReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n        } else {\n          modelPatchesMap.set(model, [patches, source]);\n          checkReadOnlyPropertyOnUpdate(patches, modelDefinition);\n        }\n      }\n\n      return attached(model, ModelAttachment.DataStore);\n    }; // \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n    // to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n\n\n    Model.fromJSON = function (json) {\n      var _this = this;\n\n      if (Array.isArray(json)) {\n        return json.map(function (init) {\n          return _this.fromJSON(init);\n        });\n      }\n\n      var instance = modelInstanceCreator(clazz, json);\n      var modelValidator = validateModelFields(modelDefinition);\n      Object.entries(instance).forEach(function (_a) {\n        var _b = __read(_a, 2),\n            k = _b[0],\n            v = _b[1];\n\n        modelValidator(k, v);\n      });\n      return attached(instance, ModelAttachment.DataStore);\n    };\n\n    return Model;\n  }();\n\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: modelDefinition.name\n  });\n\n  var _loop_1 = function (field) {\n    if (!isFieldAssociation(modelDefinition, field)) {\n      return \"continue\";\n    }\n\n    var _a = modelDefinition.fields[field],\n        type = _a.type,\n        localAssociation = _a.association,\n        _b = _a.association,\n        targetName = _b.targetName,\n        targetNames = _b.targetNames;\n    var relationship = new ModelRelationship({\n      builder: clazz,\n      schema: modelDefinition,\n      pkField: extractPrimaryKeyFieldNames(modelDefinition)\n    }, field);\n    Object.defineProperty(clazz.prototype, modelDefinition.fields[field].name, {\n      set: function (model) {\n        if (!model || !(typeof model === 'object')) return; // Avoid validation error when processing AppSync response with nested\n        // selection set. Nested entitites lack version field and can not be validated\n        // TODO: explore a more reliable method to solve this\n\n        if (model.hasOwnProperty('_version')) {\n          var modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n\n          if (!isValidModelConstructor(modelConstructor)) {\n            var msg = \"Value passed to \" + modelDefinition.name + \".\" + field + \" is not a valid instance of a model\";\n            logger.error(msg, {\n              model: model\n            });\n            throw new Error(msg);\n          }\n\n          if (modelConstructor.name.toLowerCase() !== relationship.remoteModelConstructor.name.toLowerCase()) {\n            var msg = \"Value passed to \" + modelDefinition.name + \".\" + field + \" is not an instance of \" + relationship.remoteModelConstructor.name;\n            logger.error(msg, {\n              model: model\n            });\n            throw new Error(msg);\n          }\n        }\n\n        if (relationship.isComplete) {\n          for (var i = 0; i < relationship.localJoinFields.length; i++) {\n            this[relationship.localJoinFields[i]] = model[relationship.remoteJoinFields[i]];\n          }\n\n          var instanceMemos = modelInstanceAssociationsMap.has(this) ? modelInstanceAssociationsMap.get(this) : modelInstanceAssociationsMap.set(this, {}).get(this);\n          instanceMemos[field] = model;\n        }\n      },\n      get: function () {\n        var _this = this;\n\n        var instanceMemos = modelInstanceAssociationsMap.has(this) ? modelInstanceAssociationsMap.get(this) : modelInstanceAssociationsMap.set(this, {}).get(this);\n\n        if (!instanceMemos.hasOwnProperty(field)) {\n          if (getAttachment(this) === ModelAttachment.DataStore) {\n            var resultPromise = instance.query(relationship.remoteModelConstructor, function (base) {\n              return base.and(function (q) {\n                return relationship.remoteJoinFields.map(function (field, index) {\n                  return q[field].eq(_this[relationship.localJoinFields[index]]);\n                });\n              });\n            });\n\n            if (relationship.type === 'HAS_MANY') {\n              instanceMemos[field] = new AsyncCollection(resultPromise);\n            } else {\n              instanceMemos[field] = resultPromise.then(function (rows) {\n                if (rows.length > 1) {\n                  // should never happen for a HAS_ONE or BELONGS_TO.\n                  var err = new Error(\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tData integrity error.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tToo many records found for a HAS_ONE/BELONGS_TO field '\" + modelDefinition.name + \".\" + field + \"'\\n\\t\\t\\t\\t\\t\\t\\t\\t\");\n                  console.error(err);\n                  throw err;\n                } else {\n                  return rows[0];\n                }\n              });\n            }\n          } else if (getAttachment(this) === ModelAttachment.API) {\n            throw new Error('Lazy loading from API is not yet supported!');\n          } else {\n            if (relationship.type === 'HAS_MANY') {\n              return new AsyncCollection([]);\n            } else {\n              return Promise.resolve(undefined);\n            }\n          }\n        }\n\n        return instanceMemos[field];\n      }\n    });\n  };\n\n  for (var field in modelDefinition.fields) {\n    _loop_1(field);\n  }\n\n  return clazz;\n};\n\nvar AsyncItem =\n/** @class */\nfunction (_super) {\n  __extends(AsyncItem, _super);\n\n  function AsyncItem() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return AsyncItem;\n}(Promise);\n\nexport { AsyncItem };\n\nvar AsyncCollection =\n/** @class */\nfunction () {\n  function AsyncCollection(values) {\n    this.values = values;\n  }\n\n  AsyncCollection.prototype[Symbol.asyncIterator] = function () {\n    var _this = this;\n\n    var values;\n    var index = 0;\n    return {\n      next: function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var result;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!!values) return [3\n                /*break*/\n                , 2];\n                return [4\n                /*yield*/\n                , this.values];\n\n              case 1:\n                values = _a.sent();\n                _a.label = 2;\n\n              case 2:\n                if (index < values.length) {\n                  result = {\n                    value: values[index],\n                    done: false\n                  };\n                  index++;\n                  return [2\n                  /*return*/\n                  , result];\n                }\n\n                return [2\n                /*return*/\n                , {\n                  value: null,\n                  done: true\n                }];\n            }\n          });\n        });\n      }\n    };\n  };\n\n  AsyncCollection.prototype.toArray = function (_a) {\n    var _b = (_a === void 0 ? {} : _a).max,\n        max = _b === void 0 ? Number.MAX_SAFE_INTEGER : _b;\n\n    var e_4, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var output, i, _d, _e, element, e_4_1;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            output = [];\n            i = 0;\n            _f.label = 1;\n\n          case 1:\n            _f.trys.push([1, 6, 7, 12]);\n\n            _d = __asyncValues(this);\n            _f.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , _d.next()];\n\n          case 3:\n            if (!(_e = _f.sent(), !_e.done)) return [3\n            /*break*/\n            , 5];\n            element = _e.value;\n\n            if (i < max) {\n              output.push(element);\n              i++;\n            } else {\n              return [3\n              /*break*/\n              , 5];\n            }\n\n            _f.label = 4;\n\n          case 4:\n            return [3\n            /*break*/\n            , 2];\n\n          case 5:\n            return [3\n            /*break*/\n            , 12];\n\n          case 6:\n            e_4_1 = _f.sent();\n            e_4 = {\n              error: e_4_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 7:\n            _f.trys.push([7,, 10, 11]);\n\n            if (!(_e && !_e.done && (_c = _d.return))) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , _c.call(_d)];\n\n          case 8:\n            _f.sent();\n\n            _f.label = 9;\n\n          case 9:\n            return [3\n            /*break*/\n            , 11];\n\n          case 10:\n            if (e_4) throw e_4.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 11:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            return [2\n            /*return*/\n            , output];\n        }\n      });\n    });\n  };\n\n  return AsyncCollection;\n}();\n\nexport { AsyncCollection };\n\nvar checkReadOnlyPropertyOnCreate = function (draft, modelDefinition) {\n  var modelKeys = Object.keys(draft);\n  var fields = modelDefinition.fields;\n  modelKeys.forEach(function (key) {\n    if (fields[key] && fields[key].isReadOnly) {\n      throw new Error(key + \" is read-only.\");\n    }\n  });\n};\n\nvar checkReadOnlyPropertyOnUpdate = function (patches, modelDefinition) {\n  var patchArray = patches.map(function (p) {\n    return [p.path[0], p.value];\n  });\n  var fields = modelDefinition.fields;\n  patchArray.forEach(function (_a) {\n    var _b = __read(_a, 2),\n        key = _b[0],\n        val = _b[1];\n\n    if (!val || !fields[key]) return;\n\n    if (fields[key].isReadOnly) {\n      throw new Error(key + \" is read-only.\");\n    }\n  });\n};\n\nvar createNonModelClass = function (typeDefinition) {\n  var clazz =\n  /** @class */\n  function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, typeDefinition, draft);\n      });\n      return instance;\n    }\n\n    return Model;\n  }();\n\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: typeDefinition.name\n  });\n  registerNonModelClass(clazz);\n  return clazz;\n};\n\nfunction isQueryOne(obj) {\n  return typeof obj === 'string';\n}\n\nfunction defaultConflictHandler(conflictData) {\n  var localModel = conflictData.localModel,\n      modelConstructor = conflictData.modelConstructor,\n      remoteModel = conflictData.remoteModel;\n  var _version = remoteModel._version;\n  return modelInstanceCreator(modelConstructor, __assign(__assign({}, localModel), {\n    _version: _version\n  }));\n}\n\nfunction defaultErrorHandler(error) {\n  logger.warn(error);\n}\n\nfunction getModelConstructorByModelName(namespaceName, modelName) {\n  var result;\n\n  switch (namespaceName) {\n    case DATASTORE:\n      result = dataStoreClasses[modelName];\n      break;\n\n    case USER:\n      result = userClasses[modelName];\n      break;\n\n    case SYNC:\n      result = syncClasses[modelName];\n      break;\n\n    case STORAGE:\n      result = storageClasses[modelName];\n      break;\n\n    default:\n      throw new Error(\"Invalid namespace: \" + namespaceName);\n  }\n\n  if (isValidModelConstructor(result)) {\n    return result;\n  } else {\n    var msg = \"Model name is not valid for namespace. modelName: \" + modelName + \", namespace: \" + namespaceName;\n    logger.error(msg);\n    throw new Error(msg);\n  }\n}\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\n\n\nfunction checkSchemaVersion(storage, version) {\n  return __awaiter(this, void 0, void 0, function () {\n    var Setting, modelDefinition;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          Setting = dataStoreClasses.Setting;\n          modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n          return [4\n          /*yield*/\n          , storage.runExclusive(function (s) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var _a, schemaVersionSetting, storedValue;\n\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , s.query(Setting, ModelPredicateCreator.createFromExisting(modelDefinition, function (c) {\n                      return c.key('eq', SETTING_SCHEMA_VERSION);\n                    }), {\n                      page: 0,\n                      limit: 1\n                    })];\n\n                  case 1:\n                    _a = __read.apply(void 0, [_b.sent(), 1]), schemaVersionSetting = _a[0];\n                    if (!(schemaVersionSetting !== undefined && schemaVersionSetting.value !== undefined)) return [3\n                    /*break*/\n                    , 4];\n                    storedValue = JSON.parse(schemaVersionSetting.value);\n                    if (!(storedValue !== version)) return [3\n                    /*break*/\n                    , 3];\n                    return [4\n                    /*yield*/\n                    , s.clear(false)];\n\n                  case 2:\n                    _b.sent();\n\n                    _b.label = 3;\n\n                  case 3:\n                    return [3\n                    /*break*/\n                    , 6];\n\n                  case 4:\n                    return [4\n                    /*yield*/\n                    , s.save(modelInstanceCreator(Setting, {\n                      key: SETTING_SCHEMA_VERSION,\n                      value: JSON.stringify(version)\n                    }))];\n\n                  case 5:\n                    _b.sent();\n\n                    _b.label = 6;\n\n                  case 6:\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          })];\n\n        case 1:\n          _a.sent();\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nvar syncSubscription;\n\nfunction getNamespace() {\n  var namespace = {\n    name: DATASTORE,\n    relationships: {},\n    enums: {},\n    nonModels: {},\n    models: {\n      Setting: {\n        name: 'Setting',\n        pluralName: 'Settings',\n        syncable: false,\n        fields: {\n          id: {\n            name: 'id',\n            type: 'ID',\n            isRequired: true,\n            isArray: false\n          },\n          key: {\n            name: 'key',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          },\n          value: {\n            name: 'value',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          }\n        }\n      }\n    }\n  };\n  return namespace;\n}\n\nvar DataStoreState;\n\n(function (DataStoreState) {\n  DataStoreState[\"NotRunning\"] = \"Not Running\";\n  DataStoreState[\"Starting\"] = \"Starting\";\n  DataStoreState[\"Running\"] = \"Running\";\n  DataStoreState[\"Stopping\"] = \"Stopping\";\n  DataStoreState[\"Clearing\"] = \"Clearing\";\n})(DataStoreState || (DataStoreState = {}));\n\nvar DataStore =\n/** @class */\nfunction () {\n  function DataStore() {\n    var _this = this; // reference to configured category instances. Used for preserving SSR context\n\n\n    this.Auth = Auth;\n    this.API = API;\n    this.Cache = Cache; // Non-null assertions (bang operator) have been added to most of these properties\n    // to make TS happy. These properties are all expected to be set immediately after\n    // construction.\n    // TODO: Refactor to use proper DI if possible. If not possible, change these to\n    // optionals and implement conditional checks throughout. Rinse/repeat on all\n    // sync engine processors, storage engine, adapters, etc..\n\n    this.amplifyConfig = {};\n    this.syncPredicates = new WeakMap(); // object that gets passed to descendent classes. Allows us to pass these down by reference\n\n    this.amplifyContext = {\n      Auth: this.Auth,\n      API: this.API,\n      Cache: this.Cache\n    };\n    /**\n     * **IMPORTANT!**\n     *\n     * Accumulator for background things that can **and MUST** be called when\n     * DataStore stops.\n     *\n     * These jobs **MUST** be *idempotent promises* that resolve ONLY\n     * once the intended jobs are completely finished and/or otherwise destroyed\n     * and cleaned up with ZERO outstanding:\n     *\n     * 1. side effects (e.g., state changes)\n     * 1. callbacks\n     * 1. subscriptions\n     * 1. calls to storage\n     * 1. *etc.*\n     *\n     * Methods that create pending promises, subscriptions, callbacks, or any\n     * type of side effect **MUST** be registered with the manager. And, a new\n     * manager must be created after each `exit()`.\n     *\n     * Failure to comply will put DataStore into a highly unpredictable state\n     * when it needs to stop or clear -- which occurs when restarting with new\n     * sync expressions, during testing, and potentially during app code\n     * recovery handling, etc..\n     *\n     * It is up to the discretion of each disposer whether to wait for job\n     * completion or to cancel operations and issue failures *as long as the\n     * disposer returns in a reasonable amount of time.*\n     *\n     * (Reasonable = *seconds*, not minutes.)\n     */\n\n    this.runningProcesses = new BackgroundProcessManager();\n    /**\n     * Indicates what state DataStore is in.\n     *\n     * Not [yet?] used for actual state management; but for messaging\n     * when errors occur, to help troubleshoot.\n     */\n\n    this.state = DataStoreState.NotRunning;\n    /**\n     * If not already done:\n     * 1. Attaches and initializes storage.\n     * 1. Loads the schema and records metadata.\n     * 1. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n     * attaches a sync engine, starts it, and subscribes.\n     */\n\n    this.start = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var aws_appsync_graphqlEndpoint, _a, fullSyncIntervalInMilliseconds;\n\n              var _this = this;\n\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    this.state = DataStoreState.Starting;\n                    if (!(this.initialized === undefined)) return [3\n                    /*break*/\n                    , 1];\n                    logger.debug('Starting DataStore');\n                    this.initialized = new Promise(function (res, rej) {\n                      _this.initResolve = res;\n                      _this.initReject = rej;\n                    });\n                    return [3\n                    /*break*/\n                    , 3];\n\n                  case 1:\n                    return [4\n                    /*yield*/\n                    , this.initialized];\n\n                  case 2:\n                    _b.sent();\n\n                    return [2\n                    /*return*/\n                    ];\n\n                  case 3:\n                    this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n                    return [4\n                    /*yield*/\n                    , this.storage.init()];\n\n                  case 4:\n                    _b.sent();\n\n                    checkSchemaInitialized();\n                    return [4\n                    /*yield*/\n                    , checkSchemaVersion(this.storage, schema.version)];\n\n                  case 5:\n                    _b.sent();\n\n                    aws_appsync_graphqlEndpoint = this.amplifyConfig.aws_appsync_graphqlEndpoint;\n                    if (!aws_appsync_graphqlEndpoint) return [3\n                    /*break*/\n                    , 7];\n                    logger.debug('GraphQL endpoint available', aws_appsync_graphqlEndpoint);\n                    _a = this;\n                    return [4\n                    /*yield*/\n                    , this.processSyncExpressions()];\n\n                  case 6:\n                    _a.syncPredicates = _b.sent();\n                    this.sync = new SyncEngine(schema, namespaceResolver, syncClasses, userClasses, this.storage, modelInstanceCreator, this.conflictHandler, this.errorHandler, this.syncPredicates, this.amplifyConfig, this.authModeStrategy, this.amplifyContext, this.connectivityMonitor);\n                    fullSyncIntervalInMilliseconds = this.fullSyncInterval * 1000 * 60;\n                    syncSubscription = this.sync.start({\n                      fullSyncInterval: fullSyncIntervalInMilliseconds\n                    }).subscribe({\n                      next: function (_a) {\n                        var type = _a.type,\n                            data = _a.data; // In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n                        // In the Browser, we can begin returning data once subscriptions are in place.\n\n                        var readyType = isNode ? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY : ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n\n                        if (type === readyType) {\n                          _this.initResolve();\n                        }\n\n                        Hub.dispatch('datastore', {\n                          event: type,\n                          data: data\n                        });\n                      },\n                      error: function (err) {\n                        logger.warn('Sync error', err);\n\n                        _this.initReject();\n                      }\n                    });\n                    return [3\n                    /*break*/\n                    , 8];\n\n                  case 7:\n                    logger.warn(\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\", {\n                      config: this.amplifyConfig\n                    });\n                    this.initResolve();\n                    _b.label = 8;\n\n                  case 8:\n                    return [4\n                    /*yield*/\n                    , this.initialized];\n\n                  case 9:\n                    _b.sent();\n\n                    this.state = DataStoreState.Running;\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }, 'datastore start').catch(this.handleAddProcError('DataStore.start()'))];\n        });\n      });\n    };\n\n    this.query = function (modelConstructor, identifierOrCriteria, paginationProducer) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var result, msg, modelDefinition, pagination, keyFields, msg, predicate, predicate, seedPredicate, predicate, returnOne;\n\n              var _a;\n\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , this.start()];\n\n                  case 1:\n                    _b.sent();\n\n                    if (!this.storage) {\n                      throw new Error('No storage to query');\n                    } //#region Input validation\n\n\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Constructor is not for a valid model';\n                      logger.error(msg, {\n                        modelConstructor: modelConstructor\n                      });\n                      throw new Error(msg);\n                    }\n\n                    if (typeof identifierOrCriteria === 'string') {\n                      if (paginationProducer !== undefined) {\n                        logger.warn('Pagination is ignored when querying by id');\n                      }\n                    }\n\n                    modelDefinition = getModelDefinition(modelConstructor);\n\n                    if (!modelDefinition) {\n                      throw new Error('Invalid model definition provided!');\n                    }\n\n                    pagination = this.processPagination(modelDefinition, paginationProducer);\n                    keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                    if (!isQueryOne(identifierOrCriteria)) return [3\n                    /*break*/\n                    , 3];\n\n                    if (keyFields.length > 1) {\n                      msg = errorMessages.queryByPkWithCompositeKeyPresent;\n                      logger.error(msg, {\n                        keyFields: keyFields\n                      });\n                      throw new Error(msg);\n                    }\n\n                    predicate = ModelPredicateCreator.createForSingleField(modelDefinition, keyFields[0], identifierOrCriteria);\n                    return [4\n                    /*yield*/\n                    , this.storage.query(modelConstructor, predicate, pagination)];\n\n                  case 2:\n                    result = _b.sent();\n                    return [3\n                    /*break*/\n                    , 9];\n\n                  case 3:\n                    if (!isIdentifierObject(identifierOrCriteria, modelDefinition)) return [3\n                    /*break*/\n                    , 5];\n                    predicate = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                    return [4\n                    /*yield*/\n                    , this.storage.query(modelConstructor, predicate, pagination)];\n\n                  case 4:\n                    result = _b.sent();\n                    return [3\n                    /*break*/\n                    , 9];\n\n                  case 5:\n                    if (!(!identifierOrCriteria || isPredicatesAll(identifierOrCriteria))) return [3\n                    /*break*/\n                    , 7];\n                    return [4\n                    /*yield*/\n                    , (_a = this.storage) === null || _a === void 0 ? void 0 : _a.query(modelConstructor, undefined, pagination)];\n\n                  case 6:\n                    result = _b.sent();\n                    return [3\n                    /*break*/\n                    , 9];\n\n                  case 7:\n                    seedPredicate = recursivePredicateFor({\n                      builder: modelConstructor,\n                      schema: modelDefinition,\n                      pkField: getModelPKFieldName(modelConstructor)\n                    });\n                    predicate = internals(identifierOrCriteria(seedPredicate));\n                    return [4\n                    /*yield*/\n                    , predicate.fetch(this.storage)];\n\n                  case 8:\n                    result = _b.sent();\n                    result = inMemoryPagination(result, pagination);\n                    _b.label = 9;\n\n                  case 9:\n                    returnOne = isQueryOne(identifierOrCriteria) || isIdentifierObject(identifierOrCriteria, modelDefinition);\n                    return [2\n                    /*return*/\n                    , attached(returnOne ? result[0] : result, ModelAttachment.DataStore)];\n                }\n              });\n            });\n          }, 'datastore query').catch(this.handleAddProcError('DataStore.query()'))];\n        });\n      });\n    };\n\n    this.save = function (model, condition) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var patchesTuple, modelConstructor, msg, modelDefinition, modelMeta, producedCondition, _a, savedModel;\n\n              var _this = this;\n\n              return __generator(this, function (_b) {\n                switch (_b.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , this.start()];\n\n                  case 1:\n                    _b.sent();\n\n                    if (!this.storage) {\n                      throw new Error('No storage to save to');\n                    }\n\n                    patchesTuple = modelPatchesMap.get(model);\n                    modelConstructor = model ? model.constructor : undefined;\n\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Object is not an instance of a valid model';\n                      logger.error(msg, {\n                        model: model\n                      });\n                      throw new Error(msg);\n                    }\n\n                    modelDefinition = getModelDefinition(modelConstructor);\n\n                    if (!modelDefinition) {\n                      throw new Error('Model Definition could not be found for model');\n                    }\n\n                    modelMeta = {\n                      builder: modelConstructor,\n                      schema: modelDefinition,\n                      pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                    };\n                    return [4\n                    /*yield*/\n                    , this.storage.runExclusive(function (s) {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        var nonHasManyRelationships, nonHasManyRelationships_1, nonHasManyRelationships_1_1, relationship, queryObject, related, e_5_1;\n\n                        var e_5, _a;\n\n                        var _b;\n\n                        return __generator(this, function (_c) {\n                          switch (_c.label) {\n                            case 0:\n                              nonHasManyRelationships = ModelRelationship.allFrom(modelMeta).filter(function (r) {\n                                return r.type === 'BELONGS_TO';\n                              });\n                              _c.label = 1;\n\n                            case 1:\n                              _c.trys.push([1, 6, 7, 8]);\n\n                              nonHasManyRelationships_1 = __values(nonHasManyRelationships), nonHasManyRelationships_1_1 = nonHasManyRelationships_1.next();\n                              _c.label = 2;\n\n                            case 2:\n                              if (!!nonHasManyRelationships_1_1.done) return [3\n                              /*break*/\n                              , 5];\n                              relationship = nonHasManyRelationships_1_1.value;\n                              queryObject = relationship.createRemoteQueryObject(model);\n                              if (!(queryObject !== null)) return [3\n                              /*break*/\n                              , 4];\n                              return [4\n                              /*yield*/\n                              , s.query(relationship.remoteModelConstructor, ModelPredicateCreator.createFromFlatEqualities(relationship.remoteDefinition, queryObject))];\n\n                            case 3:\n                              related = _c.sent();\n\n                              if (related.length === 0) {\n                                throw new Error([\"Data integrity error. You tried to save a \" + modelDefinition.name + \" (\" + JSON.stringify(model) + \")\", \"but the instance assigned to the \\\"\" + relationship.field + \"\\\" property\", \"does not exist in the local database. If you're trying to create the related\", \"\\\"\" + ((_b = relationship.remoteDefinition) === null || _b === void 0 ? void 0 : _b.name) + \"\\\", you must save it independently first.\"].join(' '));\n                              }\n\n                              _c.label = 4;\n\n                            case 4:\n                              nonHasManyRelationships_1_1 = nonHasManyRelationships_1.next();\n                              return [3\n                              /*break*/\n                              , 2];\n\n                            case 5:\n                              return [3\n                              /*break*/\n                              , 8];\n\n                            case 6:\n                              e_5_1 = _c.sent();\n                              e_5 = {\n                                error: e_5_1\n                              };\n                              return [3\n                              /*break*/\n                              , 8];\n\n                            case 7:\n                              try {\n                                if (nonHasManyRelationships_1_1 && !nonHasManyRelationships_1_1.done && (_a = nonHasManyRelationships_1.return)) _a.call(nonHasManyRelationships_1);\n                              } finally {\n                                if (e_5) throw e_5.error;\n                              }\n\n                              return [7\n                              /*endfinally*/\n                              ];\n\n                            case 8:\n                              return [2\n                              /*return*/\n                              ];\n                          }\n                        });\n                      });\n                    })];\n\n                  case 2:\n                    _b.sent();\n\n                    producedCondition = condition ? internals(condition(predicateFor(modelMeta))).toStoragePredicate() : undefined;\n                    return [4\n                    /*yield*/\n                    , this.storage.runExclusive(function (s) {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        var saved;\n                        return __generator(this, function (_a) {\n                          switch (_a.label) {\n                            case 0:\n                              return [4\n                              /*yield*/\n                              , s.save(model, producedCondition, undefined, patchesTuple)];\n\n                            case 1:\n                              saved = _a.sent();\n                              return [2\n                              /*return*/\n                              , s.query(modelConstructor, ModelPredicateCreator.createForPk(modelDefinition, model))];\n                          }\n                        });\n                      });\n                    })];\n\n                  case 3:\n                    _a = __read.apply(void 0, [_b.sent(), 1]), savedModel = _a[0];\n                    return [2\n                    /*return*/\n                    , attached(savedModel, ModelAttachment.DataStore)];\n                }\n              });\n            });\n          }, 'datastore save').catch(this.handleAddProcError('DataStore.save()'))];\n        });\n      });\n    };\n\n    this.setConflictHandler = function (config) {\n      var configDataStore = config.DataStore;\n\n      var conflictHandlerIsDefault = function () {\n        return _this.conflictHandler === defaultConflictHandler;\n      };\n\n      if (configDataStore && configDataStore.conflictHandler) {\n        return configDataStore.conflictHandler;\n      }\n\n      if (conflictHandlerIsDefault() && config.conflictHandler) {\n        return config.conflictHandler;\n      }\n\n      return _this.conflictHandler || defaultConflictHandler;\n    };\n\n    this.setErrorHandler = function (config) {\n      var configDataStore = config.DataStore;\n\n      var errorHandlerIsDefault = function () {\n        return _this.errorHandler === defaultErrorHandler;\n      };\n\n      if (configDataStore && configDataStore.errorHandler) {\n        return configDataStore.errorHandler;\n      }\n\n      if (errorHandlerIsDefault() && config.errorHandler) {\n        return config.errorHandler;\n      }\n\n      return _this.errorHandler || defaultErrorHandler;\n    };\n\n    this.delete = function (modelOrConstructor, identifierOrCriteria) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          return [2\n          /*return*/\n          , this.runningProcesses.add(function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var condition, msg, modelConstructor, msg, modelDefinition, keyFields, msg, msg, _a, deleted, model, modelConstructor, msg, modelDefinition, pkPredicate, msg, _b, _c, deleted;\n\n              return __generator(this, function (_d) {\n                switch (_d.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , this.start()];\n\n                  case 1:\n                    _d.sent();\n\n                    if (!this.storage) {\n                      throw new Error('No storage to delete from');\n                    }\n\n                    if (!modelOrConstructor) {\n                      msg = 'Model or Model Constructor required';\n                      logger.error(msg, {\n                        modelOrConstructor: modelOrConstructor\n                      });\n                      throw new Error(msg);\n                    }\n\n                    if (!isValidModelConstructor(modelOrConstructor)) return [3\n                    /*break*/\n                    , 3];\n                    modelConstructor = modelOrConstructor;\n\n                    if (!identifierOrCriteria) {\n                      msg = 'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n                      logger.error(msg, {\n                        identifierOrCriteria: identifierOrCriteria\n                      });\n                      throw new Error(msg);\n                    }\n\n                    modelDefinition = getModelDefinition(modelConstructor);\n\n                    if (!modelDefinition) {\n                      throw new Error('Could not find model definition for modelConstructor.');\n                    }\n\n                    if (typeof identifierOrCriteria === 'string') {\n                      keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n                      if (keyFields.length > 1) {\n                        msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n                        logger.error(msg, {\n                          keyFields: keyFields\n                        });\n                        throw new Error(msg);\n                      }\n\n                      condition = ModelPredicateCreator.createForSingleField(modelDefinition, keyFields[0], identifierOrCriteria);\n                    } else {\n                      if (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n                        condition = ModelPredicateCreator.createForPk(modelDefinition, identifierOrCriteria);\n                      } else {\n                        condition = internals(identifierOrCriteria(predicateFor({\n                          builder: modelConstructor,\n                          schema: modelDefinition,\n                          pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                        }))).toStoragePredicate();\n                      }\n\n                      if (!condition || !ModelPredicateCreator.isValidPredicate(condition)) {\n                        msg = 'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n                        logger.error(msg, {\n                          condition: condition\n                        });\n                        throw new Error(msg);\n                      }\n                    }\n\n                    return [4\n                    /*yield*/\n                    , this.storage.delete(modelConstructor, condition)];\n\n                  case 2:\n                    _a = __read.apply(void 0, [_d.sent(), 1]), deleted = _a[0];\n                    return [2\n                    /*return*/\n                    , attached(deleted, ModelAttachment.DataStore)];\n\n                  case 3:\n                    model = modelOrConstructor;\n                    modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n\n                    if (!isValidModelConstructor(modelConstructor)) {\n                      msg = 'Object is not an instance of a valid model';\n                      logger.error(msg, {\n                        model: model\n                      });\n                      throw new Error(msg);\n                    }\n\n                    modelDefinition = getModelDefinition(modelConstructor);\n\n                    if (!modelDefinition) {\n                      throw new Error('Could not find model definition for modelConstructor.');\n                    }\n\n                    pkPredicate = ModelPredicateCreator.createForPk(modelDefinition, model);\n\n                    if (identifierOrCriteria) {\n                      if (typeof identifierOrCriteria !== 'function') {\n                        msg = 'Invalid criteria';\n                        logger.error(msg, {\n                          identifierOrCriteria: identifierOrCriteria\n                        });\n                        throw new Error(msg);\n                      }\n\n                      condition = internals(identifierOrCriteria(predicateFor({\n                        builder: modelConstructor,\n                        schema: modelDefinition,\n                        pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                      }))).toStoragePredicate(pkPredicate);\n                    } else {\n                      condition = pkPredicate;\n                    }\n\n                    return [4\n                    /*yield*/\n                    , this.storage.delete(model, condition)];\n\n                  case 4:\n                    _b = __read.apply(void 0, [_d.sent(), 1]), _c = __read(_b[0], 1), deleted = _c[0];\n                    return [2\n                    /*return*/\n                    , attached(deleted, ModelAttachment.DataStore)];\n                }\n              });\n            });\n          }, 'datastore delete').catch(this.handleAddProcError('DataStore.delete()'))];\n        });\n      });\n    };\n\n    this.observe = function (modelOrConstructor, identifierOrCriteria) {\n      var executivePredicate;\n      var modelConstructor = modelOrConstructor && isValidModelConstructor(modelOrConstructor) ? modelOrConstructor : undefined;\n\n      if (modelOrConstructor && modelConstructor === undefined) {\n        var model = modelOrConstructor;\n        var modelConstructor_1 = model && Object.getPrototypeOf(model).constructor;\n\n        if (isValidModelConstructor(modelConstructor_1)) {\n          if (identifierOrCriteria) {\n            logger.warn('idOrCriteria is ignored when using a model instance', {\n              model: model,\n              identifierOrCriteria: identifierOrCriteria\n            });\n          }\n\n          return _this.observe(modelConstructor_1, model.id);\n        } else {\n          var msg = 'The model is not an instance of a PersistentModelConstructor';\n          logger.error(msg, {\n            model: model\n          });\n          throw new Error(msg);\n        }\n      } // observe should not accept object literal syntax\n\n\n      if (identifierOrCriteria && modelConstructor && isIdentifierObject(identifierOrCriteria, getModelDefinition(modelConstructor))) {\n        var msg = errorMessages.observeWithObjectLiteral;\n        logger.error(msg, {\n          objectLiteral: identifierOrCriteria\n        });\n        throw new Error(msg);\n      }\n\n      if (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n        var msg = 'Cannot provide criteria without a modelConstructor';\n        logger.error(msg, identifierOrCriteria);\n        throw new Error(msg);\n      }\n\n      if (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n        var msg = 'Constructor is not for a valid model';\n        logger.error(msg, {\n          modelConstructor: modelConstructor\n        });\n        throw new Error(msg);\n      }\n\n      if (modelConstructor && typeof identifierOrCriteria === 'string') {\n        var buildIdPredicate = function (seed) {\n          return seed.id.eq(identifierOrCriteria);\n        };\n\n        executivePredicate = internals(buildIdPredicate(buildSeedPredicate(modelConstructor)));\n      } else if (modelConstructor && typeof identifierOrCriteria === 'function') {\n        executivePredicate = internals(identifierOrCriteria(buildSeedPredicate(modelConstructor)));\n      }\n\n      return new Observable(function (observer) {\n        var source;\n\n        _this.runningProcesses.add(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var _this = this;\n\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4\n                  /*yield*/\n                  , this.start()];\n\n                case 1:\n                  _a.sent(); // Filter the events returned by Storage according to namespace,\n                  // append original element data, and subscribe to the observable\n\n\n                  source = this.storage.observe(modelConstructor).filter(function (_a) {\n                    var model = _a.model;\n                    return namespaceResolver(model) === USER;\n                  }).subscribe({\n                    next: function (item) {\n                      return _this.runningProcesses.isOpen && _this.runningProcesses.add(function () {\n                        return __awaiter(_this, void 0, void 0, function () {\n                          var message, modelDefinition, keyFields, primaryKeysAndValues, freshElement, _a;\n\n                          return __generator(this, function (_b) {\n                            switch (_b.label) {\n                              case 0:\n                                message = item;\n                                if (!(item.opType !== 'DELETE')) return [3\n                                /*break*/\n                                , 2];\n                                modelDefinition = getModelDefinition(item.model);\n                                keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n                                primaryKeysAndValues = extractPrimaryKeysAndValues(item.element, keyFields);\n                                return [4\n                                /*yield*/\n                                , this.query(item.model, primaryKeysAndValues)];\n\n                              case 1:\n                                freshElement = _b.sent();\n                                message = __assign(__assign({}, message), {\n                                  element: freshElement\n                                });\n                                _b.label = 2;\n\n                              case 2:\n                                _a = !executivePredicate;\n                                if (_a) return [3\n                                /*break*/\n                                , 4];\n                                return [4\n                                /*yield*/\n                                , executivePredicate.matches(message.element)];\n\n                              case 3:\n                                _a = _b.sent();\n                                _b.label = 4;\n\n                              case 4:\n                                if (_a) {\n                                  observer.next(message);\n                                }\n\n                                return [2\n                                /*return*/\n                                ];\n                            }\n                          });\n                        });\n                      }, 'datastore observe message handler');\n                    },\n                    error: function (err) {\n                      return observer.error(err);\n                    },\n                    complete: function () {\n                      return observer.complete();\n                    }\n                  });\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        }, 'datastore observe observable initialization').catch(_this.handleAddProcError('DataStore.observe()')).catch(function (error) {\n          observer.error(error);\n        }); // better than no cleaner, but if the subscriber is handling the\n        // complete() message async and not registering with the context,\n        // this will still be problematic.\n\n\n        return _this.runningProcesses.addCleaner(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              if (source) {\n                source.unsubscribe();\n              }\n\n              return [2\n              /*return*/\n              ];\n            });\n          });\n        }, 'DataStore.observe() cleanup');\n      });\n    };\n\n    this.observeQuery = function (model, criteria, options) {\n      return new Observable(function (observer) {\n        var items = new Map();\n        var itemsChanged = new Map();\n        var deletedItemIds = [];\n        var handle; // let predicate: ModelPredicate<T> | undefined;\n\n        var executivePredicate;\n        /**\n         * As the name suggests, this geneates a snapshot in the form of\n         * \t`{items: T[], isSynced: boolean}`\n         * and sends it to the observer.\n         *\n         * SIDE EFFECT: The underlying generation and emission methods may touch:\n         * `items`, `itemsChanged`, and `deletedItemIds`.\n         *\n         * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n         */\n\n        var generateAndEmitSnapshot = function () {\n          var snapshot = generateSnapshot();\n          emitSnapshot(snapshot);\n        }; // a mechanism to return data after X amount of seconds OR after the\n        // \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n\n\n        var limitTimerRace = new DeferredCallbackResolver({\n          callback: generateAndEmitSnapshot,\n          errorHandler: observer.error,\n          maxInterval: 2000\n        });\n        var sort = (options || {}).sort;\n        var sortOptions = sort ? {\n          sort: sort\n        } : undefined;\n        var modelDefinition = getModelDefinition(model);\n\n        if (!modelDefinition) {\n          throw new Error('Could not find model definition.');\n        }\n\n        if (model && typeof criteria === 'function') {\n          executivePredicate = internals(criteria(buildSeedPredicate(model)));\n        } else if (isPredicatesAll(criteria)) {\n          executivePredicate = undefined;\n        }\n\n        _this.runningProcesses.add(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var err_1;\n\n            var _this = this;\n\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  _a.trys.push([0, 2,, 3]);\n\n                  return [4\n                  /*yield*/\n                  , this.query(model, criteria, sortOptions)];\n\n                case 1:\n                  // first, query and return any locally-available records\n                  _a.sent().forEach(function (item) {\n                    var itemModelDefinition = getModelDefinition(model);\n                    var idOrPk = getIdentifierValue(itemModelDefinition, item);\n                    items.set(idOrPk, item);\n                  }); // Observe the model and send a stream of updates (debounced).\n                  // We need to post-filter results instead of passing criteria through\n                  // to have visibility into items that move from in-set to out-of-set.\n                  // We need to explicitly remove those items from the existing snapshot.\n\n\n                  handle = this.observe(model).subscribe(function (_a) {\n                    var element = _a.element,\n                        model = _a.model,\n                        opType = _a.opType;\n                    return _this.runningProcesses.isOpen && _this.runningProcesses.add(function () {\n                      return __awaiter(_this, void 0, void 0, function () {\n                        var itemModelDefinition, idOrPk, _a, isSynced, limit;\n\n                        var _b, _c;\n\n                        return __generator(this, function (_d) {\n                          switch (_d.label) {\n                            case 0:\n                              itemModelDefinition = getModelDefinition(model);\n                              idOrPk = getIdentifierValue(itemModelDefinition, element);\n                              _a = executivePredicate;\n                              if (!_a) return [3\n                              /*break*/\n                              , 2];\n                              return [4\n                              /*yield*/\n                              , executivePredicate.matches(element)];\n\n                            case 1:\n                              _a = !_d.sent();\n                              _d.label = 2;\n\n                            case 2:\n                              if (_a) {\n                                if (opType === 'UPDATE' && (items.has(idOrPk) || itemsChanged.has(idOrPk))) {\n                                  // tracking as a \"deleted item\" will include the item in\n                                  // page limit calculations and ensure it is removed from the\n                                  // final items collection, regardless of which collection(s)\n                                  // it is currently in. (I mean, it could be in both, right!?)\n                                  deletedItemIds.push(idOrPk);\n                                } else {\n                                  // ignore updates for irrelevant/filtered items.\n                                  return [2\n                                  /*return*/\n                                  ];\n                                }\n                              } // Flag items which have been recently deleted\n                              // NOTE: Merging of separate operations to the same model instance is handled upstream\n                              // in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n                              // depends on the LATEST record (for a given id).\n\n\n                              if (opType === 'DELETE') {\n                                deletedItemIds.push(idOrPk);\n                              } else {\n                                itemsChanged.set(idOrPk, element);\n                              }\n\n                              isSynced = (_c = (_b = this.sync) === null || _b === void 0 ? void 0 : _b.getModelSyncedStatus(model)) !== null && _c !== void 0 ? _c : false;\n                              limit = itemsChanged.size - deletedItemIds.length >= this.syncPageSize;\n\n                              if (limit || isSynced) {\n                                limitTimerRace.resolve();\n                              } // kicks off every subsequent race as results sync down\n\n\n                              limitTimerRace.start();\n                              return [2\n                              /*return*/\n                              ];\n                          }\n                        });\n                      });\n                    }, 'handle observeQuery observed event');\n                  }); // returns a set of initial/locally-available results\n\n                  generateAndEmitSnapshot();\n                  return [3\n                  /*break*/\n                  , 3];\n\n                case 2:\n                  err_1 = _a.sent();\n                  observer.error(err_1);\n                  return [3\n                  /*break*/\n                  , 3];\n\n                case 3:\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        }, 'datastore observequery startup').catch(_this.handleAddProcError('DataStore.observeQuery()')).catch(function (error) {\n          observer.error(error);\n        });\n        /**\n         * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n         * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n         *\n         * SIDE EFFECT: The shared `items` collection is recreated.\n         */\n\n\n        var generateSnapshot = function () {\n          var _a, _b;\n\n          var isSynced = (_b = (_a = _this.sync) === null || _a === void 0 ? void 0 : _a.getModelSyncedStatus(model)) !== null && _b !== void 0 ? _b : false;\n\n          var itemsArray = __spread(Array.from(items.values()), Array.from(itemsChanged.values()));\n\n          if (options === null || options === void 0 ? void 0 : options.sort) {\n            sortItems(itemsArray);\n          }\n\n          items.clear();\n          itemsArray.forEach(function (item) {\n            var itemModelDefinition = getModelDefinition(model);\n            var idOrPk = getIdentifierValue(itemModelDefinition, item);\n            items.set(idOrPk, item);\n          }); // remove deleted items from the final result set\n\n          deletedItemIds.forEach(function (idOrPk) {\n            return items.delete(idOrPk);\n          });\n          return {\n            items: Array.from(items.values()),\n            isSynced: isSynced\n          };\n        };\n        /**\n         * Emits the list of items to the observer.\n         *\n         * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n         * for the next snapshot.\n         *\n         * @param snapshot The generated items data to emit.\n         */\n\n\n        var emitSnapshot = function (snapshot) {\n          // send the generated snapshot to the primary subscription.\n          // NOTE: This observer's handler *could* be async ...\n          observer.next(snapshot); // reset the changed items sets\n\n          itemsChanged.clear();\n          deletedItemIds = [];\n        };\n        /**\n         * Sorts an `Array` of `T` according to the sort instructions given in the\n         * original  `observeQuery()` call.\n         *\n         * @param itemsToSort A array of model type.\n         */\n\n\n        var sortItems = function (itemsToSort) {\n          var modelDefinition = getModelDefinition(model);\n\n          var pagination = _this.processPagination(modelDefinition, options);\n\n          var sortPredicates = ModelSortPredicateCreator.getPredicates(pagination.sort);\n\n          if (sortPredicates.length) {\n            var compareFn = sortCompareFunction(sortPredicates);\n            itemsToSort.sort(compareFn);\n          }\n        };\n        /**\n         * Force one last snapshot when the model is fully synced.\n         *\n         * This reduces latency for that last snapshot, which will otherwise\n         * wait for the configured timeout.\n         *\n         * @param payload The payload from the Hub event.\n         */\n\n\n        var hubCallback = function (_a) {\n          var payload = _a.payload;\n\n          var _b;\n\n          var event = payload.event,\n              data = payload.data;\n\n          if (event === ControlMessage.SYNC_ENGINE_MODEL_SYNCED && ((_b = data === null || data === void 0 ? void 0 : data.model) === null || _b === void 0 ? void 0 : _b.name) === model.name) {\n            generateAndEmitSnapshot();\n            Hub.remove('datastore', hubCallback);\n          }\n        };\n\n        Hub.listen('datastore', hubCallback);\n        return _this.runningProcesses.addCleaner(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n              if (handle) {\n                handle.unsubscribe();\n              }\n\n              return [2\n              /*return*/\n              ];\n            });\n          });\n        }, 'datastore observequery cleaner');\n      });\n    };\n\n    this.configure = function (config) {\n      if (config === void 0) {\n        config = {};\n      }\n\n      _this.amplifyContext.Auth = _this.Auth;\n      _this.amplifyContext.API = _this.API;\n      _this.amplifyContext.Cache = _this.Cache;\n\n      var configDataStore = config.DataStore,\n          configAuthModeStrategyType = config.authModeStrategyType,\n          configConflictHandler = config.conflictHandler,\n          configErrorHandler = config.errorHandler,\n          configMaxRecordsToSync = config.maxRecordsToSync,\n          configSyncPageSize = config.syncPageSize,\n          configFullSyncInterval = config.fullSyncInterval,\n          configSyncExpressions = config.syncExpressions,\n          configAuthProviders = config.authProviders,\n          configStorageAdapter = config.storageAdapter,\n          configFromAmplify = __rest(config, [\"DataStore\", \"authModeStrategyType\", \"conflictHandler\", \"errorHandler\", \"maxRecordsToSync\", \"syncPageSize\", \"fullSyncInterval\", \"syncExpressions\", \"authProviders\", \"storageAdapter\"]);\n\n      _this.amplifyConfig = __assign(__assign({}, configFromAmplify), _this.amplifyConfig);\n      _this.conflictHandler = _this.setConflictHandler(config);\n      _this.errorHandler = _this.setErrorHandler(config);\n      var authModeStrategyType = configDataStore && configDataStore.authModeStrategyType || configAuthModeStrategyType || AuthModeStrategyType.DEFAULT;\n\n      switch (authModeStrategyType) {\n        case AuthModeStrategyType.MULTI_AUTH:\n          _this.authModeStrategy = multiAuthStrategy(_this.amplifyContext);\n          break;\n\n        case AuthModeStrategyType.DEFAULT:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n\n        default:\n          _this.authModeStrategy = defaultAuthStrategy;\n          break;\n      } // store on config object, so that Sync, Subscription, and Mutation processors can have access\n\n\n      _this.amplifyConfig.authProviders = configDataStore && configDataStore.authProviders || configAuthProviders;\n      _this.syncExpressions = configDataStore && configDataStore.syncExpressions || configSyncExpressions || _this.syncExpressions;\n      _this.maxRecordsToSync = configDataStore && configDataStore.maxRecordsToSync || configMaxRecordsToSync || _this.maxRecordsToSync || 10000; // store on config object, so that Sync, Subscription, and Mutation processors can have access\n\n      _this.amplifyConfig.maxRecordsToSync = _this.maxRecordsToSync;\n      _this.syncPageSize = configDataStore && configDataStore.syncPageSize || configSyncPageSize || _this.syncPageSize || 1000; // store on config object, so that Sync, Subscription, and Mutation processors can have access\n\n      _this.amplifyConfig.syncPageSize = _this.syncPageSize;\n      _this.fullSyncInterval = configDataStore && configDataStore.fullSyncInterval || configFullSyncInterval || _this.fullSyncInterval || 24 * 60; // 1 day\n\n      _this.storageAdapter = configDataStore && configDataStore.storageAdapter || configStorageAdapter || _this.storageAdapter || undefined;\n      _this.sessionId = _this.retrieveSessionId();\n    };\n  }\n\n  DataStore.prototype.getModuleName = function () {\n    return 'DataStore';\n  };\n  /**\n   * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n   * more instructive errors for customers.\n   *\n   * @param operation The name of the operation (usually a Datastore method) the customer\n   * tried to call.\n   */\n\n\n  DataStore.prototype.handleAddProcError = function (operation) {\n    var _this = this;\n    /**\n     * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n     * and replaced with a friendlier message that instructs the App Developer.\n     *\n     * @param err An error to test.\n     */\n\n\n    var handler = function (err) {\n      if (err.message.startsWith('BackgroundManagerNotOpenError')) {\n        throw new Error([\"DataStoreStateError: Tried to execute `\" + operation + \"` while DataStore was \\\"\" + _this.state + \"\\\".\", \"This can only be done while DataStore is \\\"Started\\\" or \\\"Stopped\\\". To remedy:\", 'Ensure all calls to `stop()` and `clear()` have completed first.', 'If this is not possible, retry the operation until it succeeds.'].join('\\n'));\n      } else {\n        throw err;\n      }\n    };\n\n    return handler;\n  };\n  /**\n   * Clears all data from storage and removes all data, schema info, other\n   * initialization details, and then stops DataStore.\n   *\n   * That said, reinitialization is required after clearing. This can be done\n   * by explicitiliy calling `start()` or any method that implicitly starts\n   * DataStore, such as `query()`, `save()`, or `delete()`.\n   */\n\n\n  DataStore.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            checkSchemaInitialized();\n            this.state = DataStoreState.Clearing;\n            return [4\n            /*yield*/\n            , this.runningProcesses.close()];\n\n          case 1:\n            _a.sent();\n\n            if (!(this.storage === undefined)) return [3\n            /*break*/\n            , 3]; // connect to storage so that it can be cleared without fully starting DataStore\n\n            this.storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator, this.storageAdapter, this.sessionId);\n            return [4\n            /*yield*/\n            , this.storage.init()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            if (syncSubscription && !syncSubscription.closed) {\n              syncSubscription.unsubscribe();\n            }\n\n            if (!this.sync) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.sync.stop()];\n\n          case 4:\n            _a.sent();\n\n            _a.label = 5;\n\n          case 5:\n            return [4\n            /*yield*/\n            , this.storage.clear()];\n\n          case 6:\n            _a.sent();\n\n            this.initialized = undefined; // Should re-initialize when start() is called.\n\n            this.storage = undefined;\n            this.sync = undefined;\n            this.syncPredicates = new WeakMap();\n            return [4\n            /*yield*/\n            , this.runningProcesses.open()];\n\n          case 7:\n            _a.sent();\n\n            this.state = DataStoreState.NotRunning;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Stops all DataStore sync activities.\n   *\n   * TODO: \"Waits for graceful termination of\n   * running queries and terminates subscriptions.\"\n   */\n\n\n  DataStore.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.state = DataStoreState.Stopping;\n            return [4\n            /*yield*/\n            , this.runningProcesses.close()];\n\n          case 1:\n            _a.sent();\n\n            if (syncSubscription && !syncSubscription.closed) {\n              syncSubscription.unsubscribe();\n            }\n\n            if (!this.sync) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.sync.stop()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            this.initialized = undefined; // Should re-initialize when start() is called.\n\n            this.sync = undefined;\n            return [4\n            /*yield*/\n            , this.runningProcesses.open()];\n\n          case 4:\n            _a.sent();\n\n            this.state = DataStoreState.NotRunning;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Validates given pagination input from a query and creates a pagination\n   * argument for use against the storage layer.\n   *\n   * @param modelDefinition\n   * @param paginationProducer\n   */\n\n\n  DataStore.prototype.processPagination = function (modelDefinition, paginationProducer) {\n    var sortPredicate;\n\n    var _a = paginationProducer || {},\n        limit = _a.limit,\n        page = _a.page,\n        sort = _a.sort;\n\n    if (limit === undefined && page === undefined && sort === undefined) {\n      return undefined;\n    }\n\n    if (page !== undefined && limit === undefined) {\n      throw new Error('Limit is required when requesting a page');\n    }\n\n    if (page !== undefined) {\n      if (typeof page !== 'number') {\n        throw new Error('Page should be a number');\n      }\n\n      if (page < 0) {\n        throw new Error(\"Page can't be negative\");\n      }\n    }\n\n    if (limit !== undefined) {\n      if (typeof limit !== 'number') {\n        throw new Error('Limit should be a number');\n      }\n\n      if (limit < 0) {\n        throw new Error(\"Limit can't be negative\");\n      }\n    }\n\n    if (sort) {\n      sortPredicate = ModelSortPredicateCreator.createFromExisting(modelDefinition, sort);\n    }\n\n    return {\n      limit: limit,\n      page: page,\n      sort: sortPredicate\n    };\n  };\n  /**\n   * Examines the configured `syncExpressions` and produces a WeakMap of\n   * SchemaModel -> predicate to use during sync.\n   */\n\n\n  DataStore.prototype.processSyncExpressions = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var syncPredicates;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.syncExpressions || !this.syncExpressions.length) {\n              return [2\n              /*return*/\n              , new WeakMap()];\n            }\n\n            return [4\n            /*yield*/\n            , Promise.all(this.syncExpressions.map(function (syncExpression) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a, modelConstructor, conditionProducer, modelDefinition, condition, predicate;\n\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , syncExpression];\n\n                    case 1:\n                      _a = _b.sent(), modelConstructor = _a.modelConstructor, conditionProducer = _a.conditionProducer;\n                      modelDefinition = getModelDefinition(modelConstructor);\n                      return [4\n                      /*yield*/\n                      , this.unwrapPromise(conditionProducer)];\n\n                    case 2:\n                      condition = _b.sent();\n\n                      if (isPredicatesAll(condition)) {\n                        return [2\n                        /*return*/\n                        , [modelDefinition, null]];\n                      }\n\n                      predicate = internals(condition(predicateFor({\n                        builder: modelConstructor,\n                        schema: modelDefinition,\n                        pkField: extractPrimaryKeyFieldNames(modelDefinition)\n                      }))).toStoragePredicate();\n                      return [2\n                      /*return*/\n                      , [modelDefinition, predicate]];\n                  }\n                });\n              });\n            }))];\n\n          case 1:\n            syncPredicates = _a.sent();\n            return [2\n            /*return*/\n            , this.weakMapFromEntries(syncPredicates)];\n        }\n      });\n    });\n  };\n\n  DataStore.prototype.createFromCondition = function (modelDefinition, condition) {\n    try {\n      return ModelPredicateCreator.createFromExisting(modelDefinition, condition);\n    } catch (error) {\n      logger.error('Error creating Sync Predicate');\n      throw error;\n    }\n  };\n\n  DataStore.prototype.unwrapPromise = function (conditionProducer) {\n    return __awaiter(this, void 0, void 0, function () {\n      var condition, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , conditionProducer()];\n\n          case 1:\n            condition = _a.sent();\n            return [2\n            /*return*/\n            , condition || conditionProducer];\n\n          case 2:\n            error_1 = _a.sent();\n\n            if (error_1 instanceof TypeError) {\n              return [2\n              /*return*/\n              , conditionProducer];\n            }\n\n            throw error_1;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DataStore.prototype.weakMapFromEntries = function (entries) {\n    return entries.reduce(function (map, _a) {\n      var _b = __read(_a, 2),\n          modelDefinition = _b[0],\n          predicate = _b[1];\n\n      if (map.has(modelDefinition)) {\n        var name_2 = modelDefinition.name;\n        logger.warn(\"You can only utilize one Sync Expression per model.\\n          Subsequent sync expressions for the \" + name_2 + \" model will be ignored.\");\n        return map;\n      }\n\n      if (predicate) {\n        map.set(modelDefinition, predicate);\n      }\n\n      return map;\n    }, new WeakMap());\n  };\n  /**\n   * A session ID to allow CMS to open databases against multiple apps.\n   * This session ID is only expected be set by AWS Amplify Studio.\n   */\n\n\n  DataStore.prototype.retrieveSessionId = function () {\n    try {\n      var sessionId = sessionStorage.getItem('datastoreSessionId');\n\n      if (sessionId) {\n        var aws_appsync_graphqlEndpoint = this.amplifyConfig.aws_appsync_graphqlEndpoint;\n        var appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n\n        var _a = __read(appSyncUrl.split('.'), 1),\n            appSyncId = _a[0];\n\n        return sessionId + \"-\" + appSyncId;\n      }\n    } catch (_b) {}\n\n    return undefined;\n  };\n\n  return DataStore;\n}();\n\nvar instance = new DataStore();\nAmplify.register(instance);\nexport { DataStore as DataStoreClass, initSchema, instance as DataStore };","map":{"version":3,"mappings":"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","names":["API","Auth","Cache","Amplify","ConsoleLogger","Logger","Hub","browserOrNode","BackgroundProcessManager","immerable","produce","setAutoFreeze","enablePatches","v4","uuid4","Observable","defaultAuthStrategy","multiAuthStrategy","isPredicatesAll","ModelPredicateCreator","ModelSortPredicateCreator","ExclusiveStorage","Storage","ModelRelationship","ControlMessage","SyncEngine","GraphQLScalarType","isGraphQLScalarType","isSchemaModelWithAttributes","AuthModeStrategyType","isNonModelFieldType","isModelFieldType","isIdentifierObject","isFieldAssociation","DATASTORE","errorMessages","establishRelationAndKeys","isModelConstructor","monotonicUlidFactory","STORAGE","SYNC","USER","isNullOrUndefined","registerNonModelClass","sortCompareFunction","DeferredCallbackResolver","inMemoryPagination","extractPrimaryKeyFieldNames","extractPrimaryKeysAndValues","isIdManaged","isIdOptionallyManaged","mergePatches","recursivePredicateFor","predicateFor","internals","getIdentifierValue","logger","ulid","Date","now","SETTING_SCHEMA_VERSION","schema","modelNamespaceMap","WeakMap","modelPatchesMap","getModelDefinition","modelConstructor","namespace","get","definition","namespaces","models","name","undefined","indexes","relationships","indexFields","Set","indexes_1_1","index","_d","indexField","add","fields","__assign","Object","fromEntries","__spread","values","map","type","isArray","getModelPKFieldName","_a","_b","keys","_c","primaryKey","isValidModelConstructor","obj","has","namespaceResolver","resolver","Error","buildSeedPredicate","modelSchema","pks","builder","pkField","syncClasses","userClasses","dataStoreClasses","storageClasses","modelInstanceAssociationsMap","ModelAttachment","attachedModelInstances","attached","result","attachment","Array","record","set","getAttachment","instance","Detached","initSchema","userSchema","console","warn","log","checkSchemaCodegenVersion","codegenVersion","internalUserNamespace","createTypeClasses","dataStoreNamespace","getNamespace","storageNamespace","syncNamespace","version","forEach","relations","modelAssociations","Map","connectedModels","model","filter","association","field","connectionType","push","getOwnPropertyDescriptor","defineProperty","count","size","from","modelName","parents","every","x","delete","modelTopologicalOrdering","checkSchemaInitialized","message","error","majorVersion","minorVersion","isValid","versionParts","split","major","minor","patch","patchrevision","Number","err","classes","entries","modelDefinition","clazz","createModelClass","nonModels","typeName","typeDefinition","createNonModelClass","instancesMetadata","WeakSet","modelInstanceCreator","init","validateModelFields","k","v","fieldDefinition","isRequired_1","isArrayNullable","name_1","includes","idEmptyString","value","type_1","jsType_1","getJSType","validateScalar_1","getValidationFunction","JSON","parse","errorTypeText","some","e","elemTypes","join","validationStatus","subNonModelDefinition_1","user","nonModel","modelValidator_1","item","subKey","castInstanceType","Boolean","initializeInstance","draft","modelValidator","parsedValue","isInternallyInitialized","modelInstanceMetadata","isInternalModel","_id","id","syncable","checkReadOnlyPropertyOnCreate","_lastChangedAt","_deleted","_version","Model","source","fn","getPrototypeOf","constructor","msg","patches","keyNames","key","p","hasExistingPatches","length","existingPatches","existingSource","mergedPatches","checkReadOnlyPropertyOnUpdate","DataStore","json","fromJSON","localAssociation","targetName","targetNames","relationship","prototype","hasOwnProperty","toLowerCase","remoteModelConstructor","isComplete","i","localJoinFields","remoteJoinFields","instanceMemos","resultPromise","query","and","q","eq","_this","AsyncCollection","then","rows","Promise","resolve","__extends","Symbol","asyncIterator","next","done","max","output","element","modelKeys","isReadOnly","patchArray","path","val","isQueryOne","defaultConflictHandler","conflictData","remoteModel","localModel","defaultErrorHandler","getModelConstructorByModelName","namespaceName","checkSchemaVersion","storage","Setting","runExclusive","s","createFromExisting","page","limit","schemaVersionSetting","storedValue","clear","save","stringify","syncSubscription","enums","pluralName","isRequired","DataStoreState","NotRunning","runningProcesses","state","Starting","initialized","debug","res","rej","initResolve","initReject","storageAdapter","sessionId","aws_appsync_graphqlEndpoint","amplifyConfig","processSyncExpressions","syncPredicates","sync","conflictHandler","errorHandler","authModeStrategy","amplifyContext","connectivityMonitor","fullSyncIntervalInMilliseconds","fullSyncInterval","start","subscribe","data","readyType","isNode","SYNC_ENGINE_SYNC_QUERIES_READY","SYNC_ENGINE_STORAGE_SUBSCRIBED","dispatch","event","config","Running","catch","handleAddProcError","identifierOrCriteria","paginationProducer","pagination","processPagination","keyFields","queryByPkWithCompositeKeyPresent","predicate","createForSingleField","createForPk","seedPredicate","fetch","returnOne","condition","patchesTuple","modelMeta","nonHasManyRelationships","allFrom","nonHasManyRelationships_1","nonHasManyRelationships_1_1","queryObject","createRemoteQueryObject","createFromFlatEqualities","remoteDefinition","related","producedCondition","toStoragePredicate","saved","savedModel","conflictHandlerIsDefault","configDataStore","errorHandlerIsDefault","modelOrConstructor","deleteByPkWithCompositeKeyPresent","isValidPredicate","deleted","pkPredicate","executivePredicate","modelConstructor_1","observe","observeWithObjectLiteral","objectLiteral","buildIdPredicate","isOpen","opType","primaryKeysAndValues","freshElement","matches","observer","complete","addCleaner","unsubscribe","criteria","options","items","itemsChanged","deletedItemIds","handle","generateAndEmitSnapshot","snapshot","generateSnapshot","emitSnapshot","limitTimerRace","callback","maxInterval","sortOptions","sort","itemModelDefinition","idOrPk","isSynced","getModelSyncedStatus","syncPageSize","err_1","itemsArray","sortItems","itemsToSort","sortPredicates","getPredicates","compareFn","hubCallback","payload","SYNC_ENGINE_MODEL_SYNCED","remove","listen","configAuthModeStrategyType","configConflictHandler","configErrorHandler","configMaxRecordsToSync","configSyncPageSize","configFullSyncInterval","configSyncExpressions","configAuthProviders","configStorageAdapter","configFromAmplify","setConflictHandler","setErrorHandler","authModeStrategyType","DEFAULT","MULTI_AUTH","authProviders","syncExpressions","maxRecordsToSync","retrieveSessionId","operation","handler","startsWith","Clearing","close","closed","stop","open","Stopping","sortPredicate","all","syncExpression","conditionProducer","unwrapPromise","weakMapFromEntries","error_1","TypeError","reduce","name_2","sessionStorage","getItem","appSyncUrl","appSyncId","register","DataStoreClass"],"sources":["/home/dalienst/node_modules/@aws-amplify/datastore/src/datastore/datastore.ts"],"sourcesContent":["import { API } from '@aws-amplify/api';\nimport { Auth } from '@aws-amplify/auth';\nimport { Cache } from '@aws-amplify/cache';\nimport {\n\tAmplify,\n\tConsoleLogger as Logger,\n\tHub,\n\tbrowserOrNode,\n\tBackgroundProcessManager,\n} from '@aws-amplify/core';\nimport {\n\tDraft,\n\timmerable,\n\tproduce,\n\tsetAutoFreeze,\n\tenablePatches,\n\tPatch,\n} from 'immer';\nimport { v4 as uuid4 } from 'uuid';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { defaultAuthStrategy, multiAuthStrategy } from '../authModeStrategies';\nimport {\n\tisPredicatesAll,\n\tModelPredicateCreator,\n\tModelSortPredicateCreator,\n\tPredicateAll,\n} from '../predicates';\nimport { Adapter } from '../storage/adapter';\nimport { ExclusiveStorage as Storage } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { ControlMessage, SyncEngine } from '../sync';\nimport {\n\tAuthModeStrategy,\n\tConflictHandler,\n\tDataStoreConfig,\n\tGraphQLScalarType,\n\tInternalSchema,\n\tisGraphQLScalarType,\n\tisSchemaModelWithAttributes,\n\tModelFieldType,\n\tModelInit,\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tModelField,\n\tSortPredicate,\n\tMutableModel,\n\tNamespaceResolver,\n\tNonModelTypeConstructor,\n\tProducerPaginationInput,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tProducerModelPredicate,\n\tSchema,\n\tSchemaModel,\n\tSchemaNamespace,\n\tSchemaNonModel,\n\tSubscriptionMessage,\n\tDataStoreSnapshot,\n\tSyncConflict,\n\tSyncError,\n\tTypeConstructorMap,\n\tErrorHandler,\n\tSyncExpression,\n\tAuthModeStrategyType,\n\tisNonModelFieldType,\n\tisModelFieldType,\n\tObserveQueryOptions,\n\tManagedIdentifier,\n\tPersistentModelMetaData,\n\tIdentifierFieldOrIdentifierObject,\n\tisIdentifierObject,\n\tAmplifyContext,\n\tisFieldAssociation,\n\tRecursiveModelPredicateExtender,\n\tModelPredicateExtender,\n} from '../types';\n// tslint:disable:no-duplicate-imports\nimport type { __modelMeta__ } from '../types';\n\nimport {\n\tDATASTORE,\n\terrorMessages,\n\testablishRelationAndKeys,\n\tisModelConstructor,\n\tmonotonicUlidFactory,\n\tNAMESPACES,\n\tSTORAGE,\n\tSYNC,\n\tUSER,\n\tisNullOrUndefined,\n\tregisterNonModelClass,\n\tsortCompareFunction,\n\tDeferredCallbackResolver,\n\tinMemoryPagination,\n\textractPrimaryKeyFieldNames,\n\textractPrimaryKeysAndValues,\n\tisIdManaged,\n\tisIdOptionallyManaged,\n\tmergePatches,\n} from '../util';\nimport {\n\trecursivePredicateFor,\n\tpredicateFor,\n\tGroupCondition,\n\tinternals,\n} from '../predicates/next';\nimport { getIdentifierValue } from '../sync/utils';\nimport DataStoreConnectivity from '../sync/datastoreConnectivity';\n\nsetAutoFreeze(true);\nenablePatches();\n\nconst logger = new Logger('DataStore');\n\nconst ulid = monotonicUlidFactory(Date.now());\nconst { isNode } = browserOrNode();\n\ntype SettingMetaData = {\n\tidentifier: ManagedIdentifier<Setting, 'id'>;\n\treadOnlyFields: never;\n};\ndeclare class Setting {\n\tpublic readonly [__modelMeta__]: SettingMetaData;\n\tconstructor(init: ModelInit<Setting, SettingMetaData>);\n\tstatic copyOf(\n\t\tsrc: Setting,\n\t\tmutator: (draft: MutableModel<Setting, SettingMetaData>) => void | Setting\n\t): Setting;\n\tpublic readonly id: string;\n\tpublic readonly key: string;\n\tpublic readonly value: string;\n}\n\nconst SETTING_SCHEMA_VERSION = 'schemaVersion';\n\nlet schema: InternalSchema;\nconst modelNamespaceMap = new WeakMap<\n\tPersistentModelConstructor<any>,\n\tstring\n>();\n// stores data for crafting the correct update mutation input for a model\n// Patch[] - array of changed fields and metadata\n// PersistentModel - the source model, used for diffing object-type fields\nconst modelPatchesMap = new WeakMap<\n\tPersistentModel,\n\t[Patch[], PersistentModel]\n>();\n\nconst getModelDefinition = (\n\tmodelConstructor: PersistentModelConstructor<any>\n) => {\n\tconst namespace = modelNamespaceMap.get(modelConstructor)!;\n\tconst definition = namespace\n\t\t? schema.namespaces[namespace].models[modelConstructor.name]\n\t\t: undefined;\n\n\t// compatibility with legacy/pre-PK codegen for lazy loading to inject\n\t// index fields into the model definition.\n\tif (definition) {\n\t\tconst indexes =\n\t\t\tschema.namespaces[namespace].relationships![modelConstructor.name]\n\t\t\t\t.indexes;\n\n\t\tconst indexFields = new Set<string>();\n\t\tfor (const index of indexes) {\n\t\t\tfor (const indexField of index[1]) {\n\t\t\t\tindexFields.add(indexField);\n\t\t\t}\n\t\t}\n\n\t\tdefinition.fields = {\n\t\t\t...Object.fromEntries(\n\t\t\t\t[...indexFields.values()].map(\n\t\t\t\t\tname => [\n\t\t\t\t\t\tname,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t[]\n\t\t\t\t)\n\t\t\t),\n\t\t\t...definition.fields,\n\t\t};\n\t}\n\n\treturn definition;\n};\n\nconst getModelPKFieldName = (\n\tmodelConstructor: PersistentModelConstructor<any>\n) => {\n\tconst namespace = modelNamespaceMap.get(modelConstructor);\n\treturn (\n\t\t(namespace &&\n\t\t\tschema.namespaces?.[namespace]?.keys?.[modelConstructor.name]\n\t\t\t\t.primaryKey) || ['id']\n\t);\n};\n\nconst isValidModelConstructor = <T extends PersistentModel>(\n\tobj: any\n): obj is PersistentModelConstructor<T> => {\n\tif (isModelConstructor(obj) && modelNamespaceMap.has(obj)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n};\n\nconst namespaceResolver: NamespaceResolver = modelConstructor => {\n\tconst resolver = modelNamespaceMap.get(modelConstructor);\n\tif (!resolver) {\n\t\tthrow new Error(\n\t\t\t`Namespace Resolver for '${modelConstructor.name}' not found! This is probably a bug in '@amplify-js/datastore'.`\n\t\t);\n\t}\n\treturn resolver;\n};\n\nconst buildSeedPredicate = <T extends PersistentModel>(\n\tmodelConstructor: PersistentModelConstructor<T>\n) => {\n\tif (!modelConstructor) throw new Error('Missing modelConstructor');\n\n\tconst modelSchema = getModelDefinition(\n\t\tmodelConstructor as PersistentModelConstructor<T>\n\t);\n\tif (!modelSchema) throw new Error('Missing modelSchema');\n\n\tconst pks = getModelPKFieldName(\n\t\tmodelConstructor as PersistentModelConstructor<T>\n\t);\n\tif (!pks) throw new Error('Could not determine PK');\n\n\treturn recursivePredicateFor<T>({\n\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\tschema: modelSchema,\n\t\tpkField: pks,\n\t});\n};\n\n// exporting syncClasses for testing outbox.test.ts\nexport let syncClasses: TypeConstructorMap;\nlet userClasses: TypeConstructorMap;\nlet dataStoreClasses: TypeConstructorMap;\nlet storageClasses: TypeConstructorMap;\n\n/**\n * Maps a model to its related models for memoization/immutability.\n */\nconst modelInstanceAssociationsMap = new WeakMap<PersistentModel, object>();\n\n/**\n * Describes whether and to what a model is attached for lazy loading purposes.\n */\nenum ModelAttachment {\n\t/**\n\t * Model doesn't lazy load from any data source.\n\t *\n\t * Related entity properties provided at instantiation are returned\n\t * via the respective lazy interfaces when their properties are invoked.\n\t */\n\tDetached = 'Detached',\n\n\t/**\n\t * Model lazy loads from the global DataStore.\n\t */\n\tDataStore = 'DataStore',\n\n\t/**\n\t * Demonstrative. Not yet implemented.\n\t */\n\tAPI = 'API',\n}\n\n/**\n * Tells us which data source a model is attached to (lazy loads from).\n *\n * If `Deatched`, the model's lazy properties will only ever return properties\n * from memory provided at construction time.\n */\nconst attachedModelInstances = new WeakMap<PersistentModel, ModelAttachment>();\n\n/**\n * Registers a model instance against a data source (DataStore, API, or\n * Detached/None).\n *\n * The API option is demonstrative. Lazy loading against API is not yet\n * implemented.\n *\n * @param result A model instance or array of instances\n * @param attachment A ModelAttachment data source\n * @returns passes the `result` back through after attachment\n */\nexport function attached<T extends PersistentModel | PersistentModel[]>(\n\tresult: T,\n\tattachment: ModelAttachment\n): T {\n\tif (Array.isArray(result)) {\n\t\tresult.map(record => attached(record, attachment)) as T;\n\t} else {\n\t\tresult && attachedModelInstances.set(result, attachment);\n\t}\n\treturn result;\n}\n\n/**\n * Determines what source a model instance should lazy load from.\n *\n * If the instace was never explicitly registered, it is detached by default.\n *\n * @param instance A model instance\n */\nexport const getAttachment = (instance: PersistentModel) => {\n\treturn attachedModelInstances.has(instance)\n\t\t? attachedModelInstances.get(instance)\n\t\t: ModelAttachment.Detached;\n};\n\nconst initSchema = (userSchema: Schema) => {\n\tif (schema !== undefined) {\n\t\tconsole.warn('The schema has already been initialized');\n\n\t\treturn userClasses;\n\t}\n\n\tlogger.log('validating schema', { schema: userSchema });\n\n\tcheckSchemaCodegenVersion(userSchema.codegenVersion);\n\n\tconst internalUserNamespace: SchemaNamespace = {\n\t\tname: USER,\n\t\t...userSchema,\n\t};\n\n\tlogger.log('DataStore', 'Init models');\n\tuserClasses = createTypeClasses(internalUserNamespace);\n\tlogger.log('DataStore', 'Models initialized');\n\n\tconst dataStoreNamespace = getNamespace();\n\tconst storageNamespace = Storage.getNamespace();\n\tconst syncNamespace = SyncEngine.getNamespace();\n\n\tdataStoreClasses = createTypeClasses(dataStoreNamespace);\n\tstorageClasses = createTypeClasses(storageNamespace);\n\tsyncClasses = createTypeClasses(syncNamespace);\n\n\tschema = {\n\t\tnamespaces: {\n\t\t\t[dataStoreNamespace.name]: dataStoreNamespace,\n\t\t\t[internalUserNamespace.name]: internalUserNamespace,\n\t\t\t[storageNamespace.name]: storageNamespace,\n\t\t\t[syncNamespace.name]: syncNamespace,\n\t\t},\n\t\tversion: userSchema.version,\n\t\tcodegenVersion: userSchema.codegenVersion,\n\t};\n\n\tObject.keys(schema.namespaces).forEach(namespace => {\n\t\tconst [relations, keys] = establishRelationAndKeys(\n\t\t\tschema.namespaces[namespace]\n\t\t);\n\n\t\tschema.namespaces[namespace].relationships = relations;\n\t\tschema.namespaces[namespace].keys = keys;\n\n\t\tconst modelAssociations = new Map<string, string[]>();\n\n\t\tObject.values(schema.namespaces[namespace].models).forEach(model => {\n\t\t\tconst connectedModels: string[] = [];\n\n\t\t\tObject.values(model.fields)\n\t\t\t\t.filter(\n\t\t\t\t\tfield =>\n\t\t\t\t\t\tfield.association &&\n\t\t\t\t\t\tfield.association.connectionType === 'BELONGS_TO' &&\n\t\t\t\t\t\t(<ModelFieldType>field.type).model !== model.name\n\t\t\t\t)\n\t\t\t\t.forEach(field =>\n\t\t\t\t\tconnectedModels.push((<ModelFieldType>field.type).model)\n\t\t\t\t);\n\n\t\t\tmodelAssociations.set(model.name, connectedModels);\n\n\t\t\tObject.values(model.fields).forEach(field => {\n\t\t\t\tif (\n\t\t\t\t\ttypeof field.type === 'object' &&\n\t\t\t\t\t!Object.getOwnPropertyDescriptor(\n\t\t\t\t\t\t<ModelFieldType>field.type,\n\t\t\t\t\t\t'modelConstructor'\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tObject.defineProperty(field.type, 'modelConstructor', {\n\t\t\t\t\t\tget: () => {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tbuilder: userClasses[(<ModelFieldType>field.type).model],\n\t\t\t\t\t\t\t\tschema:\n\t\t\t\t\t\t\t\t\tschema.namespaces[namespace].models[\n\t\t\t\t\t\t\t\t\t\t(<ModelFieldType>field.type).model\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tpkField: getModelPKFieldName(\n\t\t\t\t\t\t\t\t\tuserClasses[\n\t\t\t\t\t\t\t\t\t\t(<ModelFieldType>field.type).model\n\t\t\t\t\t\t\t\t\t] as PersistentModelConstructor<any>\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tconst result = new Map<string, string[]>();\n\n\t\tlet count = 1000;\n\t\twhile (true && count > 0) {\n\t\t\tif (modelAssociations.size === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount--;\n\t\t\tif (count === 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Models are not topologically sortable. Please verify your schema.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tfor (const modelName of Array.from(modelAssociations.keys())) {\n\t\t\t\tconst parents = modelAssociations.get(modelName);\n\n\t\t\t\tif (parents?.every(x => result.has(x))) {\n\t\t\t\t\tresult.set(modelName, parents);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArray.from(result.keys()).forEach(x => modelAssociations.delete(x));\n\t\t}\n\n\t\tschema.namespaces[namespace].modelTopologicalOrdering = result;\n\t});\n\n\treturn userClasses;\n};\n\n/**\n * Throws an exception if the schema has *not* been initialized\n * by `initSchema()`.\n *\n * **To be called before trying to access schema.**\n *\n * Currently this only needs to be called in `start()` and `clear()` because\n * all other functions will call start first.\n */\nconst checkSchemaInitialized = () => {\n\tif (schema === undefined) {\n\t\tconst message =\n\t\t\t'Schema is not initialized. DataStore will not function as expected. This could happen if you have multiple versions of DataStore installed. Please see https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js/#check-for-duplicate-versions';\n\t\tlogger.error(message);\n\t\tthrow new Error(message);\n\t}\n};\n\n/**\n * Throws an exception if the schema is using a codegen version that is not supported.\n *\n * Set the supported version by setting majorVersion and minorVersion\n * This functions similar to ^ version range.\n * The tested codegenVersion major version must exactly match the set majorVersion\n * The tested codegenVersion minor version must be gt or equal to the set minorVersion\n * Example: For a min supported version of 5.4.0 set majorVersion = 5 and minorVersion = 4\n *\n * This regex will not work when setting a supported range with minor version\n * of 2 or more digits.\n * i.e. minorVersion = 10 will not work\n * The regex will work for testing a codegenVersion with multi digit minor\n * versions as long as the minimum minorVersion is single digit.\n * i.e. codegenVersion = 5.30.1, majorVersion = 5, minorVersion = 4 PASSES\n *\n * @param codegenVersion schema codegenVersion\n */\nconst checkSchemaCodegenVersion = (codegenVersion: string) => {\n\t// TODO: set to correct version when released in codegen\n\tconst majorVersion = 3;\n\tconst minorVersion = 2;\n\tlet isValid = false;\n\n\ttry {\n\t\tconst versionParts = codegenVersion.split('.');\n\t\tconst [major, minor, patch, patchrevision] = versionParts;\n\t\tisValid = Number(major) === majorVersion && Number(minor) >= minorVersion;\n\t} catch (err) {\n\t\tconsole.log(`Error parsing codegen version: ${codegenVersion}\\n${err}`);\n\t}\n\n\tif (!isValid) {\n\t\tconst message =\n\t\t\t`Models were generated with an unsupported version of codegen. Codegen artifacts are from ${\n\t\t\t\tcodegenVersion || 'an unknown version'\n\t\t\t}, whereas ^${majorVersion}.${minorVersion}.0 is required. ` +\n\t\t\t\"Update to the latest CLI and run 'amplify codegen models'.\";\n\t\tlogger.error(message);\n\t\tthrow new Error(message);\n\t}\n};\n\nconst createTypeClasses: (\n\tnamespace: SchemaNamespace\n) => TypeConstructorMap = namespace => {\n\tconst classes: TypeConstructorMap = {};\n\n\tObject.entries(namespace.models).forEach(([modelName, modelDefinition]) => {\n\t\tconst clazz = createModelClass(modelDefinition);\n\t\tclasses[modelName] = clazz;\n\n\t\tmodelNamespaceMap.set(clazz, namespace.name);\n\t});\n\n\tObject.entries(namespace.nonModels || {}).forEach(\n\t\t([typeName, typeDefinition]) => {\n\t\t\tconst clazz = createNonModelClass(typeDefinition) as any;\n\t\t\tclasses[typeName] = clazz;\n\t\t}\n\t);\n\n\treturn classes;\n};\n\n/**\n * Constructs a model and records it with its metadata in a weakset. Allows for\n * the separate storage of core model fields and Amplify/DataStore metadata\n * fields that the customer app does not want exposed.\n *\n * @param modelConstructor The model constructor.\n * @param init Init data that would normally be passed to the constructor.\n * @returns The initialized model.\n */\nexport declare type ModelInstanceCreator = typeof modelInstanceCreator;\n\n/**\n * Collection of instantiated models to allow storage of metadata apart from\n * the model visible to the consuming app -- in case the app doesn't have\n * metadata fields (_version, _deleted, etc.) exposed on the model itself.\n */\nconst instancesMetadata = new WeakSet<ModelInit<any, any>>();\n\nfunction modelInstanceCreator<T extends PersistentModel>(\n\tmodelConstructor: PersistentModelConstructor<T>,\n\tinit: Partial<T>\n): T {\n\tinstancesMetadata.add(init);\n\n\treturn new modelConstructor(<ModelInit<T, PersistentModelMetaData<T>>>init);\n}\n\nconst validateModelFields =\n\t(modelDefinition: SchemaModel | SchemaNonModel) => (k: string, v: any) => {\n\t\tconst fieldDefinition = modelDefinition.fields[k];\n\n\t\tif (fieldDefinition !== undefined) {\n\t\t\tconst { type, isRequired, isArrayNullable, name, isArray } =\n\t\t\t\tfieldDefinition;\n\n\t\t\tif (\n\t\t\t\t((!isArray && isRequired) || (isArray && !isArrayNullable)) &&\n\t\t\t\t(v === null || v === undefined)\n\t\t\t) {\n\t\t\t\tthrow new Error(`Field ${name} is required`);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tisSchemaModelWithAttributes(modelDefinition) &&\n\t\t\t\t!isIdManaged(modelDefinition)\n\t\t\t) {\n\t\t\t\tconst keys = extractPrimaryKeyFieldNames(modelDefinition);\n\t\t\t\tif (keys.includes(k) && v === '') {\n\t\t\t\t\tlogger.error(errorMessages.idEmptyString, { k, value: v });\n\t\t\t\t\tthrow new Error(errorMessages.idEmptyString);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isGraphQLScalarType(type)) {\n\t\t\t\tconst jsType = GraphQLScalarType.getJSType(type);\n\t\t\t\tconst validateScalar = GraphQLScalarType.getValidationFunction(type);\n\n\t\t\t\tif (type === 'AWSJSON') {\n\t\t\t\t\tif (typeof v === jsType) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof v === 'string') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJSON.parse(v);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tthrow new Error(`Field ${name} is an invalid JSON object. ${v}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tlet errorTypeText: string = jsType;\n\t\t\t\t\tif (!isRequired) {\n\t\t\t\t\t\terrorTypeText = `${jsType} | null | undefined`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Array.isArray(v) && !isArrayNullable) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t!isNullOrUndefined(v) &&\n\t\t\t\t\t\t(<[]>v).some(e =>\n\t\t\t\t\t\t\tisNullOrUndefined(e) ? isRequired : typeof e !== jsType\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst elemTypes = (<[]>v)\n\t\t\t\t\t\t\t.map(e => (e === null ? 'null' : typeof e))\n\t\t\t\t\t\t\t.join(',');\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${errorTypeText}, [${elemTypes}] received. ${v}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (validateScalar && !isNullOrUndefined(v)) {\n\t\t\t\t\t\tconst validationStatus = (<[]>v).map(e => {\n\t\t\t\t\t\t\tif (!isNullOrUndefined(e)) {\n\t\t\t\t\t\t\t\treturn validateScalar(e);\n\t\t\t\t\t\t\t} else if (isNullOrUndefined(e) && !isRequired) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!validationStatus.every(s => s)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${type}, validation failed for one or more elements. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!isRequired && v === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (typeof v !== jsType && v !== null) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Field ${name} should be of type ${jsType}, ${typeof v} received. ${v}`\n\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\t!isNullOrUndefined(v) &&\n\t\t\t\t\tvalidateScalar &&\n\t\t\t\t\t!validateScalar(v as never) // TODO: why never, TS ... why ...\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Field ${name} should be of type ${type}, validation failed. ${v}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (isNonModelFieldType(type)) {\n\t\t\t\t// do not check non model fields if undefined or null\n\t\t\t\tif (!isNullOrUndefined(v)) {\n\t\t\t\t\tconst subNonModelDefinition =\n\t\t\t\t\t\tschema.namespaces.user.nonModels![type.nonModel];\n\t\t\t\t\tconst modelValidator = validateModelFields(subNonModelDefinition);\n\n\t\t\t\t\tif (isArray) {\n\t\t\t\t\t\tlet errorTypeText: string = type.nonModel;\n\t\t\t\t\t\tif (!isRequired) {\n\t\t\t\t\t\t\terrorTypeText = `${type.nonModel} | null | undefined`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!Array.isArray(v)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Field ${name} should be of type [${errorTypeText}], ${typeof v} received. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tv.forEach(item => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(isNullOrUndefined(item) && isRequired) ||\n\t\t\t\t\t\t\t\t(typeof item !== 'object' && typeof item !== 'undefined')\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`All elements in the ${name} array should be of type ${\n\t\t\t\t\t\t\t\t\t\ttype.nonModel\n\t\t\t\t\t\t\t\t\t}, [${typeof item}] received. ${item}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isNullOrUndefined(item)) {\n\t\t\t\t\t\t\t\tObject.keys(subNonModelDefinition.fields).forEach(subKey => {\n\t\t\t\t\t\t\t\t\tmodelValidator(subKey, item[subKey]);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof v !== 'object') {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Field ${name} should be of type ${\n\t\t\t\t\t\t\t\t\ttype.nonModel\n\t\t\t\t\t\t\t\t}, ${typeof v} recieved. ${v}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tObject.keys(subNonModelDefinition.fields).forEach(subKey => {\n\t\t\t\t\t\t\tmodelValidator(subKey, v[subKey]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\nconst castInstanceType = (\n\tmodelDefinition: SchemaModel | SchemaNonModel,\n\tk: string,\n\tv: any\n) => {\n\tconst { isArray, type } = modelDefinition.fields[k] || {};\n\t// attempt to parse stringified JSON\n\tif (\n\t\ttypeof v === 'string' &&\n\t\t(isArray ||\n\t\t\ttype === 'AWSJSON' ||\n\t\t\tisNonModelFieldType(type) ||\n\t\t\tisModelFieldType(type))\n\t) {\n\t\ttry {\n\t\t\treturn JSON.parse(v);\n\t\t} catch {\n\t\t\t// if JSON is invalid, don't throw and let modelValidator handle it\n\t\t}\n\t}\n\n\t// cast from numeric representation of boolean to JS boolean\n\tif (typeof v === 'number' && type === 'Boolean') {\n\t\treturn Boolean(v);\n\t}\n\n\treturn v;\n};\n\nconst initializeInstance = <T extends PersistentModel>(\n\tinit: ModelInit<T>,\n\tmodelDefinition: SchemaModel | SchemaNonModel,\n\tdraft: Draft<T & ModelInstanceMetadata>\n) => {\n\tconst modelValidator = validateModelFields(modelDefinition);\n\tObject.entries(init).forEach(([k, v]) => {\n\t\tconst parsedValue = castInstanceType(modelDefinition, k, v);\n\n\t\tmodelValidator(k, parsedValue);\n\t\t(<any>draft)[k] = parsedValue;\n\t});\n};\n\nconst createModelClass = <T extends PersistentModel>(\n\tmodelDefinition: SchemaModel\n) => {\n\tconst clazz = <PersistentModelConstructor<T>>(<unknown>class Model {\n\t\tconstructor(init: ModelInit<T>) {\n\t\t\tconst instance = produce(\n\t\t\t\tthis,\n\t\t\t\t(draft: Draft<T & ModelInstanceMetadata>) => {\n\t\t\t\t\tinitializeInstance(init, modelDefinition, draft);\n\n\t\t\t\t\t// model is initialized inside a DataStore component (e.g. by Sync Engine, Storage Engine, etc.)\n\t\t\t\t\tconst isInternallyInitialized = instancesMetadata.has(init);\n\n\t\t\t\t\tconst modelInstanceMetadata: ModelInstanceMetadata =\n\t\t\t\t\t\tisInternallyInitialized\n\t\t\t\t\t\t\t? <ModelInstanceMetadata>(<unknown>init)\n\t\t\t\t\t\t\t: <ModelInstanceMetadata>{};\n\n\t\t\t\t\ttype ModelWithIDIdentifier = { id: string };\n\n\t\t\t\t\tconst { id: _id } =\n\t\t\t\t\t\tmodelInstanceMetadata as unknown as ModelWithIDIdentifier;\n\n\t\t\t\t\tif (isIdManaged(modelDefinition)) {\n\t\t\t\t\t\tconst isInternalModel = _id !== null && _id !== undefined;\n\n\t\t\t\t\t\tconst id = isInternalModel\n\t\t\t\t\t\t\t? _id\n\t\t\t\t\t\t\t: modelDefinition.syncable\n\t\t\t\t\t\t\t? uuid4()\n\t\t\t\t\t\t\t: ulid();\n\n\t\t\t\t\t\t(<ModelWithIDIdentifier>(<unknown>draft)).id = id;\n\t\t\t\t\t} else if (isIdOptionallyManaged(modelDefinition)) {\n\t\t\t\t\t\t// only auto-populate if the id was not provided\n\t\t\t\t\t\t(<ModelWithIDIdentifier>(<unknown>draft)).id = draft.id || uuid4();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!isInternallyInitialized) {\n\t\t\t\t\t\tcheckReadOnlyPropertyOnCreate(draft, modelDefinition);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { _version, _lastChangedAt, _deleted } = modelInstanceMetadata;\n\n\t\t\t\t\tif (modelDefinition.syncable) {\n\t\t\t\t\t\tdraft._version = _version;\n\t\t\t\t\t\tdraft._lastChangedAt = _lastChangedAt;\n\t\t\t\t\t\tdraft._deleted = _deleted;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn instance;\n\t\t}\n\n\t\tstatic copyOf(source: T, fn: (draft: MutableModel<T>) => T) {\n\t\t\tconst modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\tconst msg = 'The source object is not a valid model';\n\t\t\t\tlogger.error(msg, { source });\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\n\t\t\tlet patches;\n\t\t\tconst model = produce(\n\t\t\t\tsource,\n\t\t\t\tdraft => {\n\t\t\t\t\tfn(<MutableModel<T>>draft);\n\n\t\t\t\t\tconst keyNames = extractPrimaryKeyFieldNames(modelDefinition);\n\t\t\t\t\t// Keys are immutable\n\t\t\t\t\tkeyNames.forEach(key => ((draft as Object)[key] = source[key]));\n\n\t\t\t\t\tconst modelValidator = validateModelFields(modelDefinition);\n\t\t\t\t\tObject.entries(draft).forEach(([k, v]) => {\n\t\t\t\t\t\tconst parsedValue = castInstanceType(modelDefinition, k, v);\n\n\t\t\t\t\t\tmodelValidator(k, parsedValue);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tp => (patches = p)\n\t\t\t);\n\n\t\t\tconst hasExistingPatches = modelPatchesMap.has(source);\n\n\t\t\tif (patches.length || hasExistingPatches) {\n\t\t\t\tif (hasExistingPatches) {\n\t\t\t\t\tconst [existingPatches, existingSource] =\n\t\t\t\t\t\tmodelPatchesMap.get(source)!;\n\t\t\t\t\tconst mergedPatches = mergePatches(\n\t\t\t\t\t\texistingSource,\n\t\t\t\t\t\texistingPatches,\n\t\t\t\t\t\tpatches\n\t\t\t\t\t);\n\t\t\t\t\tmodelPatchesMap.set(model, [mergedPatches, existingSource]);\n\t\t\t\t\tcheckReadOnlyPropertyOnUpdate(mergedPatches, modelDefinition);\n\t\t\t\t} else {\n\t\t\t\t\tmodelPatchesMap.set(model, [patches, source]);\n\t\t\t\t\tcheckReadOnlyPropertyOnUpdate(patches, modelDefinition);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn attached(model, ModelAttachment.DataStore);\n\t\t}\n\n\t\t// \"private\" method (that's hidden via `Setting`) for `withSSRContext` to use\n\t\t// to gain access to `modelInstanceCreator` and `clazz` for persisting IDs from server to client.\n\t\tstatic fromJSON(json: T | T[]) {\n\t\t\tif (Array.isArray(json)) {\n\t\t\t\treturn json.map(init => this.fromJSON(init));\n\t\t\t}\n\n\t\t\tconst instance = modelInstanceCreator(clazz, json);\n\n\t\t\tconst modelValidator = validateModelFields(modelDefinition);\n\n\t\t\tObject.entries(instance).forEach(([k, v]) => {\n\t\t\t\tmodelValidator(k, v);\n\t\t\t});\n\n\t\t\treturn attached(instance, ModelAttachment.DataStore);\n\t\t}\n\t});\n\n\tclazz[immerable] = true;\n\n\tObject.defineProperty(clazz, 'name', { value: modelDefinition.name });\n\n\tfor (const field in modelDefinition.fields) {\n\t\tif (!isFieldAssociation(modelDefinition, field)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst {\n\t\t\ttype,\n\t\t\tassociation: localAssociation,\n\t\t\tassociation: { targetName, targetNames },\n\t\t} = modelDefinition.fields[field] as Required<ModelField>;\n\n\t\tconst relationship = new ModelRelationship(\n\t\t\t{\n\t\t\t\tbuilder: clazz,\n\t\t\t\tschema: modelDefinition,\n\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t},\n\t\t\tfield\n\t\t);\n\n\t\tObject.defineProperty(clazz.prototype, modelDefinition.fields[field].name, {\n\t\t\tset(model: PersistentModel) {\n\t\t\t\tif (!model || !(typeof model === 'object')) return;\n\n\t\t\t\t// Avoid validation error when processing AppSync response with nested\n\t\t\t\t// selection set. Nested entitites lack version field and can not be validated\n\t\t\t\t// TODO: explore a more reliable method to solve this\n\t\t\t\tif (model.hasOwnProperty('_version')) {\n\t\t\t\t\tconst modelConstructor = Object.getPrototypeOf(model || {})\n\t\t\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\t\tconst msg = `Value passed to ${modelDefinition.name}.${field} is not a valid instance of a model`;\n\t\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmodelConstructor.name.toLowerCase() !==\n\t\t\t\t\t\trelationship.remoteModelConstructor.name.toLowerCase()\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst msg = `Value passed to ${modelDefinition.name}.${field} is not an instance of ${relationship.remoteModelConstructor.name}`;\n\t\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (relationship.isComplete) {\n\t\t\t\t\tfor (let i = 0; i < relationship.localJoinFields.length; i++) {\n\t\t\t\t\t\tthis[relationship.localJoinFields[i]] =\n\t\t\t\t\t\t\tmodel[relationship.remoteJoinFields[i]];\n\t\t\t\t\t}\n\t\t\t\t\tconst instanceMemos = modelInstanceAssociationsMap.has(this)\n\t\t\t\t\t\t? modelInstanceAssociationsMap.get(this)!\n\t\t\t\t\t\t: modelInstanceAssociationsMap.set(this, {}).get(this)!;\n\t\t\t\t\tinstanceMemos[field] = model;\n\t\t\t\t}\n\t\t\t},\n\t\t\tget() {\n\t\t\t\tconst instanceMemos = modelInstanceAssociationsMap.has(this)\n\t\t\t\t\t? modelInstanceAssociationsMap.get(this)!\n\t\t\t\t\t: modelInstanceAssociationsMap.set(this, {}).get(this)!;\n\n\t\t\t\tif (!instanceMemos.hasOwnProperty(field)) {\n\t\t\t\t\tif (getAttachment(this) === ModelAttachment.DataStore) {\n\t\t\t\t\t\tconst resultPromise = instance.query(\n\t\t\t\t\t\t\trelationship.remoteModelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\t\t\tbase =>\n\t\t\t\t\t\t\t\tbase.and(q => {\n\t\t\t\t\t\t\t\t\treturn relationship.remoteJoinFields.map((field, index) => {\n\t\t\t\t\t\t\t\t\t\treturn (q[field] as any).eq(\n\t\t\t\t\t\t\t\t\t\t\tthis[relationship.localJoinFields[index]]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (relationship.type === 'HAS_MANY') {\n\t\t\t\t\t\t\tinstanceMemos[field] = new AsyncCollection(resultPromise);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinstanceMemos[field] = resultPromise.then(rows => {\n\t\t\t\t\t\t\t\tif (rows.length > 1) {\n\t\t\t\t\t\t\t\t\t// should never happen for a HAS_ONE or BELONGS_TO.\n\t\t\t\t\t\t\t\t\tconst err = new Error(`\n\t\t\t\t\t\t\t\t\tData integrity error.\n\t\t\t\t\t\t\t\t\tToo many records found for a HAS_ONE/BELONGS_TO field '${modelDefinition.name}.${field}'\n\t\t\t\t\t\t\t\t`);\n\t\t\t\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn rows[0];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (getAttachment(this) === ModelAttachment.API) {\n\t\t\t\t\t\tthrow new Error('Lazy loading from API is not yet supported!');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (relationship.type === 'HAS_MANY') {\n\t\t\t\t\t\t\treturn new AsyncCollection([]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn Promise.resolve(undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn instanceMemos[field];\n\t\t\t},\n\t\t});\n\t}\n\n\treturn clazz;\n};\n\nexport class AsyncItem<T> extends Promise<T> {}\n\nexport class AsyncCollection<T> implements AsyncIterable<T> {\n\tprivate values: Array<any> | Promise<Array<any>>;\n\n\tconstructor(values: Array<any> | Promise<Array<any>>) {\n\t\tthis.values = values;\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T> {\n\t\tlet values;\n\t\tlet index = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tif (!values) values = await this.values;\n\t\t\t\tif (index < values.length) {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\tvalue: values[index],\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t};\n\t\t\t\t\tindex++;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tvalue: null,\n\t\t\t\t\tdone: true,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tasync toArray({\n\t\tmax = Number.MAX_SAFE_INTEGER,\n\t}: { max?: number } = {}): Promise<T[]> {\n\t\tconst output: T[] = [];\n\t\tlet i = 0;\n\t\tfor await (const element of this) {\n\t\t\tif (i < max) {\n\t\t\t\toutput.push(element);\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n}\n\nconst checkReadOnlyPropertyOnCreate = <T extends PersistentModel>(\n\tdraft: T,\n\tmodelDefinition: SchemaModel\n) => {\n\tconst modelKeys = Object.keys(draft);\n\tconst { fields } = modelDefinition;\n\n\tmodelKeys.forEach(key => {\n\t\tif (fields[key] && fields[key].isReadOnly) {\n\t\t\tthrow new Error(`${key} is read-only.`);\n\t\t}\n\t});\n};\n\nconst checkReadOnlyPropertyOnUpdate = (\n\tpatches: Patch[],\n\tmodelDefinition: SchemaModel\n) => {\n\tconst patchArray = patches.map(p => [p.path[0], p.value]);\n\tconst { fields } = modelDefinition;\n\n\tpatchArray.forEach(([key, val]) => {\n\t\tif (!val || !fields[key]) return;\n\n\t\tif (fields[key].isReadOnly) {\n\t\t\tthrow new Error(`${key} is read-only.`);\n\t\t}\n\t});\n};\n\nconst createNonModelClass = <T extends PersistentModel>(\n\ttypeDefinition: SchemaNonModel\n) => {\n\tconst clazz = <NonModelTypeConstructor<T>>(<unknown>class Model {\n\t\tconstructor(init: ModelInit<T>) {\n\t\t\tconst instance = produce(\n\t\t\t\tthis,\n\t\t\t\t(draft: Draft<T & ModelInstanceMetadata>) => {\n\t\t\t\t\tinitializeInstance(init, typeDefinition, draft);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn instance;\n\t\t}\n\t});\n\n\tclazz[immerable] = true;\n\n\tObject.defineProperty(clazz, 'name', { value: typeDefinition.name });\n\n\tregisterNonModelClass(clazz);\n\n\treturn clazz;\n};\n\nfunction isQueryOne(obj: any): obj is string {\n\treturn typeof obj === 'string';\n}\n\nfunction defaultConflictHandler(conflictData: SyncConflict): PersistentModel {\n\tconst { localModel, modelConstructor, remoteModel } = conflictData;\n\tconst { _version } = remoteModel;\n\treturn modelInstanceCreator(modelConstructor, { ...localModel, _version });\n}\n\nfunction defaultErrorHandler(error: SyncError<PersistentModel>): void {\n\tlogger.warn(error);\n}\n\nfunction getModelConstructorByModelName(\n\tnamespaceName: NAMESPACES,\n\tmodelName: string\n): PersistentModelConstructor<any> {\n\tlet result: PersistentModelConstructor<any> | NonModelTypeConstructor<any>;\n\n\tswitch (namespaceName) {\n\t\tcase DATASTORE:\n\t\t\tresult = dataStoreClasses[modelName];\n\t\t\tbreak;\n\t\tcase USER:\n\t\t\tresult = userClasses[modelName];\n\t\t\tbreak;\n\t\tcase SYNC:\n\t\t\tresult = syncClasses[modelName];\n\t\t\tbreak;\n\t\tcase STORAGE:\n\t\t\tresult = storageClasses[modelName];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid namespace: ${namespaceName}`);\n\t}\n\n\tif (isValidModelConstructor(result)) {\n\t\treturn result;\n\t} else {\n\t\tconst msg = `Model name is not valid for namespace. modelName: ${modelName}, namespace: ${namespaceName}`;\n\t\tlogger.error(msg);\n\n\t\tthrow new Error(msg);\n\t}\n}\n\n/**\n * Queries the DataStore metadata tables to see if they are the expected\n * version. If not, clobbers the whole DB. If so, leaves them alone.\n * Otherwise, simply writes the schema version.\n *\n * SIDE EFFECT:\n * 1. Creates a transaction\n * 1. Updates data.\n *\n * @param storage Storage adapter containing the metadata.\n * @param version The expected schema version.\n */\nasync function checkSchemaVersion(\n\tstorage: Storage,\n\tversion: string\n): Promise<void> {\n\tconst Setting =\n\t\tdataStoreClasses.Setting as PersistentModelConstructor<Setting>;\n\n\tconst modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n\n\tawait storage.runExclusive(async s => {\n\t\tconst [schemaVersionSetting] = await s.query(\n\t\t\tSetting,\n\t\t\tModelPredicateCreator.createFromExisting(modelDefinition, c =>\n\t\t\t\tc.key('eq', SETTING_SCHEMA_VERSION)\n\t\t\t),\n\t\t\t{ page: 0, limit: 1 }\n\t\t);\n\n\t\tif (\n\t\t\tschemaVersionSetting !== undefined &&\n\t\t\tschemaVersionSetting.value !== undefined\n\t\t) {\n\t\t\tconst storedValue = JSON.parse(schemaVersionSetting.value);\n\n\t\t\tif (storedValue !== version) {\n\t\t\t\tawait s.clear(false);\n\t\t\t}\n\t\t} else {\n\t\t\tawait s.save(\n\t\t\t\tmodelInstanceCreator(Setting, {\n\t\t\t\t\tkey: SETTING_SCHEMA_VERSION,\n\t\t\t\t\tvalue: JSON.stringify(version),\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t});\n}\n\nlet syncSubscription: ZenObservable.Subscription;\n\nfunction getNamespace(): SchemaNamespace {\n\tconst namespace: SchemaNamespace = {\n\t\tname: DATASTORE,\n\t\trelationships: {},\n\t\tenums: {},\n\t\tnonModels: {},\n\t\tmodels: {\n\t\t\tSetting: {\n\t\t\t\tname: 'Setting',\n\t\t\t\tpluralName: 'Settings',\n\t\t\t\tsyncable: false,\n\t\t\t\tfields: {\n\t\t\t\t\tid: {\n\t\t\t\t\t\tname: 'id',\n\t\t\t\t\t\ttype: 'ID',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t\tkey: {\n\t\t\t\t\t\tname: 'key',\n\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tname: 'value',\n\t\t\t\t\t\ttype: 'String',\n\t\t\t\t\t\tisRequired: true,\n\t\t\t\t\t\tisArray: false,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n\n\treturn namespace;\n}\n\nenum DataStoreState {\n\tNotRunning = 'Not Running',\n\tStarting = 'Starting',\n\tRunning = 'Running',\n\tStopping = 'Stopping',\n\tClearing = 'Clearing',\n}\n\nclass DataStore {\n\t// reference to configured category instances. Used for preserving SSR context\n\tprivate Auth = Auth;\n\tprivate API = API;\n\tprivate Cache = Cache;\n\n\t// Non-null assertions (bang operator) have been added to most of these properties\n\t// to make TS happy. These properties are all expected to be set immediately after\n\t// construction.\n\n\t// TODO: Refactor to use proper DI if possible. If not possible, change these to\n\t// optionals and implement conditional checks throughout. Rinse/repeat on all\n\t// sync engine processors, storage engine, adapters, etc..\n\n\tprivate amplifyConfig: Record<string, any> = {};\n\tprivate authModeStrategy!: AuthModeStrategy;\n\tprivate conflictHandler!: ConflictHandler;\n\tprivate errorHandler!: (error: SyncError<PersistentModel>) => void;\n\tprivate fullSyncInterval!: number;\n\tprivate initialized?: Promise<void>;\n\tprivate initReject!: Function;\n\tprivate initResolve!: Function;\n\tprivate maxRecordsToSync!: number;\n\tprivate storage?: Storage;\n\tprivate sync?: SyncEngine;\n\tprivate syncPageSize!: number;\n\tprivate syncExpressions!: SyncExpression[];\n\tprivate syncPredicates: WeakMap<SchemaModel, ModelPredicate<any>> =\n\t\tnew WeakMap<SchemaModel, ModelPredicate<any>>();\n\tprivate sessionId?: string;\n\tprivate storageAdapter!: Adapter;\n\t// object that gets passed to descendent classes. Allows us to pass these down by reference\n\tprivate amplifyContext: AmplifyContext = {\n\t\tAuth: this.Auth,\n\t\tAPI: this.API,\n\t\tCache: this.Cache,\n\t};\n\tprivate connectivityMonitor?: DataStoreConnectivity;\n\n\t/**\n\t * **IMPORTANT!**\n\t *\n\t * Accumulator for background things that can **and MUST** be called when\n\t * DataStore stops.\n\t *\n\t * These jobs **MUST** be *idempotent promises* that resolve ONLY\n\t * once the intended jobs are completely finished and/or otherwise destroyed\n\t * and cleaned up with ZERO outstanding:\n\t *\n\t * 1. side effects (e.g., state changes)\n\t * 1. callbacks\n\t * 1. subscriptions\n\t * 1. calls to storage\n\t * 1. *etc.*\n\t *\n\t * Methods that create pending promises, subscriptions, callbacks, or any\n\t * type of side effect **MUST** be registered with the manager. And, a new\n\t * manager must be created after each `exit()`.\n\t *\n\t * Failure to comply will put DataStore into a highly unpredictable state\n\t * when it needs to stop or clear -- which occurs when restarting with new\n\t * sync expressions, during testing, and potentially during app code\n\t * recovery handling, etc..\n\t *\n\t * It is up to the discretion of each disposer whether to wait for job\n\t * completion or to cancel operations and issue failures *as long as the\n\t * disposer returns in a reasonable amount of time.*\n\t *\n\t * (Reasonable = *seconds*, not minutes.)\n\t */\n\tprivate runningProcesses = new BackgroundProcessManager();\n\n\t/**\n\t * Indicates what state DataStore is in.\n\t *\n\t * Not [yet?] used for actual state management; but for messaging\n\t * when errors occur, to help troubleshoot.\n\t */\n\tprivate state: DataStoreState = DataStoreState.NotRunning;\n\n\tgetModuleName() {\n\t\treturn 'DataStore';\n\t}\n\n\t/**\n\t * Builds a function to capture `BackgroundManagerNotOpenError`'s to produce friendlier,\n\t * more instructive errors for customers.\n\t *\n\t * @param operation The name of the operation (usually a Datastore method) the customer\n\t * tried to call.\n\t */\n\thandleAddProcError(operation: string) {\n\t\t/**\n\t\t * If the tested error is a `BackgroundManagerNotOpenError`, it will be captured\n\t\t * and replaced with a friendlier message that instructs the App Developer.\n\t\t *\n\t\t * @param err An error to test.\n\t\t */\n\t\tconst handler = (err: Error) => {\n\t\t\tif (err.message.startsWith('BackgroundManagerNotOpenError')) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t[\n\t\t\t\t\t\t`DataStoreStateError: Tried to execute \\`${operation}\\` while DataStore was \"${this.state}\".`,\n\t\t\t\t\t\t`This can only be done while DataStore is \"Started\" or \"Stopped\". To remedy:`,\n\t\t\t\t\t\t'Ensure all calls to `stop()` and `clear()` have completed first.',\n\t\t\t\t\t\t'If this is not possible, retry the operation until it succeeds.',\n\t\t\t\t\t].join('\\n')\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t};\n\n\t\treturn handler;\n\t}\n\n\t/**\n\t * If not already done:\n\t * 1. Attaches and initializes storage.\n\t * 1. Loads the schema and records metadata.\n\t * 1. If `this.amplifyConfig.aws_appsync_graphqlEndpoint` contains a URL,\n\t * attaches a sync engine, starts it, and subscribes.\n\t */\n\tstart = async (): Promise<void> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tthis.state = DataStoreState.Starting;\n\t\t\t\tif (this.initialized === undefined) {\n\t\t\t\t\tlogger.debug('Starting DataStore');\n\t\t\t\t\tthis.initialized = new Promise((res, rej) => {\n\t\t\t\t\t\tthis.initResolve = res;\n\t\t\t\t\t\tthis.initReject = rej;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait this.initialized;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.storage = new Storage(\n\t\t\t\t\tschema,\n\t\t\t\t\tnamespaceResolver,\n\t\t\t\t\tgetModelConstructorByModelName,\n\t\t\t\t\tmodelInstanceCreator,\n\t\t\t\t\tthis.storageAdapter,\n\t\t\t\t\tthis.sessionId\n\t\t\t\t);\n\n\t\t\t\tawait this.storage.init();\n\t\t\t\tcheckSchemaInitialized();\n\t\t\t\tawait checkSchemaVersion(this.storage, schema.version);\n\t\t\t\tconst { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n\n\t\t\t\tif (aws_appsync_graphqlEndpoint) {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t'GraphQL endpoint available',\n\t\t\t\t\t\taws_appsync_graphqlEndpoint\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.syncPredicates = await this.processSyncExpressions();\n\n\t\t\t\t\tthis.sync = new SyncEngine(\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tnamespaceResolver,\n\t\t\t\t\t\tsyncClasses,\n\t\t\t\t\t\tuserClasses,\n\t\t\t\t\t\tthis.storage,\n\t\t\t\t\t\tmodelInstanceCreator,\n\t\t\t\t\t\tthis.conflictHandler,\n\t\t\t\t\t\tthis.errorHandler,\n\t\t\t\t\t\tthis.syncPredicates,\n\t\t\t\t\t\tthis.amplifyConfig,\n\t\t\t\t\t\tthis.authModeStrategy,\n\t\t\t\t\t\tthis.amplifyContext,\n\t\t\t\t\t\tthis.connectivityMonitor\n\t\t\t\t\t);\n\n\t\t\t\t\tconst fullSyncIntervalInMilliseconds =\n\t\t\t\t\t\tthis.fullSyncInterval * 1000 * 60; // fullSyncInterval from param is in minutes\n\t\t\t\t\tsyncSubscription = this.sync\n\t\t\t\t\t\t.start({ fullSyncInterval: fullSyncIntervalInMilliseconds })\n\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\tnext: ({ type, data }) => {\n\t\t\t\t\t\t\t\t// In Node, we need to wait for queries to be synced to prevent returning empty arrays.\n\t\t\t\t\t\t\t\t// In the Browser, we can begin returning data once subscriptions are in place.\n\t\t\t\t\t\t\t\tconst readyType = isNode\n\t\t\t\t\t\t\t\t\t? ControlMessage.SYNC_ENGINE_SYNC_QUERIES_READY\n\t\t\t\t\t\t\t\t\t: ControlMessage.SYNC_ENGINE_STORAGE_SUBSCRIBED;\n\n\t\t\t\t\t\t\t\tif (type === readyType) {\n\t\t\t\t\t\t\t\t\tthis.initResolve();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tHub.dispatch('datastore', {\n\t\t\t\t\t\t\t\t\tevent: type,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: err => {\n\t\t\t\t\t\t\t\tlogger.warn('Sync error', err);\n\t\t\t\t\t\t\t\tthis.initReject();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\"Data won't be synchronized. No GraphQL endpoint configured. Did you forget `Amplify.configure(awsconfig)`?\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconfig: this.amplifyConfig,\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.initResolve();\n\t\t\t\t}\n\n\t\t\t\tawait this.initialized;\n\t\t\t\tthis.state = DataStoreState.Running;\n\t\t\t}, 'datastore start')\n\t\t\t.catch(this.handleAddProcError('DataStore.start()'));\n\t};\n\n\tquery: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: IdentifierFieldOrIdentifierObject<\n\t\t\t\tT,\n\t\t\t\tPersistentModelMetaData<T>\n\t\t\t>\n\t\t): Promise<T | undefined>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?:\n\t\t\t\t| RecursiveModelPredicateExtender<T>\n\t\t\t\t| typeof PredicateAll\n\t\t\t\t| null,\n\t\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t\t): Promise<T[]>;\n\t} = async <T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| IdentifierFieldOrIdentifierObject<T, PersistentModelMetaData<T>>\n\t\t\t| RecursiveModelPredicateExtender<T>\n\t\t\t| typeof PredicateAll\n\t\t\t| null,\n\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t): Promise<T | T[] | undefined> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\tlet result: T[];\n\n\t\t\t\tif (!this.storage) {\n\t\t\t\t\tthrow new Error('No storage to query');\n\t\t\t\t}\n\n\t\t\t\t//#region Input validation\n\n\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\tconst msg = 'Constructor is not for a valid model';\n\t\t\t\t\tlogger.error(msg, { modelConstructor });\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tif (typeof identifierOrCriteria === 'string') {\n\t\t\t\t\tif (paginationProducer !== undefined) {\n\t\t\t\t\t\tlogger.warn('Pagination is ignored when querying by id');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\tthrow new Error('Invalid model definition provided!');\n\t\t\t\t}\n\n\t\t\t\tconst pagination = this.processPagination(\n\t\t\t\t\tmodelDefinition,\n\t\t\t\t\tpaginationProducer\n\t\t\t\t);\n\n\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\t\tif (isQueryOne(identifierOrCriteria)) {\n\t\t\t\t\tif (keyFields.length > 1) {\n\t\t\t\t\t\tconst msg = errorMessages.queryByPkWithCompositeKeyPresent;\n\t\t\t\t\t\tlogger.error(msg, { keyFields });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = ModelPredicateCreator.createForSingleField<T>(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tkeyFields[0],\n\t\t\t\t\t\tidentifierOrCriteria\n\t\t\t\t\t);\n\n\t\t\t\t\tresult = await this.storage.query<T>(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tpredicate,\n\t\t\t\t\t\tpagination\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Object is being queried using object literal syntax\n\t\t\t\t\tif (isIdentifierObject(<T>identifierOrCriteria, modelDefinition)) {\n\t\t\t\t\t\tconst predicate = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t<T>identifierOrCriteria\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult = await this.storage.query<T>(\n\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\tpredicate,\n\t\t\t\t\t\t\tpagination\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t!identifierOrCriteria ||\n\t\t\t\t\t\tisPredicatesAll(identifierOrCriteria)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresult = await this.storage?.query<T>(\n\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tpagination\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst seedPredicate = recursivePredicateFor<T>({\n\t\t\t\t\t\t\tbuilder: modelConstructor,\n\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\tpkField: getModelPKFieldName(modelConstructor),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst predicate = internals(\n\t\t\t\t\t\t\t(identifierOrCriteria as RecursiveModelPredicateExtender<T>)(\n\t\t\t\t\t\t\t\tseedPredicate\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresult = (await predicate.fetch(this.storage)) as T[];\n\t\t\t\t\t\tresult = inMemoryPagination(result, pagination);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//#endregion\n\n\t\t\t\tconst returnOne =\n\t\t\t\t\tisQueryOne(identifierOrCriteria) ||\n\t\t\t\t\tisIdentifierObject(identifierOrCriteria, modelDefinition);\n\n\t\t\t\treturn attached(\n\t\t\t\t\treturnOne ? result[0] : result,\n\t\t\t\t\tModelAttachment.DataStore\n\t\t\t\t);\n\t\t\t}, 'datastore query')\n\t\t\t.catch(this.handleAddProcError('DataStore.query()'));\n\t};\n\n\tsave = async <T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicateExtender<T>\n\t): Promise<T> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\tif (!this.storage) {\n\t\t\t\t\tthrow new Error('No storage to save to');\n\t\t\t\t}\n\n\t\t\t\t// Immer patches for constructing a correct update mutation input\n\t\t\t\t// Allows us to only include changed fields for updates\n\t\t\t\tconst patchesTuple = modelPatchesMap.get(model);\n\n\t\t\t\tconst modelConstructor: PersistentModelConstructor<T> | undefined =\n\t\t\t\t\tmodel ? <PersistentModelConstructor<T>>model.constructor : undefined;\n\n\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\tconst msg = 'Object is not an instance of a valid model';\n\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\tthrow new Error('Model Definition could not be found for model');\n\t\t\t\t}\n\n\t\t\t\tconst modelMeta = {\n\t\t\t\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t};\n\n\t\t\t\tawait this.storage.runExclusive(async s => {\n\t\t\t\t\t// no enforcement for HAS_MANY on save, because the ~related~ entities\n\t\t\t\t\t// hold the FK in that case.\n\t\t\t\t\tconst nonHasManyRelationships = ModelRelationship.allFrom(\n\t\t\t\t\t\tmodelMeta\n\t\t\t\t\t).filter(r => r.type === 'BELONGS_TO');\n\t\t\t\t\tfor (const relationship of nonHasManyRelationships) {\n\t\t\t\t\t\tconst queryObject = relationship.createRemoteQueryObject(model);\n\t\t\t\t\t\tif (queryObject !== null) {\n\t\t\t\t\t\t\t// console.log({ queryObject });\n\t\t\t\t\t\t\tconst related = await s.query(\n\t\t\t\t\t\t\t\trelationship.remoteModelConstructor,\n\t\t\t\t\t\t\t\tModelPredicateCreator.createFromFlatEqualities(\n\t\t\t\t\t\t\t\t\trelationship.remoteDefinition!,\n\t\t\t\t\t\t\t\t\tqueryObject\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (related.length === 0) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t`Data integrity error. You tried to save a ${\n\t\t\t\t\t\t\t\t\t\t\tmodelDefinition.name\n\t\t\t\t\t\t\t\t\t\t} (${JSON.stringify(model)})`,\n\t\t\t\t\t\t\t\t\t\t`but the instance assigned to the \"${relationship.field}\" property`,\n\t\t\t\t\t\t\t\t\t\t`does not exist in the local database. If you're trying to create the related`,\n\t\t\t\t\t\t\t\t\t\t`\"${relationship.remoteDefinition?.name}\", you must save it independently first.`,\n\t\t\t\t\t\t\t\t\t].join(' ')\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst producedCondition = condition\n\t\t\t\t\t? internals(\n\t\t\t\t\t\t\tcondition(predicateFor(modelMeta))\n\t\t\t\t\t  ).toStoragePredicate<T>()\n\t\t\t\t\t: undefined;\n\n\t\t\t\tconst [savedModel] = await this.storage.runExclusive(async s => {\n\t\t\t\t\tconst saved = await s.save(\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tproducedCondition,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tpatchesTuple\n\t\t\t\t\t);\n\t\t\t\t\treturn s.query<T>(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tModelPredicateCreator.createForPk(modelDefinition, model)\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\treturn attached(savedModel, ModelAttachment.DataStore);\n\t\t\t}, 'datastore save')\n\t\t\t.catch(this.handleAddProcError('DataStore.save()'));\n\t};\n\n\tsetConflictHandler = (config: DataStoreConfig): ConflictHandler => {\n\t\tconst { DataStore: configDataStore } = config;\n\n\t\tconst conflictHandlerIsDefault: () => boolean = () =>\n\t\t\tthis.conflictHandler === defaultConflictHandler;\n\n\t\tif (configDataStore && configDataStore.conflictHandler) {\n\t\t\treturn configDataStore.conflictHandler;\n\t\t}\n\t\tif (conflictHandlerIsDefault() && config.conflictHandler) {\n\t\t\treturn config.conflictHandler;\n\t\t}\n\n\t\treturn this.conflictHandler || defaultConflictHandler;\n\t};\n\n\tsetErrorHandler = (config: DataStoreConfig): ErrorHandler => {\n\t\tconst { DataStore: configDataStore } = config;\n\n\t\tconst errorHandlerIsDefault: () => boolean = () =>\n\t\t\tthis.errorHandler === defaultErrorHandler;\n\n\t\tif (configDataStore && configDataStore.errorHandler) {\n\t\t\treturn configDataStore.errorHandler;\n\t\t}\n\t\tif (errorHandlerIsDefault() && config.errorHandler) {\n\t\t\treturn config.errorHandler;\n\t\t}\n\n\t\treturn this.errorHandler || defaultErrorHandler;\n\t};\n\n\tdelete: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: IdentifierFieldOrIdentifierObject<\n\t\t\t\tT,\n\t\t\t\tPersistentModelMetaData<T>\n\t\t\t>\n\t\t): Promise<T[]>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcondition: ModelPredicateExtender<T> | typeof PredicateAll\n\t\t): Promise<T[]>;\n\t\t<T extends PersistentModel>(\n\t\t\tmodel: T,\n\t\t\tcondition?: ModelPredicateExtender<T>\n\t\t): Promise<T>;\n\t} = async <T extends PersistentModel>(\n\t\tmodelOrConstructor: T | PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| IdentifierFieldOrIdentifierObject<T, PersistentModelMetaData<T>>\n\t\t\t| ModelPredicateExtender<T>\n\t\t\t| typeof PredicateAll\n\t): Promise<T | T[]> => {\n\t\treturn this.runningProcesses\n\t\t\t.add(async () => {\n\t\t\t\tawait this.start();\n\n\t\t\t\tif (!this.storage) {\n\t\t\t\t\tthrow new Error('No storage to delete from');\n\t\t\t\t}\n\n\t\t\t\tlet condition: ModelPredicate<T> | undefined;\n\n\t\t\t\tif (!modelOrConstructor) {\n\t\t\t\t\tconst msg = 'Model or Model Constructor required';\n\t\t\t\t\tlogger.error(msg, { modelOrConstructor });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\n\t\t\t\tif (isValidModelConstructor<T>(modelOrConstructor)) {\n\t\t\t\t\tconst modelConstructor = modelOrConstructor;\n\n\t\t\t\t\tif (!identifierOrCriteria) {\n\t\t\t\t\t\tconst msg =\n\t\t\t\t\t\t\t'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n\t\t\t\t\t\tlogger.error(msg, { identifierOrCriteria });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Could not find model definition for modelConstructor.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof identifierOrCriteria === 'string') {\n\t\t\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n\n\t\t\t\t\t\tif (keyFields.length > 1) {\n\t\t\t\t\t\t\tconst msg = errorMessages.deleteByPkWithCompositeKeyPresent;\n\t\t\t\t\t\t\tlogger.error(msg, { keyFields });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcondition = ModelPredicateCreator.createForSingleField<T>(\n\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\tkeyFields[0],\n\t\t\t\t\t\t\tidentifierOrCriteria\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isIdentifierObject(identifierOrCriteria, modelDefinition)) {\n\t\t\t\t\t\t\tcondition = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t<T>identifierOrCriteria\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcondition = internals(\n\t\t\t\t\t\t\t\t(identifierOrCriteria as ModelPredicateExtender<T>)(\n\t\t\t\t\t\t\t\t\tpredicateFor({\n\t\t\t\t\t\t\t\t\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t).toStoragePredicate<T>();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!condition ||\n\t\t\t\t\t\t\t!ModelPredicateCreator.isValidPredicate(condition)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst msg =\n\t\t\t\t\t\t\t\t'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n\t\t\t\t\t\t\tlogger.error(msg, { condition });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [deleted] = await this.storage.delete(\n\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\t\treturn attached(deleted, ModelAttachment.DataStore);\n\t\t\t\t} else {\n\t\t\t\t\tconst model = modelOrConstructor;\n\t\t\t\t\tconst modelConstructor = Object.getPrototypeOf(model || {})\n\t\t\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\n\t\t\t\t\tif (!isValidModelConstructor(modelConstructor)) {\n\t\t\t\t\t\tconst msg = 'Object is not an instance of a valid model';\n\t\t\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor);\n\n\t\t\t\t\tif (!modelDefinition) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Could not find model definition for modelConstructor.'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pkPredicate = ModelPredicateCreator.createForPk<T>(\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tmodel\n\t\t\t\t\t);\n\n\t\t\t\t\tif (identifierOrCriteria) {\n\t\t\t\t\t\tif (typeof identifierOrCriteria !== 'function') {\n\t\t\t\t\t\t\tconst msg = 'Invalid criteria';\n\t\t\t\t\t\t\tlogger.error(msg, { identifierOrCriteria });\n\n\t\t\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcondition = internals(\n\t\t\t\t\t\t\t(identifierOrCriteria as ModelPredicateExtender<T>)(\n\t\t\t\t\t\t\t\tpredicateFor({\n\t\t\t\t\t\t\t\t\tbuilder: modelConstructor as PersistentModelConstructor<T>,\n\t\t\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t).toStoragePredicate<T>(pkPredicate);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcondition = pkPredicate;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst [[deleted]] = await this.storage.delete(model, condition);\n\n\t\t\t\t\treturn attached(deleted, ModelAttachment.DataStore);\n\t\t\t\t}\n\t\t\t}, 'datastore delete')\n\t\t\t.catch(this.handleAddProcError('DataStore.delete()'));\n\t};\n\n\tobserve: {\n\t\t(): Observable<SubscriptionMessage<PersistentModel>>;\n\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tidentifier: string\n\t\t): Observable<SubscriptionMessage<T>>;\n\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?: RecursiveModelPredicateExtender<T> | typeof PredicateAll\n\t\t): Observable<SubscriptionMessage<T>>;\n\n\t\t<T extends PersistentModel>(model: T): Observable<SubscriptionMessage<T>>;\n\t} = <T extends PersistentModel>(\n\t\tmodelOrConstructor?: T | PersistentModelConstructor<T>,\n\t\tidentifierOrCriteria?:\n\t\t\t| string\n\t\t\t| RecursiveModelPredicateExtender<T>\n\t\t\t| typeof PredicateAll\n\t): Observable<SubscriptionMessage<T>> => {\n\t\tlet executivePredicate: GroupCondition;\n\n\t\tconst modelConstructor: PersistentModelConstructor<T> | undefined =\n\t\t\tmodelOrConstructor && isValidModelConstructor<T>(modelOrConstructor)\n\t\t\t\t? modelOrConstructor\n\t\t\t\t: undefined;\n\n\t\tif (modelOrConstructor && modelConstructor === undefined) {\n\t\t\tconst model = <T>modelOrConstructor;\n\t\t\tconst modelConstructor =\n\t\t\t\tmodel && (<Object>Object.getPrototypeOf(model)).constructor;\n\n\t\t\tif (isValidModelConstructor<T>(modelConstructor)) {\n\t\t\t\tif (identifierOrCriteria) {\n\t\t\t\t\tlogger.warn('idOrCriteria is ignored when using a model instance', {\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tidentifierOrCriteria,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn this.observe(modelConstructor, model.id);\n\t\t\t} else {\n\t\t\t\tconst msg =\n\t\t\t\t\t'The model is not an instance of a PersistentModelConstructor';\n\t\t\t\tlogger.error(msg, { model });\n\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\t\t}\n\n\t\t// observe should not accept object literal syntax\n\t\tif (\n\t\t\tidentifierOrCriteria &&\n\t\t\tmodelConstructor &&\n\t\t\tisIdentifierObject(\n\t\t\t\tidentifierOrCriteria,\n\t\t\t\tgetModelDefinition(modelConstructor!)!\n\t\t\t)\n\t\t) {\n\t\t\tconst msg = errorMessages.observeWithObjectLiteral;\n\t\t\tlogger.error(msg, { objectLiteral: identifierOrCriteria });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (identifierOrCriteria !== undefined && modelConstructor === undefined) {\n\t\t\tconst msg = 'Cannot provide criteria without a modelConstructor';\n\t\t\tlogger.error(msg, identifierOrCriteria);\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n\t\t\tconst msg = 'Constructor is not for a valid model';\n\t\t\tlogger.error(msg, { modelConstructor });\n\n\t\t\tthrow new Error(msg);\n\t\t}\n\n\t\tif (modelConstructor && typeof identifierOrCriteria === 'string') {\n\t\t\tconst buildIdPredicate = seed => seed.id.eq(identifierOrCriteria);\n\t\t\texecutivePredicate = internals(\n\t\t\t\tbuildIdPredicate(buildSeedPredicate(modelConstructor))\n\t\t\t);\n\t\t} else if (modelConstructor && typeof identifierOrCriteria === 'function') {\n\t\t\texecutivePredicate = internals(\n\t\t\t\t(identifierOrCriteria as RecursiveModelPredicateExtender<T>)(\n\t\t\t\t\tbuildSeedPredicate(modelConstructor) as any\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn new Observable<SubscriptionMessage<T>>(observer => {\n\t\t\tlet source: ZenObservable.Subscription;\n\n\t\t\tthis.runningProcesses\n\t\t\t\t.add(async () => {\n\t\t\t\t\tawait this.start();\n\n\t\t\t\t\t// Filter the events returned by Storage according to namespace,\n\t\t\t\t\t// append original element data, and subscribe to the observable\n\t\t\t\t\tsource = this.storage!.observe(modelConstructor)\n\t\t\t\t\t\t.filter(({ model }) => namespaceResolver(model) === USER)\n\t\t\t\t\t\t.subscribe({\n\t\t\t\t\t\t\tnext: item =>\n\t\t\t\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\t\t// the `element` doesn't necessarily contain all item details or\n\t\t\t\t\t\t\t\t\t// have related records attached consistently with that of a query()\n\t\t\t\t\t\t\t\t\t// result item. for consistency, we attach them here.\n\n\t\t\t\t\t\t\t\t\tlet message = item;\n\n\t\t\t\t\t\t\t\t\t// as long as we're not dealing with a DELETE, we need to fetch a fresh\n\t\t\t\t\t\t\t\t\t// item from storage to ensure it's fully populated.\n\t\t\t\t\t\t\t\t\tif (item.opType !== 'DELETE') {\n\t\t\t\t\t\t\t\t\t\tconst modelDefinition = getModelDefinition(item.model);\n\t\t\t\t\t\t\t\t\t\tconst keyFields = extractPrimaryKeyFieldNames(\n\t\t\t\t\t\t\t\t\t\t\tmodelDefinition!\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst primaryKeysAndValues = extractPrimaryKeysAndValues(\n\t\t\t\t\t\t\t\t\t\t\titem.element,\n\t\t\t\t\t\t\t\t\t\t\tkeyFields\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst freshElement = await this.query(\n\t\t\t\t\t\t\t\t\t\t\titem.model,\n\t\t\t\t\t\t\t\t\t\t\tprimaryKeysAndValues\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tmessage = {\n\t\t\t\t\t\t\t\t\t\t\t...message,\n\t\t\t\t\t\t\t\t\t\t\telement: freshElement as T,\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!executivePredicate ||\n\t\t\t\t\t\t\t\t\t\t(await executivePredicate.matches(message.element))\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tobserver.next(message as SubscriptionMessage<T>);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, 'datastore observe message handler'),\n\t\t\t\t\t\t\terror: err => observer.error(err),\n\t\t\t\t\t\t\tcomplete: () => observer.complete(),\n\t\t\t\t\t\t});\n\t\t\t\t}, 'datastore observe observable initialization')\n\t\t\t\t.catch(this.handleAddProcError('DataStore.observe()'))\n\t\t\t\t.catch(error => {\n\t\t\t\t\tobserver.error(error);\n\t\t\t\t});\n\n\t\t\t// better than no cleaner, but if the subscriber is handling the\n\t\t\t// complete() message async and not registering with the context,\n\t\t\t// this will still be problematic.\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tif (source) {\n\t\t\t\t\tsource.unsubscribe();\n\t\t\t\t}\n\t\t\t}, 'DataStore.observe() cleanup');\n\t\t});\n\t};\n\n\tobserveQuery: {\n\t\t<T extends PersistentModel>(\n\t\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\t\tcriteria?: RecursiveModelPredicateExtender<T> | typeof PredicateAll,\n\t\t\tpaginationProducer?: ObserveQueryOptions<T>\n\t\t): Observable<DataStoreSnapshot<T>>;\n\t} = <T extends PersistentModel>(\n\t\tmodel: PersistentModelConstructor<T>,\n\t\tcriteria?: RecursiveModelPredicateExtender<T> | typeof PredicateAll,\n\t\toptions?: ObserveQueryOptions<T>\n\t): Observable<DataStoreSnapshot<T>> => {\n\t\treturn new Observable<DataStoreSnapshot<T>>(observer => {\n\t\t\tconst items = new Map<string, T>();\n\t\t\tconst itemsChanged = new Map<string, T>();\n\t\t\tlet deletedItemIds: string[] = [];\n\t\t\tlet handle: ZenObservable.Subscription;\n\t\t\t// let predicate: ModelPredicate<T> | undefined;\n\t\t\tlet executivePredicate: GroupCondition | undefined;\n\n\t\t\t/**\n\t\t\t * As the name suggests, this geneates a snapshot in the form of\n\t\t\t * \t`{items: T[], isSynced: boolean}`\n\t\t\t * and sends it to the observer.\n\t\t\t *\n\t\t\t * SIDE EFFECT: The underlying generation and emission methods may touch:\n\t\t\t * `items`, `itemsChanged`, and `deletedItemIds`.\n\t\t\t *\n\t\t\t * Refer to `generateSnapshot` and `emitSnapshot` for more details.\n\t\t\t */\n\t\t\tconst generateAndEmitSnapshot = (): void => {\n\t\t\t\tconst snapshot = generateSnapshot();\n\t\t\t\temitSnapshot(snapshot);\n\t\t\t};\n\n\t\t\t// a mechanism to return data after X amount of seconds OR after the\n\t\t\t// \"limit\" (itemsChanged >= this.syncPageSize) has been reached, whichever comes first\n\t\t\tconst limitTimerRace = new DeferredCallbackResolver({\n\t\t\t\tcallback: generateAndEmitSnapshot,\n\t\t\t\terrorHandler: observer.error,\n\t\t\t\tmaxInterval: 2000,\n\t\t\t});\n\n\t\t\tconst { sort } = options || {};\n\t\t\tconst sortOptions = sort ? { sort } : undefined;\n\n\t\t\tconst modelDefinition = getModelDefinition(model);\n\t\t\tif (!modelDefinition) {\n\t\t\t\tthrow new Error('Could not find model definition.');\n\t\t\t}\n\n\t\t\tif (model && typeof criteria === 'function') {\n\t\t\t\texecutivePredicate = internals(\n\t\t\t\t\t(criteria as RecursiveModelPredicateExtender<T>)(\n\t\t\t\t\t\tbuildSeedPredicate(model)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else if (isPredicatesAll(criteria)) {\n\t\t\t\texecutivePredicate = undefined;\n\t\t\t}\n\n\t\t\tthis.runningProcesses\n\t\t\t\t.add(async () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// first, query and return any locally-available records\n\t\t\t\t\t\t(await this.query(model, criteria, sortOptions)).forEach(item => {\n\t\t\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model);\n\t\t\t\t\t\t\tconst idOrPk = getIdentifierValue(itemModelDefinition!, item);\n\t\t\t\t\t\t\titems.set(idOrPk, item);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Observe the model and send a stream of updates (debounced).\n\t\t\t\t\t\t// We need to post-filter results instead of passing criteria through\n\t\t\t\t\t\t// to have visibility into items that move from in-set to out-of-set.\n\t\t\t\t\t\t// We need to explicitly remove those items from the existing snapshot.\n\t\t\t\t\t\thandle = this.observe(model).subscribe(\n\t\t\t\t\t\t\t({ element, model, opType }) =>\n\t\t\t\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t\t\t\tthis.runningProcesses.add(async () => {\n\t\t\t\t\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model)!;\n\t\t\t\t\t\t\t\t\tconst idOrPk = getIdentifierValue(\n\t\t\t\t\t\t\t\t\t\titemModelDefinition,\n\t\t\t\t\t\t\t\t\t\telement\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\texecutivePredicate &&\n\t\t\t\t\t\t\t\t\t\t!(await executivePredicate.matches(element))\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\topType === 'UPDATE' &&\n\t\t\t\t\t\t\t\t\t\t\t(items.has(idOrPk) || itemsChanged.has(idOrPk))\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t// tracking as a \"deleted item\" will include the item in\n\t\t\t\t\t\t\t\t\t\t\t// page limit calculations and ensure it is removed from the\n\t\t\t\t\t\t\t\t\t\t\t// final items collection, regardless of which collection(s)\n\t\t\t\t\t\t\t\t\t\t\t// it is currently in. (I mean, it could be in both, right!?)\n\t\t\t\t\t\t\t\t\t\t\tdeletedItemIds.push(idOrPk);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// ignore updates for irrelevant/filtered items.\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Flag items which have been recently deleted\n\t\t\t\t\t\t\t\t\t// NOTE: Merging of separate operations to the same model instance is handled upstream\n\t\t\t\t\t\t\t\t\t// in the `mergePage` method within src/sync/merger.ts. The final state of a model instance\n\t\t\t\t\t\t\t\t\t// depends on the LATEST record (for a given id).\n\t\t\t\t\t\t\t\t\tif (opType === 'DELETE') {\n\t\t\t\t\t\t\t\t\t\tdeletedItemIds.push(idOrPk);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\titemsChanged.set(idOrPk, element);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst isSynced =\n\t\t\t\t\t\t\t\t\t\tthis.sync?.getModelSyncedStatus(model) ?? false;\n\n\t\t\t\t\t\t\t\t\tconst limit =\n\t\t\t\t\t\t\t\t\t\titemsChanged.size - deletedItemIds.length >=\n\t\t\t\t\t\t\t\t\t\tthis.syncPageSize;\n\n\t\t\t\t\t\t\t\t\tif (limit || isSynced) {\n\t\t\t\t\t\t\t\t\t\tlimitTimerRace.resolve();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// kicks off every subsequent race as results sync down\n\t\t\t\t\t\t\t\t\tlimitTimerRace.start();\n\t\t\t\t\t\t\t\t}, 'handle observeQuery observed event')\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// returns a set of initial/locally-available results\n\t\t\t\t\t\tgenerateAndEmitSnapshot();\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tobserver.error(err);\n\t\t\t\t\t}\n\t\t\t\t}, 'datastore observequery startup')\n\t\t\t\t.catch(this.handleAddProcError('DataStore.observeQuery()'))\n\t\t\t\t.catch(error => {\n\t\t\t\t\tobserver.error(error);\n\t\t\t\t});\n\n\t\t\t/**\n\t\t\t * Combines the `items`, `itemsChanged`, and `deletedItemIds` collections into\n\t\t\t * a snapshot in the form of `{ items: T[], isSynced: boolean}`.\n\t\t\t *\n\t\t\t * SIDE EFFECT: The shared `items` collection is recreated.\n\t\t\t */\n\t\t\tconst generateSnapshot = (): DataStoreSnapshot<T> => {\n\t\t\t\tconst isSynced = this.sync?.getModelSyncedStatus(model) ?? false;\n\t\t\t\tconst itemsArray = [\n\t\t\t\t\t...Array.from(items.values()),\n\t\t\t\t\t...Array.from(itemsChanged.values()),\n\t\t\t\t];\n\n\t\t\t\tif (options?.sort) {\n\t\t\t\t\tsortItems(itemsArray);\n\t\t\t\t}\n\n\t\t\t\titems.clear();\n\t\t\t\titemsArray.forEach(item => {\n\t\t\t\t\tconst itemModelDefinition = getModelDefinition(model);\n\t\t\t\t\tconst idOrPk = getIdentifierValue(itemModelDefinition!, item);\n\t\t\t\t\titems.set(idOrPk, item);\n\t\t\t\t});\n\n\t\t\t\t// remove deleted items from the final result set\n\t\t\t\tdeletedItemIds.forEach(idOrPk => items.delete(idOrPk));\n\n\t\t\t\treturn {\n\t\t\t\t\titems: Array.from(items.values()),\n\t\t\t\t\tisSynced,\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Emits the list of items to the observer.\n\t\t\t *\n\t\t\t * SIDE EFFECT: `itemsChanged` and `deletedItemIds` are cleared to prepare\n\t\t\t * for the next snapshot.\n\t\t\t *\n\t\t\t * @param snapshot The generated items data to emit.\n\t\t\t */\n\t\t\tconst emitSnapshot = (snapshot: DataStoreSnapshot<T>): void => {\n\t\t\t\t// send the generated snapshot to the primary subscription.\n\t\t\t\t// NOTE: This observer's handler *could* be async ...\n\n\t\t\t\tobserver.next(snapshot);\n\n\t\t\t\t// reset the changed items sets\n\t\t\t\titemsChanged.clear();\n\t\t\t\tdeletedItemIds = [];\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Sorts an `Array` of `T` according to the sort instructions given in the\n\t\t\t * original  `observeQuery()` call.\n\t\t\t *\n\t\t\t * @param itemsToSort A array of model type.\n\t\t\t */\n\t\t\tconst sortItems = (itemsToSort: T[]): void => {\n\t\t\t\tconst modelDefinition = getModelDefinition(model);\n\t\t\t\tconst pagination = this.processPagination(modelDefinition!, options);\n\n\t\t\t\tconst sortPredicates = ModelSortPredicateCreator.getPredicates(\n\t\t\t\t\tpagination!.sort!\n\t\t\t\t);\n\n\t\t\t\tif (sortPredicates.length) {\n\t\t\t\t\tconst compareFn = sortCompareFunction(sortPredicates);\n\t\t\t\t\titemsToSort.sort(compareFn);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Force one last snapshot when the model is fully synced.\n\t\t\t *\n\t\t\t * This reduces latency for that last snapshot, which will otherwise\n\t\t\t * wait for the configured timeout.\n\t\t\t *\n\t\t\t * @param payload The payload from the Hub event.\n\t\t\t */\n\t\t\tconst hubCallback = ({ payload }): void => {\n\t\t\t\tconst { event, data } = payload;\n\t\t\t\tif (\n\t\t\t\t\tevent === ControlMessage.SYNC_ENGINE_MODEL_SYNCED &&\n\t\t\t\t\tdata?.model?.name === model.name\n\t\t\t\t) {\n\t\t\t\t\tgenerateAndEmitSnapshot();\n\t\t\t\t\tHub.remove('datastore', hubCallback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tHub.listen('datastore', hubCallback);\n\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.unsubscribe();\n\t\t\t\t}\n\t\t\t}, 'datastore observequery cleaner');\n\t\t});\n\t};\n\n\tconfigure = (config: DataStoreConfig = {}) => {\n\t\tthis.amplifyContext.Auth = this.Auth;\n\t\tthis.amplifyContext.API = this.API;\n\t\tthis.amplifyContext.Cache = this.Cache;\n\n\t\tconst {\n\t\t\tDataStore: configDataStore,\n\t\t\tauthModeStrategyType: configAuthModeStrategyType,\n\t\t\tconflictHandler: configConflictHandler,\n\t\t\terrorHandler: configErrorHandler,\n\t\t\tmaxRecordsToSync: configMaxRecordsToSync,\n\t\t\tsyncPageSize: configSyncPageSize,\n\t\t\tfullSyncInterval: configFullSyncInterval,\n\t\t\tsyncExpressions: configSyncExpressions,\n\t\t\tauthProviders: configAuthProviders,\n\t\t\tstorageAdapter: configStorageAdapter,\n\t\t\t...configFromAmplify\n\t\t} = config;\n\n\t\tthis.amplifyConfig = {\n\t\t\t...configFromAmplify,\n\t\t\t...this.amplifyConfig,\n\t\t};\n\n\t\tthis.conflictHandler = this.setConflictHandler(config);\n\t\tthis.errorHandler = this.setErrorHandler(config);\n\n\t\tconst authModeStrategyType =\n\t\t\t(configDataStore && configDataStore.authModeStrategyType) ||\n\t\t\tconfigAuthModeStrategyType ||\n\t\t\tAuthModeStrategyType.DEFAULT;\n\n\t\tswitch (authModeStrategyType) {\n\t\t\tcase AuthModeStrategyType.MULTI_AUTH:\n\t\t\t\tthis.authModeStrategy = multiAuthStrategy(this.amplifyContext);\n\t\t\t\tbreak;\n\t\t\tcase AuthModeStrategyType.DEFAULT:\n\t\t\t\tthis.authModeStrategy = defaultAuthStrategy;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.authModeStrategy = defaultAuthStrategy;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.authProviders =\n\t\t\t(configDataStore && configDataStore.authProviders) || configAuthProviders;\n\n\t\tthis.syncExpressions =\n\t\t\t(configDataStore && configDataStore.syncExpressions) ||\n\t\t\tconfigSyncExpressions ||\n\t\t\tthis.syncExpressions;\n\n\t\tthis.maxRecordsToSync =\n\t\t\t(configDataStore && configDataStore.maxRecordsToSync) ||\n\t\t\tconfigMaxRecordsToSync ||\n\t\t\tthis.maxRecordsToSync ||\n\t\t\t10000;\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.maxRecordsToSync = this.maxRecordsToSync;\n\n\t\tthis.syncPageSize =\n\t\t\t(configDataStore && configDataStore.syncPageSize) ||\n\t\t\tconfigSyncPageSize ||\n\t\t\tthis.syncPageSize ||\n\t\t\t1000;\n\n\t\t// store on config object, so that Sync, Subscription, and Mutation processors can have access\n\t\tthis.amplifyConfig.syncPageSize = this.syncPageSize;\n\n\t\tthis.fullSyncInterval =\n\t\t\t(configDataStore && configDataStore.fullSyncInterval) ||\n\t\t\tconfigFullSyncInterval ||\n\t\t\tthis.fullSyncInterval ||\n\t\t\t24 * 60; // 1 day\n\n\t\tthis.storageAdapter =\n\t\t\t(configDataStore && configDataStore.storageAdapter) ||\n\t\t\tconfigStorageAdapter ||\n\t\t\tthis.storageAdapter ||\n\t\t\tundefined;\n\n\t\tthis.sessionId = this.retrieveSessionId()!;\n\t};\n\n\t/**\n\t * Clears all data from storage and removes all data, schema info, other\n\t * initialization details, and then stops DataStore.\n\t *\n\t * That said, reinitialization is required after clearing. This can be done\n\t * by explicitiliy calling `start()` or any method that implicitly starts\n\t * DataStore, such as `query()`, `save()`, or `delete()`.\n\t */\n\tasync clear() {\n\t\tcheckSchemaInitialized();\n\t\tthis.state = DataStoreState.Clearing;\n\t\tawait this.runningProcesses.close();\n\t\tif (this.storage === undefined) {\n\t\t\t// connect to storage so that it can be cleared without fully starting DataStore\n\t\t\tthis.storage = new Storage(\n\t\t\t\tschema,\n\t\t\t\tnamespaceResolver,\n\t\t\t\tgetModelConstructorByModelName,\n\t\t\t\tmodelInstanceCreator,\n\t\t\t\tthis.storageAdapter,\n\t\t\t\tthis.sessionId\n\t\t\t);\n\t\t\tawait this.storage.init();\n\t\t}\n\n\t\tif (syncSubscription && !syncSubscription.closed) {\n\t\t\tsyncSubscription.unsubscribe();\n\t\t}\n\n\t\tif (this.sync) {\n\t\t\tawait this.sync.stop();\n\t\t}\n\n\t\tawait this.storage!.clear();\n\n\t\tthis.initialized = undefined; // Should re-initialize when start() is called.\n\t\tthis.storage = undefined;\n\t\tthis.sync = undefined;\n\t\tthis.syncPredicates = new WeakMap<SchemaModel, ModelPredicate<any>>();\n\n\t\tawait this.runningProcesses.open();\n\t\tthis.state = DataStoreState.NotRunning;\n\t}\n\n\t/**\n\t * Stops all DataStore sync activities.\n\t *\n\t * TODO: \"Waits for graceful termination of\n\t * running queries and terminates subscriptions.\"\n\t */\n\tasync stop(this: InstanceType<typeof DataStore>) {\n\t\tthis.state = DataStoreState.Stopping;\n\n\t\tawait this.runningProcesses.close();\n\n\t\tif (syncSubscription && !syncSubscription.closed) {\n\t\t\tsyncSubscription.unsubscribe();\n\t\t}\n\n\t\tif (this.sync) {\n\t\t\tawait this.sync.stop();\n\t\t}\n\n\t\tthis.initialized = undefined; // Should re-initialize when start() is called.\n\t\tthis.sync = undefined;\n\t\tawait this.runningProcesses.open();\n\t\tthis.state = DataStoreState.NotRunning;\n\t}\n\n\t/**\n\t * Validates given pagination input from a query and creates a pagination\n\t * argument for use against the storage layer.\n\t *\n\t * @param modelDefinition\n\t * @param paginationProducer\n\t */\n\tprivate processPagination<T extends PersistentModel>(\n\t\tmodelDefinition: SchemaModel,\n\t\tpaginationProducer?: ProducerPaginationInput<T>\n\t): PaginationInput<T> | undefined {\n\t\tlet sortPredicate: SortPredicate<T> | undefined;\n\t\tconst { limit, page, sort } = paginationProducer || {};\n\n\t\tif (limit === undefined && page === undefined && sort === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (page !== undefined && limit === undefined) {\n\t\t\tthrow new Error('Limit is required when requesting a page');\n\t\t}\n\n\t\tif (page !== undefined) {\n\t\t\tif (typeof page !== 'number') {\n\t\t\t\tthrow new Error('Page should be a number');\n\t\t\t}\n\n\t\t\tif (page < 0) {\n\t\t\t\tthrow new Error(\"Page can't be negative\");\n\t\t\t}\n\t\t}\n\n\t\tif (limit !== undefined) {\n\t\t\tif (typeof limit !== 'number') {\n\t\t\t\tthrow new Error('Limit should be a number');\n\t\t\t}\n\n\t\t\tif (limit < 0) {\n\t\t\t\tthrow new Error(\"Limit can't be negative\");\n\t\t\t}\n\t\t}\n\n\t\tif (sort) {\n\t\t\tsortPredicate = ModelSortPredicateCreator.createFromExisting(\n\t\t\t\tmodelDefinition,\n\t\t\t\tsort\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tlimit,\n\t\t\tpage,\n\t\t\tsort: sortPredicate,\n\t\t};\n\t}\n\n\t/**\n\t * Examines the configured `syncExpressions` and produces a WeakMap of\n\t * SchemaModel -> predicate to use during sync.\n\t */\n\tprivate async processSyncExpressions(): Promise<\n\t\tWeakMap<SchemaModel, ModelPredicate<any>>\n\t> {\n\t\tif (!this.syncExpressions || !this.syncExpressions.length) {\n\t\t\treturn new WeakMap<SchemaModel, ModelPredicate<any>>();\n\t\t}\n\n\t\tconst syncPredicates = await Promise.all(\n\t\t\tthis.syncExpressions.map(\n\t\t\t\tasync (\n\t\t\t\t\tsyncExpression: SyncExpression\n\t\t\t\t): Promise<[SchemaModel, ModelPredicate<any>]> => {\n\t\t\t\t\tconst { modelConstructor, conditionProducer } = await syncExpression;\n\t\t\t\t\tconst modelDefinition = getModelDefinition(modelConstructor)!;\n\n\t\t\t\t\t// conditionProducer is either a predicate, e.g. (c) => c.field.eq(1)\n\t\t\t\t\t// OR a function/promise that returns a predicate\n\t\t\t\t\tconst condition = await this.unwrapPromise(conditionProducer);\n\t\t\t\t\tif (isPredicatesAll(condition)) {\n\t\t\t\t\t\treturn [modelDefinition as any, null as any];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = internals(\n\t\t\t\t\t\tcondition(\n\t\t\t\t\t\t\tpredicateFor({\n\t\t\t\t\t\t\t\tbuilder: modelConstructor,\n\t\t\t\t\t\t\t\tschema: modelDefinition,\n\t\t\t\t\t\t\t\tpkField: extractPrimaryKeyFieldNames(modelDefinition),\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\t\t\t\t\t).toStoragePredicate<any>();\n\n\t\t\t\t\treturn [modelDefinition as any, predicate as any];\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\n\t\treturn this.weakMapFromEntries(syncPredicates);\n\t}\n\n\tprivate createFromCondition(\n\t\tmodelDefinition: SchemaModel,\n\t\tcondition: ProducerModelPredicate<PersistentModel>\n\t) {\n\t\ttry {\n\t\t\treturn ModelPredicateCreator.createFromExisting(\n\t\t\t\tmodelDefinition,\n\t\t\t\tcondition\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tlogger.error('Error creating Sync Predicate');\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate async unwrapPromise<T extends PersistentModel>(\n\t\tconditionProducer\n\t): Promise<ModelPredicateExtender<T>> {\n\t\ttry {\n\t\t\tconst condition = await conditionProducer();\n\t\t\treturn condition || conditionProducer;\n\t\t} catch (error) {\n\t\t\tif (error instanceof TypeError) {\n\t\t\t\treturn conditionProducer;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tprivate weakMapFromEntries(\n\t\tentries: [SchemaModel, ModelPredicate<any>][]\n\t): WeakMap<SchemaModel, ModelPredicate<any>> {\n\t\treturn entries.reduce((map, [modelDefinition, predicate]) => {\n\t\t\tif (map.has(modelDefinition)) {\n\t\t\t\tconst { name } = modelDefinition;\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`You can only utilize one Sync Expression per model.\n          Subsequent sync expressions for the ${name} model will be ignored.`\n\t\t\t\t);\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\tif (predicate) {\n\t\t\t\tmap.set(modelDefinition, predicate);\n\t\t\t}\n\n\t\t\treturn map;\n\t\t}, new WeakMap<SchemaModel, ModelPredicate<any>>());\n\t}\n\n\t/**\n\t * A session ID to allow CMS to open databases against multiple apps.\n\t * This session ID is only expected be set by AWS Amplify Studio.\n\t */\n\tprivate retrieveSessionId(): string | undefined {\n\t\ttry {\n\t\t\tconst sessionId = sessionStorage.getItem('datastoreSessionId');\n\n\t\t\tif (sessionId) {\n\t\t\t\tconst { aws_appsync_graphqlEndpoint } = this.amplifyConfig;\n\n\t\t\t\tconst appSyncUrl = aws_appsync_graphqlEndpoint.split('/')[2];\n\t\t\t\tconst [appSyncId] = appSyncUrl.split('.');\n\n\t\t\t\treturn `${sessionId}-${appSyncId}`;\n\t\t\t}\n\t\t} catch {}\n\n\t\treturn undefined;\n\t}\n}\n\nconst instance = new DataStore();\nAmplify.register(instance);\n\nexport { DataStore as DataStoreClass, initSchema, instance as DataStore };\n"]},"metadata":{},"sourceType":"module"}