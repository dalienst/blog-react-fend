{"ast":null,"code":"import { __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport * as idb from 'idb';\nimport { ModelPredicateCreator } from '../../predicates';\nimport { isPredicateObj, isPredicateGroup, OpType, QueryOne } from '../../types';\nimport { getIndex, getIndexFromAssociation, isModelConstructor, isPrivateMode, traverseModel, validatePredicate, inMemoryPagination, keysEqual, getStorename, getIndexKeys, extractPrimaryKeyValues, isSafariCompatabilityMode } from '../../util';\nvar logger = new Logger('DataStore');\nvar DB_NAME = 'amplify-datastore';\n\nvar IndexedDBAdapter =\n/** @class */\nfunction () {\n  function IndexedDBAdapter() {\n    var _this = this;\n\n    this.dbName = DB_NAME;\n    this.safariCompatabilityMode = false;\n    /**\n     * Checks the given path against the browser's IndexedDB implementation for\n     * necessary compatibility transformations, applying those transforms if needed.\n     *\n     * @param `keyArr` strings to compatibilize for browser-indexeddb index operations\n     * @returns An array or string, depending on and given key,\n     * that is ensured to be compatible with the IndexedDB implementation's nuances.\n     */\n\n    this.canonicalKeyPath = function (keyArr) {\n      if (_this.safariCompatabilityMode) {\n        return keyArr.length > 1 ? keyArr : keyArr[0];\n      }\n\n      return keyArr;\n    };\n  }\n\n  IndexedDBAdapter.prototype.getStorenameForModel = function (modelConstructor) {\n    var namespace = this.namespaceResolver(modelConstructor);\n    var modelName = modelConstructor.name;\n    return getStorename(namespace, modelName);\n  }; // Retrieves primary key values from a model\n\n\n  IndexedDBAdapter.prototype.getIndexKeyValuesFromModel = function (model) {\n    var modelConstructor = Object.getPrototypeOf(model).constructor;\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var keys = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n    return extractPrimaryKeyValues(model, keys);\n  };\n\n  IndexedDBAdapter.prototype.checkPrivate = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var isPrivate;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , isPrivateMode().then(function (isPrivate) {\n              return isPrivate;\n            })];\n\n          case 1:\n            isPrivate = _a.sent();\n\n            if (isPrivate) {\n              logger.error(\"IndexedDB not supported in this browser's private mode\");\n              return [2\n              /*return*/\n              , Promise.reject(\"IndexedDB not supported in this browser's private mode\")];\n            } else {\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Whether the browser's implementation of IndexedDB is coercing single-field\n   * indexes to a scalar key.\n   *\n   * If this returns `true`, we need to treat indexes containing a single field\n   * as scalars.\n   *\n   * See PR description for reference:\n   * https://github.com/aws-amplify/amplify-js/pull/10527\n   */\n\n\n  IndexedDBAdapter.prototype.setSafariCompatabilityMode = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this;\n            return [4\n            /*yield*/\n            , isSafariCompatabilityMode()];\n\n          case 1:\n            _a.safariCompatabilityMode = _b.sent();\n\n            if (this.safariCompatabilityMode === true) {\n              logger.debug('IndexedDB Adapter is running in Safari Compatability Mode');\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.getNamespaceAndModelFromStorename = function (storeName) {\n    var _a = __read(storeName.split('_')),\n        namespaceName = _a[0],\n        modelNameArr = _a.slice(1);\n\n    return {\n      namespaceName: namespaceName,\n      modelName: modelNameArr.join('_')\n    };\n  };\n\n  IndexedDBAdapter.prototype.setUp = function (theSchema, namespaceResolver, modelInstanceCreator, getModelConstructorByModelName, sessionId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var VERSION, _a, error_1;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.checkPrivate()];\n\n          case 1:\n            _b.sent();\n\n            return [4\n            /*yield*/\n            , this.setSafariCompatabilityMode()];\n\n          case 2:\n            _b.sent();\n\n            if (!!this.initPromise) return [3\n            /*break*/\n            , 3];\n            this.initPromise = new Promise(function (res, rej) {\n              _this.resolve = res;\n              _this.reject = rej;\n            });\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , this.initPromise];\n\n          case 4:\n            _b.sent();\n\n            _b.label = 5;\n\n          case 5:\n            if (sessionId) {\n              this.dbName = DB_NAME + \"-\" + sessionId;\n            }\n\n            this.schema = theSchema;\n            this.namespaceResolver = namespaceResolver;\n            this.modelInstanceCreator = modelInstanceCreator;\n            this.getModelConstructorByModelName = getModelConstructorByModelName;\n            _b.label = 6;\n\n          case 6:\n            _b.trys.push([6, 9,, 10]);\n\n            if (!!this.db) return [3\n            /*break*/\n            , 8];\n            VERSION = 3;\n            _a = this;\n            return [4\n            /*yield*/\n            , idb.openDB(this.dbName, VERSION, {\n              upgrade: function (db, oldVersion, newVersion, txn) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var _a, _b, storeName, origStore, tmpName, _c, namespaceName, modelName, modelInCurrentSchema, newStore, cursor, count, e_1_1, error_2;\n\n                  var e_1, _d;\n\n                  var _this = this;\n\n                  return __generator(this, function (_e) {\n                    switch (_e.label) {\n                      case 0:\n                        if (oldVersion === 0) {\n                          Object.keys(theSchema.namespaces).forEach(function (namespaceName) {\n                            var namespace = theSchema.namespaces[namespaceName];\n                            Object.keys(namespace.models).forEach(function (modelName) {\n                              var storeName = getStorename(namespaceName, modelName);\n\n                              _this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n                            });\n                          });\n                          return [2\n                          /*return*/\n                          ];\n                        }\n\n                        if (!((oldVersion === 1 || oldVersion === 2) && newVersion === 3)) return [3\n                        /*break*/\n                        , 16];\n                        _e.label = 1;\n\n                      case 1:\n                        _e.trys.push([1, 14,, 15]);\n\n                        _e.label = 2;\n\n                      case 2:\n                        _e.trys.push([2, 11, 12, 13]);\n\n                        _a = __values(txn.objectStoreNames), _b = _a.next();\n                        _e.label = 3;\n\n                      case 3:\n                        if (!!_b.done) return [3\n                        /*break*/\n                        , 10];\n                        storeName = _b.value;\n                        origStore = txn.objectStore(storeName);\n                        tmpName = \"tmp_\" + storeName;\n                        origStore.name = tmpName;\n                        _c = this.getNamespaceAndModelFromStorename(storeName), namespaceName = _c.namespaceName, modelName = _c.modelName;\n                        modelInCurrentSchema = modelName in this.schema.namespaces[namespaceName].models;\n\n                        if (!modelInCurrentSchema) {\n                          // delete original\n                          db.deleteObjectStore(tmpName);\n                          return [3\n                          /*break*/\n                          , 9];\n                        }\n\n                        newStore = this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n                        return [4\n                        /*yield*/\n                        , origStore.openCursor()];\n\n                      case 4:\n                        cursor = _e.sent();\n                        count = 0;\n                        _e.label = 5;\n\n                      case 5:\n                        if (!(cursor && cursor.value)) return [3\n                        /*break*/\n                        , 8]; // we don't pass key, since they are all new entries in the new store\n\n                        return [4\n                        /*yield*/\n                        , newStore.put(cursor.value)];\n\n                      case 6:\n                        // we don't pass key, since they are all new entries in the new store\n                        _e.sent();\n\n                        return [4\n                        /*yield*/\n                        , cursor.continue()];\n\n                      case 7:\n                        cursor = _e.sent();\n                        count++;\n                        return [3\n                        /*break*/\n                        , 5];\n\n                      case 8:\n                        // delete original\n                        db.deleteObjectStore(tmpName);\n                        logger.debug(count + \" \" + storeName + \" records migrated\");\n                        _e.label = 9;\n\n                      case 9:\n                        _b = _a.next();\n                        return [3\n                        /*break*/\n                        , 3];\n\n                      case 10:\n                        return [3\n                        /*break*/\n                        , 13];\n\n                      case 11:\n                        e_1_1 = _e.sent();\n                        e_1 = {\n                          error: e_1_1\n                        };\n                        return [3\n                        /*break*/\n                        , 13];\n\n                      case 12:\n                        try {\n                          if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\n                        } finally {\n                          if (e_1) throw e_1.error;\n                        }\n\n                        return [7\n                        /*endfinally*/\n                        ];\n\n                      case 13:\n                        // add new models created after IndexedDB, but before migration\n                        // this case may happen when a user has not opened an app for\n                        // some time and a new model is added during that time\n                        Object.keys(theSchema.namespaces).forEach(function (namespaceName) {\n                          var namespace = theSchema.namespaces[namespaceName];\n                          var objectStoreNames = new Set(txn.objectStoreNames);\n                          Object.keys(namespace.models).map(function (modelName) {\n                            return [modelName, getStorename(namespaceName, modelName)];\n                          }).filter(function (_a) {\n                            var _b = __read(_a, 2),\n                                storeName = _b[1];\n\n                            return !objectStoreNames.has(storeName);\n                          }).forEach(function (_a) {\n                            var _b = __read(_a, 2),\n                                modelName = _b[0],\n                                storeName = _b[1];\n\n                            _this.createObjectStoreForModel(db, namespaceName, storeName, modelName);\n                          });\n                        });\n                        return [3\n                        /*break*/\n                        , 15];\n\n                      case 14:\n                        error_2 = _e.sent();\n                        logger.error('Error migrating IndexedDB data', error_2);\n                        txn.abort();\n                        throw error_2;\n\n                      case 15:\n                        return [2\n                        /*return*/\n                        ];\n\n                      case 16:\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              }\n            })];\n\n          case 7:\n            _a.db = _b.sent();\n            this.resolve();\n            _b.label = 8;\n\n          case 8:\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            error_1 = _b.sent();\n            this.reject(error_1);\n            return [3\n            /*break*/\n            , 10];\n\n          case 10:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype._get = function (storeOrStoreName, keyArr) {\n    return __awaiter(this, void 0, void 0, function () {\n      var index, storeName, store, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (typeof storeOrStoreName === 'string') {\n              storeName = storeOrStoreName;\n              index = this.db.transaction(storeName, 'readonly').store.index('byPk');\n            } else {\n              store = storeOrStoreName;\n              index = store.index('byPk');\n            }\n\n            return [4\n            /*yield*/\n            , index.get(this.canonicalKeyPath(keyArr))];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.save = function (model, condition) {\n    var e_2, _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var modelConstructor, storeName, namespaceName, connectedModels, set, connectionStoreNames, tx, store, keyValues, fromDB, predicates, _b, predicateObjs, type, isValid, msg, result, connectionStoreNames_1, connectionStoreNames_1_1, resItem, storeName_1, item, instance, keys, store_1, itemKeyValues, fromDB_1, opType, modelKeyValues, key, e_2_1;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.checkPrivate()];\n\n          case 1:\n            _c.sent();\n\n            modelConstructor = Object.getPrototypeOf(model).constructor;\n            storeName = this.getStorenameForModel(modelConstructor);\n            namespaceName = this.namespaceResolver(modelConstructor);\n            connectedModels = traverseModel(modelConstructor.name, model, this.schema.namespaces[namespaceName], this.modelInstanceCreator, this.getModelConstructorByModelName);\n            set = new Set();\n            connectionStoreNames = Object.values(connectedModels).map(function (_a) {\n              var modelName = _a.modelName,\n                  item = _a.item,\n                  instance = _a.instance;\n              var storeName = getStorename(namespaceName, modelName);\n              set.add(storeName);\n              var keys = getIndexKeys(_this.schema.namespaces[namespaceName], modelName);\n              return {\n                storeName: storeName,\n                item: item,\n                instance: instance,\n                keys: keys\n              };\n            });\n            tx = this.db.transaction(__spread([storeName], Array.from(set.values())), 'readwrite');\n            store = tx.objectStore(storeName);\n            keyValues = this.getIndexKeyValuesFromModel(model);\n            return [4\n            /*yield*/\n            , this._get(store, keyValues)];\n\n          case 2:\n            fromDB = _c.sent();\n\n            if (condition && fromDB) {\n              predicates = ModelPredicateCreator.getPredicates(condition);\n              _b = predicates || {}, predicateObjs = _b.predicates, type = _b.type;\n              isValid = validatePredicate(fromDB, type, predicateObjs);\n\n              if (!isValid) {\n                msg = 'Conditional update failed';\n                logger.error(msg, {\n                  model: fromDB,\n                  condition: predicateObjs\n                });\n                throw new Error(msg);\n              }\n            }\n\n            result = [];\n            _c.label = 3;\n\n          case 3:\n            _c.trys.push([3, 11, 12, 17]);\n\n            connectionStoreNames_1 = __asyncValues(connectionStoreNames);\n            _c.label = 4;\n\n          case 4:\n            return [4\n            /*yield*/\n            , connectionStoreNames_1.next()];\n\n          case 5:\n            if (!(connectionStoreNames_1_1 = _c.sent(), !connectionStoreNames_1_1.done)) return [3\n            /*break*/\n            , 10];\n            resItem = connectionStoreNames_1_1.value;\n            storeName_1 = resItem.storeName, item = resItem.item, instance = resItem.instance, keys = resItem.keys;\n            store_1 = tx.objectStore(storeName_1);\n            itemKeyValues = keys.map(function (key) {\n              var value = item[key];\n              return value;\n            });\n            return [4\n            /*yield*/\n            , this._get(store_1, itemKeyValues)];\n\n          case 6:\n            fromDB_1 = _c.sent();\n            opType = fromDB_1 === undefined ? OpType.INSERT : OpType.UPDATE;\n            modelKeyValues = this.getIndexKeyValuesFromModel(model);\n            if (!(keysEqual(itemKeyValues, modelKeyValues) || opType === OpType.INSERT)) return [3\n            /*break*/\n            , 9];\n            return [4\n            /*yield*/\n            , store_1.index('byPk').getKey(this.canonicalKeyPath(itemKeyValues))];\n\n          case 7:\n            key = _c.sent();\n            return [4\n            /*yield*/\n            , store_1.put(item, key)];\n\n          case 8:\n            _c.sent();\n\n            result.push([instance, opType]);\n            _c.label = 9;\n\n          case 9:\n            return [3\n            /*break*/\n            , 4];\n\n          case 10:\n            return [3\n            /*break*/\n            , 17];\n\n          case 11:\n            e_2_1 = _c.sent();\n            e_2 = {\n              error: e_2_1\n            };\n            return [3\n            /*break*/\n            , 17];\n\n          case 12:\n            _c.trys.push([12,, 15, 16]);\n\n            if (!(connectionStoreNames_1_1 && !connectionStoreNames_1_1.done && (_a = connectionStoreNames_1.return))) return [3\n            /*break*/\n            , 14];\n            return [4\n            /*yield*/\n            , _a.call(connectionStoreNames_1)];\n\n          case 13:\n            _c.sent();\n\n            _c.label = 14;\n\n          case 14:\n            return [3\n            /*break*/\n            , 16];\n\n          case 15:\n            if (e_2) throw e_2.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 16:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 17:\n            return [4\n            /*yield*/\n            , tx.done];\n\n          case 18:\n            _c.sent();\n\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.load = function (namespaceName, srcModelName, records) {\n    return __awaiter(this, void 0, void 0, function () {\n      var namespace, relations, connectionStoreNames, modelConstructor;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        namespace = this.schema.namespaces[namespaceName];\n        relations = namespace.relationships[srcModelName].relationTypes;\n        connectionStoreNames = relations.map(function (_a) {\n          var modelName = _a.modelName;\n          return getStorename(namespaceName, modelName);\n        });\n        modelConstructor = this.getModelConstructorByModelName(namespaceName, srcModelName);\n\n        if (connectionStoreNames.length === 0) {\n          return [2\n          /*return*/\n          , records.map(function (record) {\n            return _this.modelInstanceCreator(modelConstructor, record);\n          })];\n        }\n\n        return [2\n        /*return*/\n        , records.map(function (record) {\n          return _this.modelInstanceCreator(modelConstructor, record);\n        })];\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.query = function (modelConstructor, predicate, pagination) {\n    return __awaiter(this, void 0, void 0, function () {\n      var storeName, namespaceName, predicates, keyPath, queryByKey, hasSort, hasPagination, records;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.checkPrivate()];\n\n          case 1:\n            _a.sent();\n\n            storeName = this.getStorenameForModel(modelConstructor);\n            namespaceName = this.namespaceResolver(modelConstructor);\n            predicates = predicate && ModelPredicateCreator.getPredicates(predicate);\n            keyPath = getIndexKeys(this.schema.namespaces[namespaceName], modelConstructor.name);\n            queryByKey = predicates && this.keyValueFromPredicate(predicates, keyPath);\n            hasSort = pagination && pagination.sort;\n            hasPagination = pagination && pagination.limit;\n            return [4\n            /*yield*/\n            , function () {\n              return __awaiter(_this, void 0, void 0, function () {\n                var record, filtered, all;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      if (!queryByKey) return [3\n                      /*break*/\n                      , 2];\n                      return [4\n                      /*yield*/\n                      , this.getByKey(storeName, queryByKey)];\n\n                    case 1:\n                      record = _a.sent();\n                      return [2\n                      /*return*/\n                      , record ? [record] : []];\n\n                    case 2:\n                      if (!predicates) return [3\n                      /*break*/\n                      , 4];\n                      return [4\n                      /*yield*/\n                      , this.filterOnPredicate(storeName, predicates)];\n\n                    case 3:\n                      filtered = _a.sent();\n                      return [2\n                      /*return*/\n                      , this.inMemoryPagination(filtered, pagination)];\n\n                    case 4:\n                      if (!hasSort) return [3\n                      /*break*/\n                      , 6];\n                      return [4\n                      /*yield*/\n                      , this.getAll(storeName)];\n\n                    case 5:\n                      all = _a.sent();\n                      return [2\n                      /*return*/\n                      , this.inMemoryPagination(all, pagination)];\n\n                    case 6:\n                      if (hasPagination) {\n                        return [2\n                        /*return*/\n                        , this.enginePagination(storeName, pagination)];\n                      }\n\n                      return [2\n                      /*return*/\n                      , this.getAll(storeName)];\n                  }\n                });\n              });\n            }()];\n\n          case 2:\n            records = _a.sent();\n            return [4\n            /*yield*/\n            , this.load(namespaceName, modelConstructor.name, records)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.getByKey = function (storeName, keyValue) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._get(storeName, keyValue)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.getAll = function (storeName) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.db.getAll(storeName)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.keyValueFromPredicate = function (predicates, keyPath) {\n    var e_3, _a;\n\n    var predicateObjs = predicates.predicates;\n\n    if (predicateObjs.length !== keyPath.length) {\n      return;\n    }\n\n    var keyValues = [];\n\n    var _loop_1 = function (key) {\n      var predicateObj = predicateObjs.find(function (p) {\n        return isPredicateObj(p) && p.field === key && p.operator === 'eq';\n      });\n      predicateObj && keyValues.push(predicateObj.operand);\n    };\n\n    try {\n      for (var keyPath_1 = __values(keyPath), keyPath_1_1 = keyPath_1.next(); !keyPath_1_1.done; keyPath_1_1 = keyPath_1.next()) {\n        var key = keyPath_1_1.value;\n\n        _loop_1(key);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (keyPath_1_1 && !keyPath_1_1.done && (_a = keyPath_1.return)) _a.call(keyPath_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return keyValues.length === keyPath.length ? keyValues : undefined;\n  };\n\n  IndexedDBAdapter.prototype.matchingIndex = function (storeName, fieldName, transaction) {\n    var e_4, _a;\n\n    var store = transaction.objectStore(storeName);\n\n    try {\n      for (var _b = __values(store.indexNames), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_1 = _c.value;\n        var idx = store.index(name_1);\n\n        if (idx.keyPath === fieldName) {\n          return idx;\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  };\n\n  IndexedDBAdapter.prototype.filterOnPredicate = function (storeName, predicates) {\n    return __awaiter(this, void 0, void 0, function () {\n      var predicateObjs, type, candidateResults, fieldPredicates, txn, predicateIndexes, actualPredicateIndexes, predicateIndex, distinctResults, predicateIndexes_1, predicateIndexes_1_1, predicateIndex, resultGroup, resultGroup_1, resultGroup_1_1, item, e_5_1, filtered;\n\n      var e_5, _a, e_6, _b;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            predicateObjs = predicates.predicates, type = predicates.type; // the predicate objects we care about tend to be nested at least\n            // one level down: `{and: {or: {and: { <the predicates we want> }}}}`\n            // so, we unpack and/or groups until we find a group with more than 1\n            // child OR a child that is not a group (and is therefore a predicate \"object\").\n\n            while (predicateObjs.length === 1 && isPredicateGroup(predicateObjs[0])) {\n              type = predicateObjs[0].type;\n              predicateObjs = predicateObjs[0].predicates;\n            }\n\n            fieldPredicates = predicateObjs.filter(function (p) {\n              return isPredicateObj(p);\n            });\n            txn = this.db.transaction(storeName);\n            predicateIndexes = fieldPredicates.map(function (p) {\n              return {\n                predicate: p,\n                index: _this.matchingIndex(storeName, String(p.field), txn)\n              };\n            }); // Explicitly wait for txns from index queries to complete before proceding.\n            // This helps ensure IndexedDB is in a stable, ready state. Else, subseqeuent\n            // qeuries can sometimes appear to deadlock (at least in FakeIndexedDB).\n\n            return [4\n            /*yield*/\n            , txn.done];\n\n          case 1:\n            // Explicitly wait for txns from index queries to complete before proceding.\n            // This helps ensure IndexedDB is in a stable, ready state. Else, subseqeuent\n            // qeuries can sometimes appear to deadlock (at least in FakeIndexedDB).\n            _c.sent();\n\n            if (!(type === 'and')) return [3\n            /*break*/\n            , 6];\n            actualPredicateIndexes = predicateIndexes.filter(function (i) {\n              return i.index && i.predicate.operator === 'eq';\n            });\n            if (!(actualPredicateIndexes.length > 0)) return [3\n            /*break*/\n            , 3];\n            predicateIndex = actualPredicateIndexes[0];\n            return [4\n            /*yield*/\n            , predicateIndex.index.getAll(predicateIndex.predicate.operand)];\n\n          case 2:\n            candidateResults = _c.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , this.getAll(storeName)];\n\n          case 4:\n            // no usable indexes\n            candidateResults = _c.sent();\n            _c.label = 5;\n\n          case 5:\n            return [3\n            /*break*/\n            , 20];\n\n          case 6:\n            if (!(type === 'or')) return [3\n            /*break*/\n            , 18];\n            if (!(predicateIndexes.length > 0 && predicateIndexes.every(function (i) {\n              return i.index && i.predicate.operator === 'eq';\n            }))) return [3\n            /*break*/\n            , 15];\n            distinctResults = new Map();\n            _c.label = 7;\n\n          case 7:\n            _c.trys.push([7, 12, 13, 14]);\n\n            predicateIndexes_1 = __values(predicateIndexes), predicateIndexes_1_1 = predicateIndexes_1.next();\n            _c.label = 8;\n\n          case 8:\n            if (!!predicateIndexes_1_1.done) return [3\n            /*break*/\n            , 11];\n            predicateIndex = predicateIndexes_1_1.value;\n            return [4\n            /*yield*/\n            , predicateIndex.index.getAll(predicateIndex.predicate.operand)];\n\n          case 9:\n            resultGroup = _c.sent();\n\n            try {\n              for (resultGroup_1 = (e_6 = void 0, __values(resultGroup)), resultGroup_1_1 = resultGroup_1.next(); !resultGroup_1_1.done; resultGroup_1_1 = resultGroup_1.next()) {\n                item = resultGroup_1_1.value; // TODO: custom PK\n\n                distinctResults.set(item.id, item);\n              }\n            } catch (e_6_1) {\n              e_6 = {\n                error: e_6_1\n              };\n            } finally {\n              try {\n                if (resultGroup_1_1 && !resultGroup_1_1.done && (_b = resultGroup_1.return)) _b.call(resultGroup_1);\n              } finally {\n                if (e_6) throw e_6.error;\n              }\n            }\n\n            _c.label = 10;\n\n          case 10:\n            predicateIndexes_1_1 = predicateIndexes_1.next();\n            return [3\n            /*break*/\n            , 8];\n\n          case 11:\n            return [3\n            /*break*/\n            , 14];\n\n          case 12:\n            e_5_1 = _c.sent();\n            e_5 = {\n              error: e_5_1\n            };\n            return [3\n            /*break*/\n            , 14];\n\n          case 13:\n            try {\n              if (predicateIndexes_1_1 && !predicateIndexes_1_1.done && (_a = predicateIndexes_1.return)) _a.call(predicateIndexes_1);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 14:\n            // we could conceivably check for special conditions and return early here.\n            // but, this is simpler and has not yet had a measurable performance impact.\n            candidateResults = Array.from(distinctResults.values());\n            return [3\n            /*break*/\n            , 17];\n\n          case 15:\n            return [4\n            /*yield*/\n            , this.getAll(storeName)];\n\n          case 16:\n            // either no usable indexes or not all conditions can use one.\n            candidateResults = _c.sent();\n            _c.label = 17;\n\n          case 17:\n            return [3\n            /*break*/\n            , 20];\n\n          case 18:\n            return [4\n            /*yield*/\n            , this.getAll(storeName)];\n\n          case 19:\n            // nothing intelligent we can do with `not` groups unless or until we start\n            // smashing comparison operators against indexes -- at which point we could\n            // perform some reversal here.\n            candidateResults = _c.sent();\n            _c.label = 20;\n\n          case 20:\n            filtered = predicateObjs ? candidateResults.filter(function (m) {\n              return validatePredicate(m, type, predicateObjs);\n            }) : candidateResults;\n            return [2\n            /*return*/\n            , filtered];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.inMemoryPagination = function (records, pagination) {\n    return inMemoryPagination(records, pagination);\n  };\n\n  IndexedDBAdapter.prototype.enginePagination = function (storeName, pagination) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, _a, page, _b, limit, initialRecord, cursor, pageResults, hasLimit;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!pagination) return [3\n            /*break*/\n            , 7];\n            _a = pagination.page, page = _a === void 0 ? 0 : _a, _b = pagination.limit, limit = _b === void 0 ? 0 : _b;\n            initialRecord = Math.max(0, page * limit) || 0;\n            return [4\n            /*yield*/\n            , this.db.transaction(storeName).objectStore(storeName).openCursor()];\n\n          case 1:\n            cursor = _c.sent();\n            if (!(cursor && initialRecord > 0)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , cursor.advance(initialRecord)];\n\n          case 2:\n            _c.sent();\n\n            _c.label = 3;\n\n          case 3:\n            pageResults = [];\n            hasLimit = typeof limit === 'number' && limit > 0;\n            _c.label = 4;\n\n          case 4:\n            if (!(cursor && cursor.value)) return [3\n            /*break*/\n            , 6];\n            pageResults.push(cursor.value);\n\n            if (hasLimit && pageResults.length === limit) {\n              return [3\n              /*break*/\n              , 6];\n            }\n\n            return [4\n            /*yield*/\n            , cursor.continue()];\n\n          case 5:\n            cursor = _c.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 6:\n            result = pageResults;\n            return [3\n            /*break*/\n            , 9];\n\n          case 7:\n            return [4\n            /*yield*/\n            , this.db.getAll(storeName)];\n\n          case 8:\n            result = _c.sent();\n            _c.label = 9;\n\n          case 9:\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.queryOne = function (modelConstructor, firstOrLast) {\n    if (firstOrLast === void 0) {\n      firstOrLast = QueryOne.FIRST;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var storeName, cursor, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.checkPrivate()];\n\n          case 1:\n            _a.sent();\n\n            storeName = this.getStorenameForModel(modelConstructor);\n            return [4\n            /*yield*/\n            , this.db.transaction([storeName], 'readonly').objectStore(storeName).openCursor(undefined, firstOrLast === QueryOne.FIRST ? 'next' : 'prev')];\n\n          case 2:\n            cursor = _a.sent();\n            result = cursor ? cursor.value : undefined;\n            return [2\n            /*return*/\n            , result && this.modelInstanceCreator(modelConstructor, result)];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.delete = function (modelOrModelConstructor, condition) {\n    return __awaiter(this, void 0, void 0, function () {\n      var deleteQueue, modelConstructor, nameSpace, storeName, models, relations, deletedModels, deletedModels, model, modelConstructor, namespaceName, storeName, tx, store, keyValues, fromDB, msg, predicates, _a, predicateObjs, type, isValid, msg, relations, relations, deletedModels;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.checkPrivate()];\n\n          case 1:\n            _b.sent();\n\n            deleteQueue = [];\n            if (!isModelConstructor(modelOrModelConstructor)) return [3\n            /*break*/\n            , 9];\n            modelConstructor = modelOrModelConstructor;\n            nameSpace = this.namespaceResolver(modelConstructor);\n            storeName = this.getStorenameForModel(modelConstructor);\n            return [4\n            /*yield*/\n            , this.query(modelConstructor, condition)];\n\n          case 2:\n            models = _b.sent();\n            relations = this.schema.namespaces[nameSpace].relationships[modelConstructor.name].relationTypes;\n            if (!(condition !== undefined)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.deleteTraverse(relations, models, modelConstructor.name, nameSpace, deleteQueue)];\n\n          case 3:\n            _b.sent();\n\n            return [4\n            /*yield*/\n            , this.deleteItem(deleteQueue)];\n\n          case 4:\n            _b.sent();\n\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2\n            /*return*/\n            , [models, deletedModels]];\n\n          case 5:\n            return [4\n            /*yield*/\n            , this.deleteTraverse(relations, models, modelConstructor.name, nameSpace, deleteQueue)];\n\n          case 6:\n            _b.sent(); // Delete all\n\n\n            return [4\n            /*yield*/\n            , this.db.transaction([storeName], 'readwrite').objectStore(storeName).clear()];\n\n          case 7:\n            // Delete all\n            _b.sent();\n\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2\n            /*return*/\n            , [models, deletedModels]];\n\n          case 8:\n            return [3\n            /*break*/\n            , 17];\n\n          case 9:\n            model = modelOrModelConstructor;\n            modelConstructor = Object.getPrototypeOf(model).constructor;\n            namespaceName = this.namespaceResolver(modelConstructor);\n            storeName = this.getStorenameForModel(modelConstructor);\n            if (!condition) return [3\n            /*break*/\n            , 13];\n            tx = this.db.transaction([storeName], 'readwrite');\n            store = tx.objectStore(storeName);\n            keyValues = this.getIndexKeyValuesFromModel(model);\n            return [4\n            /*yield*/\n            , this._get(store, keyValues)];\n\n          case 10:\n            fromDB = _b.sent();\n\n            if (fromDB === undefined) {\n              msg = 'Model instance not found in storage';\n              logger.warn(msg, {\n                model: model\n              });\n              return [2\n              /*return*/\n              , [[model], []]];\n            }\n\n            predicates = ModelPredicateCreator.getPredicates(condition);\n            _a = predicates, predicateObjs = _a.predicates, type = _a.type;\n            isValid = validatePredicate(fromDB, type, predicateObjs);\n\n            if (!isValid) {\n              msg = 'Conditional update failed';\n              logger.error(msg, {\n                model: fromDB,\n                condition: predicateObjs\n              });\n              throw new Error(msg);\n            }\n\n            return [4\n            /*yield*/\n            , tx.done];\n\n          case 11:\n            _b.sent();\n\n            relations = this.schema.namespaces[namespaceName].relationships[modelConstructor.name].relationTypes;\n            return [4\n            /*yield*/\n            , this.deleteTraverse(relations, [model], modelConstructor.name, namespaceName, deleteQueue)];\n\n          case 12:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 15];\n\n          case 13:\n            relations = this.schema.namespaces[namespaceName].relationships[modelConstructor.name].relationTypes;\n            return [4\n            /*yield*/\n            , this.deleteTraverse(relations, [model], modelConstructor.name, namespaceName, deleteQueue)];\n\n          case 14:\n            _b.sent();\n\n            _b.label = 15;\n\n          case 15:\n            return [4\n            /*yield*/\n            , this.deleteItem(deleteQueue)];\n\n          case 16:\n            _b.sent();\n\n            deletedModels = deleteQueue.reduce(function (acc, _a) {\n              var items = _a.items;\n              return acc.concat(items);\n            }, []);\n            return [2\n            /*return*/\n            , [[model], deletedModels]];\n\n          case 17:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.deleteItem = function (deleteQueue) {\n    var e_7, _a, e_8, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var connectionStoreNames, tx, _c, _d, deleteItem, storeName, items, store, items_1, items_1_1, item, key, keyValues, itemKey, e_8_1, e_7_1;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            connectionStoreNames = deleteQueue.map(function (_a) {\n              var storeName = _a.storeName;\n              return storeName;\n            });\n            tx = this.db.transaction(__spread(connectionStoreNames), 'readwrite');\n            _e.label = 1;\n\n          case 1:\n            _e.trys.push([1, 22, 23, 28]);\n\n            _c = __asyncValues(deleteQueue);\n            _e.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , _c.next()];\n\n          case 3:\n            if (!(_d = _e.sent(), !_d.done)) return [3\n            /*break*/\n            , 21];\n            deleteItem = _d.value;\n            storeName = deleteItem.storeName, items = deleteItem.items;\n            store = tx.objectStore(storeName);\n            _e.label = 4;\n\n          case 4:\n            _e.trys.push([4, 14, 15, 20]);\n\n            items_1 = __asyncValues(items);\n            _e.label = 5;\n\n          case 5:\n            return [4\n            /*yield*/\n            , items_1.next()];\n\n          case 6:\n            if (!(items_1_1 = _e.sent(), !items_1_1.done)) return [3\n            /*break*/\n            , 13];\n            item = items_1_1.value;\n            if (!item) return [3\n            /*break*/\n            , 12];\n            key = void 0;\n            if (!(typeof item === 'object')) return [3\n            /*break*/\n            , 8];\n            keyValues = this.getIndexKeyValuesFromModel(item);\n            return [4\n            /*yield*/\n            , store.index('byPk').getKey(this.canonicalKeyPath(keyValues))];\n\n          case 7:\n            key = _e.sent();\n            return [3\n            /*break*/\n            , 10];\n\n          case 8:\n            itemKey = item.toString();\n            return [4\n            /*yield*/\n            , store.index('byPk').getKey(itemKey)];\n\n          case 9:\n            key = _e.sent();\n            _e.label = 10;\n\n          case 10:\n            if (!(key !== undefined)) return [3\n            /*break*/\n            , 12];\n            return [4\n            /*yield*/\n            , store.delete(key)];\n\n          case 11:\n            _e.sent();\n\n            _e.label = 12;\n\n          case 12:\n            return [3\n            /*break*/\n            , 5];\n\n          case 13:\n            return [3\n            /*break*/\n            , 20];\n\n          case 14:\n            e_8_1 = _e.sent();\n            e_8 = {\n              error: e_8_1\n            };\n            return [3\n            /*break*/\n            , 20];\n\n          case 15:\n            _e.trys.push([15,, 18, 19]);\n\n            if (!(items_1_1 && !items_1_1.done && (_b = items_1.return))) return [3\n            /*break*/\n            , 17];\n            return [4\n            /*yield*/\n            , _b.call(items_1)];\n\n          case 16:\n            _e.sent();\n\n            _e.label = 17;\n\n          case 17:\n            return [3\n            /*break*/\n            , 19];\n\n          case 18:\n            if (e_8) throw e_8.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 19:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 20:\n            return [3\n            /*break*/\n            , 2];\n\n          case 21:\n            return [3\n            /*break*/\n            , 28];\n\n          case 22:\n            e_7_1 = _e.sent();\n            e_7 = {\n              error: e_7_1\n            };\n            return [3\n            /*break*/\n            , 28];\n\n          case 23:\n            _e.trys.push([23,, 26, 27]);\n\n            if (!(_d && !_d.done && (_a = _c.return))) return [3\n            /*break*/\n            , 25];\n            return [4\n            /*yield*/\n            , _a.call(_c)];\n\n          case 24:\n            _e.sent();\n\n            _e.label = 25;\n\n          case 25:\n            return [3\n            /*break*/\n            , 27];\n\n          case 26:\n            if (e_7) throw e_7.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 27:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 28:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.deleteTraverse = function (relations, models, srcModel, nameSpace, deleteQueue) {\n    var relations_1, relations_1_1, models_1, models_1_1, models_2, models_2_1;\n\n    var e_9, _a, e_10, _b, e_11, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var rel, relationType, modelName, targetName, targetNames, associatedWith, storeName, _d, model, hasOneIndex, values, recordToDelete, index, values, value, recordToDelete, e_10_1, model, index, keyValues, childrenArray, e_11_1, e_9_1;\n\n      var _this = this;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _e.trys.push([0, 38, 39, 44]);\n\n            relations_1 = __asyncValues(relations);\n            _e.label = 1;\n\n          case 1:\n            return [4\n            /*yield*/\n            , relations_1.next()];\n\n          case 2:\n            if (!(relations_1_1 = _e.sent(), !relations_1_1.done)) return [3\n            /*break*/\n            , 37];\n            rel = relations_1_1.value;\n            relationType = rel.relationType, modelName = rel.modelName, targetName = rel.targetName, targetNames = rel.targetNames, associatedWith = rel.associatedWith;\n            storeName = getStorename(nameSpace, modelName);\n            _d = relationType;\n\n            switch (_d) {\n              case 'HAS_ONE':\n                return [3\n                /*break*/\n                , 3];\n\n              case 'HAS_MANY':\n                return [3\n                /*break*/\n                , 20];\n\n              case 'BELONGS_TO':\n                return [3\n                /*break*/\n                , 34];\n            }\n\n            return [3\n            /*break*/\n            , 35];\n\n          case 3:\n            _e.trys.push([3, 13, 14, 19]);\n\n            models_1 = __asyncValues(models);\n            _e.label = 4;\n\n          case 4:\n            return [4\n            /*yield*/\n            , models_1.next()];\n\n          case 5:\n            if (!(models_1_1 = _e.sent(), !models_1_1.done)) return [3\n            /*break*/\n            , 12];\n            model = models_1_1.value;\n            hasOneIndex = 'byPk';\n            if (!(targetNames === null || targetNames === void 0 ? void 0 : targetNames.length)) return [3\n            /*break*/\n            , 8];\n            values = targetNames.filter(function (targetName) {\n              var _a;\n\n              return (_a = model[targetName]) !== null && _a !== void 0 ? _a : false;\n            }).map(function (targetName) {\n              return model[targetName];\n            });\n            if (values.length === 0) return [3\n            /*break*/\n            , 12];\n            return [4\n            /*yield*/\n            , this.db.transaction(storeName, 'readwrite').objectStore(storeName).index(hasOneIndex).get(this.canonicalKeyPath(values))];\n\n          case 6:\n            recordToDelete = _e.sent();\n            return [4\n            /*yield*/\n            , this.deleteTraverse(this.schema.namespaces[nameSpace].relationships[modelName].relationTypes, recordToDelete ? [recordToDelete] : [], modelName, nameSpace, deleteQueue)];\n\n          case 7:\n            _e.sent();\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 8:\n            index = void 0;\n            values = void 0;\n\n            if (targetName && targetName in model) {\n              index = hasOneIndex;\n              value = model[targetName];\n              if (value === null) return [3\n              /*break*/\n              , 12];\n              values = [value];\n            } else {\n              // backwards compatability for older versions of codegen that did not emit targetName for HAS_ONE relations\n              // TODO: can we deprecate this? it's been ~2 years since codegen started including targetName for HAS_ONE\n              // If we deprecate, we'll need to re-gen the MIPR in __tests__/schema.ts > newSchema\n              // otherwise some unit tests will fail\n              index = getIndex(this.schema.namespaces[nameSpace].relationships[modelName].relationTypes, srcModel);\n              values = this.getIndexKeyValuesFromModel(model);\n            }\n\n            if (!values || !index) return [3\n            /*break*/\n            , 12];\n            return [4\n            /*yield*/\n            , this.db.transaction(storeName, 'readwrite').objectStore(storeName).index(index).get(this.canonicalKeyPath(values))];\n\n          case 9:\n            recordToDelete = _e.sent();\n            return [4\n            /*yield*/\n            , this.deleteTraverse(this.schema.namespaces[nameSpace].relationships[modelName].relationTypes, recordToDelete ? [recordToDelete] : [], modelName, nameSpace, deleteQueue)];\n\n          case 10:\n            _e.sent();\n\n            _e.label = 11;\n\n          case 11:\n            return [3\n            /*break*/\n            , 4];\n\n          case 12:\n            return [3\n            /*break*/\n            , 19];\n\n          case 13:\n            e_10_1 = _e.sent();\n            e_10 = {\n              error: e_10_1\n            };\n            return [3\n            /*break*/\n            , 19];\n\n          case 14:\n            _e.trys.push([14,, 17, 18]);\n\n            if (!(models_1_1 && !models_1_1.done && (_b = models_1.return))) return [3\n            /*break*/\n            , 16];\n            return [4\n            /*yield*/\n            , _b.call(models_1)];\n\n          case 15:\n            _e.sent();\n\n            _e.label = 16;\n\n          case 16:\n            return [3\n            /*break*/\n            , 18];\n\n          case 17:\n            if (e_10) throw e_10.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 18:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 19:\n            return [3\n            /*break*/\n            , 36];\n\n          case 20:\n            _e.trys.push([20, 27, 28, 33]);\n\n            models_2 = __asyncValues(models);\n            _e.label = 21;\n\n          case 21:\n            return [4\n            /*yield*/\n            , models_2.next()];\n\n          case 22:\n            if (!(models_2_1 = _e.sent(), !models_2_1.done)) return [3\n            /*break*/\n            , 26];\n            model = models_2_1.value;\n            index = // explicit bi-directional @hasMany and @manyToMany\n            getIndex(this.schema.namespaces[nameSpace].relationships[modelName].relationTypes, srcModel) || // uni and/or implicit @hasMany\n            getIndexFromAssociation(this.schema.namespaces[nameSpace].relationships[modelName].indexes, associatedWith);\n            keyValues = this.getIndexKeyValuesFromModel(model);\n            return [4\n            /*yield*/\n            , this.db.transaction(storeName, 'readwrite').objectStore(storeName).index(index).getAll(this.canonicalKeyPath(keyValues))];\n\n          case 23:\n            childrenArray = _e.sent();\n            return [4\n            /*yield*/\n            , this.deleteTraverse(this.schema.namespaces[nameSpace].relationships[modelName].relationTypes, childrenArray, modelName, nameSpace, deleteQueue)];\n\n          case 24:\n            _e.sent();\n\n            _e.label = 25;\n\n          case 25:\n            return [3\n            /*break*/\n            , 21];\n\n          case 26:\n            return [3\n            /*break*/\n            , 33];\n\n          case 27:\n            e_11_1 = _e.sent();\n            e_11 = {\n              error: e_11_1\n            };\n            return [3\n            /*break*/\n            , 33];\n\n          case 28:\n            _e.trys.push([28,, 31, 32]);\n\n            if (!(models_2_1 && !models_2_1.done && (_c = models_2.return))) return [3\n            /*break*/\n            , 30];\n            return [4\n            /*yield*/\n            , _c.call(models_2)];\n\n          case 29:\n            _e.sent();\n\n            _e.label = 30;\n\n          case 30:\n            return [3\n            /*break*/\n            , 32];\n\n          case 31:\n            if (e_11) throw e_11.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 32:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 33:\n            return [3\n            /*break*/\n            , 36];\n\n          case 34:\n            // Intentionally blank\n            return [3\n            /*break*/\n            , 36];\n\n          case 35:\n            throw new Error(\"Invalid relation type \" + relationType);\n\n          case 36:\n            return [3\n            /*break*/\n            , 1];\n\n          case 37:\n            return [3\n            /*break*/\n            , 44];\n\n          case 38:\n            e_9_1 = _e.sent();\n            e_9 = {\n              error: e_9_1\n            };\n            return [3\n            /*break*/\n            , 44];\n\n          case 39:\n            _e.trys.push([39,, 42, 43]);\n\n            if (!(relations_1_1 && !relations_1_1.done && (_a = relations_1.return))) return [3\n            /*break*/\n            , 41];\n            return [4\n            /*yield*/\n            , _a.call(relations_1)];\n\n          case 40:\n            _e.sent();\n\n            _e.label = 41;\n\n          case 41:\n            return [3\n            /*break*/\n            , 43];\n\n          case 42:\n            if (e_9) throw e_9.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 43:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 44:\n            deleteQueue.push({\n              storeName: getStorename(nameSpace, srcModel),\n              items: models.map(function (record) {\n                return _this.modelInstanceCreator(_this.getModelConstructorByModelName(nameSpace, srcModel), record);\n              })\n            });\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.clear = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.checkPrivate()];\n\n          case 1:\n            _b.sent();\n\n            (_a = this.db) === null || _a === void 0 ? void 0 : _a.close();\n            return [4\n            /*yield*/\n            , idb.deleteDB(this.dbName)];\n\n          case 2:\n            _b.sent();\n\n            this.db = undefined;\n            this.initPromise = undefined;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.batchSave = function (modelConstructor, items) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, storeName, txn, store, _loop_2, this_1, items_2, items_2_1, item, e_12_1;\n\n      var e_12, _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (items.length === 0) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            return [4\n            /*yield*/\n            , this.checkPrivate()];\n\n          case 1:\n            _b.sent();\n\n            result = [];\n            storeName = this.getStorenameForModel(modelConstructor);\n            txn = this.db.transaction(storeName, 'readwrite');\n            store = txn.store;\n\n            _loop_2 = function (item) {\n              var namespaceName, modelName, model, connectedModels, keyValues, _deleted, index, key, instance;\n\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    namespaceName = this_1.namespaceResolver(modelConstructor);\n                    modelName = modelConstructor.name;\n                    model = this_1.modelInstanceCreator(modelConstructor, item);\n                    connectedModels = traverseModel(modelName, model, this_1.schema.namespaces[namespaceName], this_1.modelInstanceCreator, this_1.getModelConstructorByModelName);\n                    keyValues = this_1.getIndexKeyValuesFromModel(model);\n                    _deleted = item._deleted;\n                    index = store.index('byPk');\n                    return [4\n                    /*yield*/\n                    , index.getKey(this_1.canonicalKeyPath(keyValues))];\n\n                  case 1:\n                    key = _a.sent();\n                    if (!!_deleted) return [3\n                    /*break*/\n                    , 3];\n                    instance = connectedModels.find(function (_a) {\n                      var instance = _a.instance;\n\n                      var instanceKeyValues = _this.getIndexKeyValuesFromModel(instance);\n\n                      return keysEqual(instanceKeyValues, keyValues);\n                    }).instance;\n                    result.push([instance, key ? OpType.UPDATE : OpType.INSERT]);\n                    return [4\n                    /*yield*/\n                    , store.put(instance, key)];\n\n                  case 2:\n                    _a.sent();\n\n                    return [3\n                    /*break*/\n                    , 5];\n\n                  case 3:\n                    result.push([item, OpType.DELETE]);\n                    if (!key) return [3\n                    /*break*/\n                    , 5];\n                    return [4\n                    /*yield*/\n                    , store.delete(key)];\n\n                  case 4:\n                    _a.sent();\n\n                    _a.label = 5;\n\n                  case 5:\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _b.label = 2;\n\n          case 2:\n            _b.trys.push([2, 7, 8, 9]);\n\n            items_2 = __values(items), items_2_1 = items_2.next();\n            _b.label = 3;\n\n          case 3:\n            if (!!items_2_1.done) return [3\n            /*break*/\n            , 6];\n            item = items_2_1.value;\n            return [5\n            /*yield**/\n            , _loop_2(item)];\n\n          case 4:\n            _b.sent();\n\n            _b.label = 5;\n\n          case 5:\n            items_2_1 = items_2.next();\n            return [3\n            /*break*/\n            , 3];\n\n          case 6:\n            return [3\n            /*break*/\n            , 9];\n\n          case 7:\n            e_12_1 = _b.sent();\n            e_12 = {\n              error: e_12_1\n            };\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            try {\n              if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);\n            } finally {\n              if (e_12) throw e_12.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 9:\n            return [4\n            /*yield*/\n            , txn.done];\n\n          case 10:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  IndexedDBAdapter.prototype.createObjectStoreForModel = function (db, namespaceName, storeName, modelName) {\n    var store = db.createObjectStore(storeName, {\n      autoIncrement: true\n    });\n    var indexes = this.schema.namespaces[namespaceName].relationships[modelName].indexes;\n    indexes.forEach(function (_a) {\n      var _b = __read(_a, 3),\n          idxName = _b[0],\n          keyPath = _b[1],\n          options = _b[2];\n\n      store.createIndex(idxName, keyPath, options);\n    });\n    return store;\n  };\n\n  return IndexedDBAdapter;\n}();\n\nexport default new IndexedDBAdapter();","map":{"version":3,"mappings":"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","names":["ConsoleLogger","Logger","idb","ModelPredicateCreator","isPredicateObj","isPredicateGroup","OpType","QueryOne","getIndex","getIndexFromAssociation","isModelConstructor","isPrivateMode","traverseModel","validatePredicate","inMemoryPagination","keysEqual","getStorename","getIndexKeys","extractPrimaryKeyValues","isSafariCompatabilityMode","logger","DB_NAME","keyArr","_this","safariCompatabilityMode","length","IndexedDBAdapter","modelConstructor","namespace","namespaceResolver","modelName","model","Object","getPrototypeOf","constructor","namespaceName","keys","schema","namespaces","name","then","isPrivate","_a","error","Promise","reject","resolve","_b","debug","storeName","modelNameArr","join","theSchema","modelInstanceCreator","getModelConstructorByModelName","sessionId","checkPrivate","setSafariCompatabilityMode","initPromise","res","rej","dbName","db","VERSION","openDB","upgrade","oldVersion","newVersion","txn","forEach","models","createObjectStoreForModel","objectStoreNames","origStore","objectStore","tmpName","_c","getNamespaceAndModelFromStorename","modelInCurrentSchema","deleteObjectStore","newStore","openCursor","cursor","_e","count","value","put","continue","Set","map","filter","has","error_2","abort","error_1","storeOrStoreName","index","transaction","store","get","canonicalKeyPath","result","condition","getStorenameForModel","connectedModels","set","connectionStoreNames","values","item","instance","add","tx","__spread","Array","from","keyValues","getIndexKeyValuesFromModel","_get","fromDB","predicates","getPredicates","predicateObjs","type","isValid","msg","Error","connectionStoreNames_1","resItem","storeName_1","store_1","itemKeyValues","key","fromDB_1","opType","undefined","INSERT","UPDATE","modelKeyValues","getKey","push","done","srcModelName","records","relations","relationships","relationTypes","record","predicate","pagination","keyPath","queryByKey","keyValueFromPredicate","hasSort","sort","hasPagination","limit","getByKey","filterOnPredicate","filtered","getAll","all","enginePagination","load","keyValue","predicateObj","find","p","field","operator","operand","keyPath_1_1","fieldName","indexNames","name_1","idx","fieldPredicates","predicateIndexes","matchingIndex","String","actualPredicateIndexes","i","predicateIndex","candidateResults","every","distinctResults","Map","predicateIndexes_1","predicateIndexes_1_1","resultGroup","resultGroup_1","resultGroup_1_1","id","m","initialRecord","Math","max","page","advance","pageResults","hasLimit","firstOrLast","FIRST","modelOrModelConstructor","deleteQueue","nameSpace","query","deleteTraverse","deleteItem","deletedModels","reduce","acc","items","concat","clear","warn","items_1","itemKey","toString","delete","srcModel","relations_1","rel","relationType","targetName","targetNames","associatedWith","_d","models_1","hasOneIndex","recordToDelete","models_2","indexes","childrenArray","close","deleteDB","this_1","_deleted","instanceKeyValues","DELETE","items_2","items_2_1","createObjectStore","autoIncrement","idxName","options","createIndex"],"sources":["/home/dalienst/node_modules/@aws-amplify/datastore/src/storage/adapter/IndexedDBAdapter.ts"],"sourcesContent":["import { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport * as idb from 'idb';\nimport { ModelInstanceCreator } from '../../datastore/datastore';\nimport { ModelPredicateCreator } from '../../predicates';\nimport {\n\tInternalSchema,\n\tisPredicateObj,\n\tisPredicateGroup,\n\tModelInstanceMetadata,\n\tModelPredicate,\n\tNamespaceResolver,\n\tOpType,\n\tPaginationInput,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tPredicateObject,\n\tPredicatesGroup,\n\tQueryOne,\n\tRelationType,\n} from '../../types';\nimport {\n\tgetIndex,\n\tgetIndexFromAssociation,\n\tisModelConstructor,\n\tisPrivateMode,\n\ttraverseModel,\n\tvalidatePredicate,\n\tinMemoryPagination,\n\tNAMESPACES,\n\tkeysEqual,\n\tgetStorename,\n\tgetIndexKeys,\n\textractPrimaryKeyValues,\n\tisSafariCompatabilityMode,\n} from '../../util';\nimport { Adapter } from './index';\n\nconst logger = new Logger('DataStore');\n\nconst DB_NAME = 'amplify-datastore';\nclass IndexedDBAdapter implements Adapter {\n\tprivate schema!: InternalSchema;\n\tprivate namespaceResolver!: NamespaceResolver;\n\tprivate modelInstanceCreator!: ModelInstanceCreator;\n\tprivate getModelConstructorByModelName?: (\n\t\tnamsespaceName: NAMESPACES,\n\t\tmodelName: string\n\t) => PersistentModelConstructor<any>;\n\tprivate db!: idb.IDBPDatabase;\n\tprivate initPromise!: Promise<void>;\n\tprivate resolve!: (value?: any) => void;\n\tprivate reject!: (value?: any) => void;\n\tprivate dbName: string = DB_NAME;\n\tprivate safariCompatabilityMode: boolean = false;\n\n\tprivate getStorenameForModel(\n\t\tmodelConstructor: PersistentModelConstructor<any>\n\t) {\n\t\tconst namespace = this.namespaceResolver(modelConstructor);\n\t\tconst { name: modelName } = modelConstructor;\n\n\t\treturn getStorename(namespace, modelName);\n\t}\n\n\t// Retrieves primary key values from a model\n\tprivate getIndexKeyValuesFromModel<T extends PersistentModel>(\n\t\tmodel: T\n\t): string[] {\n\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst keys = getIndexKeys(\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tmodelConstructor.name\n\t\t);\n\n\t\treturn extractPrimaryKeyValues(model, keys);\n\t}\n\n\tprivate async checkPrivate() {\n\t\tconst isPrivate = await isPrivateMode().then(isPrivate => {\n\t\t\treturn isPrivate;\n\t\t});\n\t\tif (isPrivate) {\n\t\t\tlogger.error(\"IndexedDB not supported in this browser's private mode\");\n\t\t\treturn Promise.reject(\n\t\t\t\t\"IndexedDB not supported in this browser's private mode\"\n\t\t\t);\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Whether the browser's implementation of IndexedDB is coercing single-field\n\t * indexes to a scalar key.\n\t *\n\t * If this returns `true`, we need to treat indexes containing a single field\n\t * as scalars.\n\t *\n\t * See PR description for reference:\n\t * https://github.com/aws-amplify/amplify-js/pull/10527\n\t */\n\tprivate async setSafariCompatabilityMode() {\n\t\tthis.safariCompatabilityMode = await isSafariCompatabilityMode();\n\n\t\tif (this.safariCompatabilityMode === true) {\n\t\t\tlogger.debug('IndexedDB Adapter is running in Safari Compatability Mode');\n\t\t}\n\t}\n\n\tprivate getNamespaceAndModelFromStorename(storeName: string) {\n\t\tconst [namespaceName, ...modelNameArr] = storeName.split('_');\n\t\treturn {\n\t\t\tnamespaceName,\n\t\t\tmodelName: modelNameArr.join('_'),\n\t\t};\n\t}\n\n\tasync setUp(\n\t\ttheSchema: InternalSchema,\n\t\tnamespaceResolver: NamespaceResolver,\n\t\tmodelInstanceCreator: ModelInstanceCreator,\n\t\tgetModelConstructorByModelName: (\n\t\t\tnamsespaceName: NAMESPACES,\n\t\t\tmodelName: string\n\t\t) => PersistentModelConstructor<any>,\n\t\tsessionId?: string\n\t) {\n\t\tawait this.checkPrivate();\n\t\tawait this.setSafariCompatabilityMode();\n\n\t\tif (!this.initPromise) {\n\t\t\tthis.initPromise = new Promise((res, rej) => {\n\t\t\t\tthis.resolve = res;\n\t\t\t\tthis.reject = rej;\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.initPromise;\n\t\t}\n\t\tif (sessionId) {\n\t\t\tthis.dbName = `${DB_NAME}-${sessionId}`;\n\t\t}\n\t\tthis.schema = theSchema;\n\t\tthis.namespaceResolver = namespaceResolver;\n\t\tthis.modelInstanceCreator = modelInstanceCreator;\n\t\tthis.getModelConstructorByModelName = getModelConstructorByModelName;\n\n\t\ttry {\n\t\t\tif (!this.db) {\n\t\t\t\tconst VERSION = 3;\n\t\t\t\tthis.db = await idb.openDB(this.dbName, VERSION, {\n\t\t\t\t\tupgrade: async (db, oldVersion, newVersion, txn) => {\n\t\t\t\t\t\tif (oldVersion === 0) {\n\t\t\t\t\t\t\tObject.keys(theSchema.namespaces).forEach(namespaceName => {\n\t\t\t\t\t\t\t\tconst namespace = theSchema.namespaces[namespaceName];\n\n\t\t\t\t\t\t\t\tObject.keys(namespace.models).forEach(modelName => {\n\t\t\t\t\t\t\t\t\tconst storeName = getStorename(namespaceName, modelName);\n\t\t\t\t\t\t\t\t\tthis.createObjectStoreForModel(\n\t\t\t\t\t\t\t\t\t\tdb,\n\t\t\t\t\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\t\t\t\t\tstoreName,\n\t\t\t\t\t\t\t\t\t\tmodelName\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((oldVersion === 1 || oldVersion === 2) && newVersion === 3) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfor (const storeName of txn.objectStoreNames) {\n\t\t\t\t\t\t\t\t\tconst origStore = txn.objectStore(storeName);\n\n\t\t\t\t\t\t\t\t\t// rename original store\n\t\t\t\t\t\t\t\t\tconst tmpName = `tmp_${storeName}`;\n\t\t\t\t\t\t\t\t\torigStore.name = tmpName;\n\n\t\t\t\t\t\t\t\t\tconst { namespaceName, modelName } =\n\t\t\t\t\t\t\t\t\t\tthis.getNamespaceAndModelFromStorename(storeName);\n\n\t\t\t\t\t\t\t\t\tconst modelInCurrentSchema =\n\t\t\t\t\t\t\t\t\t\tmodelName in this.schema.namespaces[namespaceName].models;\n\n\t\t\t\t\t\t\t\t\tif (!modelInCurrentSchema) {\n\t\t\t\t\t\t\t\t\t\t// delete original\n\t\t\t\t\t\t\t\t\t\tdb.deleteObjectStore(tmpName);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst newStore = this.createObjectStoreForModel(\n\t\t\t\t\t\t\t\t\t\tdb,\n\t\t\t\t\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\t\t\t\t\tstoreName,\n\t\t\t\t\t\t\t\t\t\tmodelName\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tlet cursor = await origStore.openCursor();\n\t\t\t\t\t\t\t\t\tlet count = 0;\n\n\t\t\t\t\t\t\t\t\t// Copy data from original to new\n\t\t\t\t\t\t\t\t\twhile (cursor && cursor.value) {\n\t\t\t\t\t\t\t\t\t\t// we don't pass key, since they are all new entries in the new store\n\t\t\t\t\t\t\t\t\t\tawait newStore.put(cursor.value);\n\n\t\t\t\t\t\t\t\t\t\tcursor = await cursor.continue();\n\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// delete original\n\t\t\t\t\t\t\t\t\tdb.deleteObjectStore(tmpName);\n\n\t\t\t\t\t\t\t\t\tlogger.debug(`${count} ${storeName} records migrated`);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// add new models created after IndexedDB, but before migration\n\t\t\t\t\t\t\t\t// this case may happen when a user has not opened an app for\n\t\t\t\t\t\t\t\t// some time and a new model is added during that time\n\t\t\t\t\t\t\t\tObject.keys(theSchema.namespaces).forEach(namespaceName => {\n\t\t\t\t\t\t\t\t\tconst namespace = theSchema.namespaces[namespaceName];\n\t\t\t\t\t\t\t\t\tconst objectStoreNames = new Set(txn.objectStoreNames);\n\n\t\t\t\t\t\t\t\t\tObject.keys(namespace.models)\n\t\t\t\t\t\t\t\t\t\t.map(modelName => {\n\t\t\t\t\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t\t\t\t\t\t\tgetStorename(namespaceName, modelName),\n\t\t\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.filter(([, storeName]) => !objectStoreNames.has(storeName))\n\t\t\t\t\t\t\t\t\t\t.forEach(([modelName, storeName]) => {\n\t\t\t\t\t\t\t\t\t\t\tthis.createObjectStoreForModel(\n\t\t\t\t\t\t\t\t\t\t\t\tdb,\n\t\t\t\t\t\t\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\t\t\t\t\t\t\tstoreName,\n\t\t\t\t\t\t\t\t\t\t\t\tmodelName\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tlogger.error('Error migrating IndexedDB data', error);\n\t\t\t\t\t\t\t\ttxn.abort();\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tthis.resolve();\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.reject(error);\n\t\t}\n\t}\n\n\tprivate async _get<T>(\n\t\tstoreOrStoreName: idb.IDBPObjectStore | string,\n\t\tkeyArr: string[]\n\t): Promise<T> {\n\t\tlet index: idb.IDBPIndex;\n\n\t\tif (typeof storeOrStoreName === 'string') {\n\t\t\tconst storeName = storeOrStoreName;\n\t\t\tindex = this.db.transaction(storeName, 'readonly').store.index('byPk');\n\t\t} else {\n\t\t\tconst store = storeOrStoreName;\n\t\t\tindex = store.index('byPk');\n\t\t}\n\n\t\tconst result = await index.get(this.canonicalKeyPath(keyArr));\n\n\t\treturn result;\n\t}\n\n\tasync save<T extends PersistentModel>(\n\t\tmodel: T,\n\t\tcondition?: ModelPredicate<T>\n\t): Promise<[T, OpType.INSERT | OpType.UPDATE][]> {\n\t\tawait this.checkPrivate();\n\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\n\t\tconst connectedModels = traverseModel(\n\t\t\tmodelConstructor.name,\n\t\t\tmodel,\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tthis.modelInstanceCreator,\n\t\t\tthis.getModelConstructorByModelName!\n\t\t);\n\n\t\tconst set = new Set<string>();\n\t\tconst connectionStoreNames = Object.values(connectedModels).map(\n\t\t\t({ modelName, item, instance }) => {\n\t\t\t\tconst storeName = getStorename(namespaceName, modelName);\n\t\t\t\tset.add(storeName);\n\t\t\t\tconst keys = getIndexKeys(\n\t\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\t\tmodelName\n\t\t\t\t);\n\t\t\t\treturn { storeName, item, instance, keys };\n\t\t\t}\n\t\t);\n\n\t\tconst tx = this.db.transaction(\n\t\t\t[storeName, ...Array.from(set.values())],\n\t\t\t'readwrite'\n\t\t);\n\t\tconst store = tx.objectStore(storeName);\n\n\t\tconst keyValues = this.getIndexKeyValuesFromModel(model);\n\n\t\tconst fromDB = await this._get(store, keyValues);\n\n\t\tif (condition && fromDB) {\n\t\t\tconst predicates = ModelPredicateCreator.getPredicates(condition);\n\t\t\tconst { predicates: predicateObjs, type } = predicates || {};\n\n\t\t\tconst isValid = validatePredicate(\n\t\t\t\tfromDB as any,\n\t\t\t\ttype as any,\n\t\t\t\tpredicateObjs as any\n\t\t\t);\n\n\t\t\tif (!isValid) {\n\t\t\t\tconst msg = 'Conditional update failed';\n\t\t\t\tlogger.error(msg, { model: fromDB, condition: predicateObjs });\n\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\t\t}\n\n\t\tconst result: [T, OpType.INSERT | OpType.UPDATE][] = [];\n\t\tfor await (const resItem of connectionStoreNames) {\n\t\t\tconst { storeName, item, instance, keys } = resItem;\n\t\t\tconst store = tx.objectStore(storeName);\n\n\t\t\tconst itemKeyValues = keys.map(key => {\n\t\t\t\tconst value = item[key];\n\t\t\t\treturn value;\n\t\t\t});\n\n\t\t\tconst fromDB = <T>await this._get(store, itemKeyValues);\n\t\t\tconst opType: OpType =\n\t\t\t\tfromDB === undefined ? OpType.INSERT : OpType.UPDATE;\n\n\t\t\tconst modelKeyValues = this.getIndexKeyValuesFromModel(model);\n\n\t\t\t// Even if the parent is an INSERT, the child might not be, so we need to get its key\n\t\t\tif (\n\t\t\t\tkeysEqual(itemKeyValues, modelKeyValues) ||\n\t\t\t\topType === OpType.INSERT\n\t\t\t) {\n\t\t\t\tconst key = await store\n\t\t\t\t\t.index('byPk')\n\t\t\t\t\t.getKey(this.canonicalKeyPath(itemKeyValues));\n\t\t\t\tawait store.put(item, key);\n\t\t\t\tresult.push([instance, opType]);\n\t\t\t}\n\t\t}\n\n\t\tawait tx.done;\n\n\t\treturn result;\n\t}\n\n\tprivate async load<T>(\n\t\tnamespaceName: NAMESPACES,\n\t\tsrcModelName: string,\n\t\trecords: T[]\n\t): Promise<T[]> {\n\t\tconst namespace = this.schema.namespaces[namespaceName];\n\t\tconst relations = namespace.relationships![srcModelName].relationTypes;\n\t\tconst connectionStoreNames = relations.map(({ modelName }) => {\n\t\t\treturn getStorename(namespaceName, modelName);\n\t\t});\n\t\tconst modelConstructor = this.getModelConstructorByModelName!(\n\t\t\tnamespaceName,\n\t\t\tsrcModelName\n\t\t);\n\n\t\tif (connectionStoreNames.length === 0) {\n\t\t\treturn records.map(record =>\n\t\t\t\tthis.modelInstanceCreator(modelConstructor, record)\n\t\t\t);\n\t\t}\n\n\t\treturn records.map(record =>\n\t\t\tthis.modelInstanceCreator(modelConstructor, record)\n\t\t);\n\t}\n\n\tasync query<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tpredicate?: ModelPredicate<T>,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]> {\n\t\tawait this.checkPrivate();\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\t\tconst namespaceName = this.namespaceResolver(\n\t\t\tmodelConstructor\n\t\t) as NAMESPACES;\n\n\t\tconst predicates =\n\t\t\tpredicate && ModelPredicateCreator.getPredicates(predicate);\n\t\tconst keyPath = getIndexKeys(\n\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\tmodelConstructor.name\n\t\t);\n\t\tconst queryByKey =\n\t\t\tpredicates && this.keyValueFromPredicate(predicates, keyPath);\n\n\t\tconst hasSort = pagination && pagination.sort;\n\t\tconst hasPagination = pagination && pagination.limit;\n\n\t\tconst records: T[] = (await (async () => {\n\t\t\tif (queryByKey) {\n\t\t\t\tconst record = await this.getByKey(storeName, queryByKey);\n\t\t\t\treturn record ? [record] : [];\n\t\t\t}\n\n\t\t\tif (predicates) {\n\t\t\t\tconst filtered = await this.filterOnPredicate(storeName, predicates);\n\t\t\t\treturn this.inMemoryPagination(filtered, pagination);\n\t\t\t}\n\n\t\t\tif (hasSort) {\n\t\t\t\tconst all = await this.getAll(storeName);\n\t\t\t\treturn this.inMemoryPagination(all, pagination);\n\t\t\t}\n\n\t\t\tif (hasPagination) {\n\t\t\t\treturn this.enginePagination(storeName, pagination);\n\t\t\t}\n\n\t\t\treturn this.getAll(storeName);\n\t\t})()) as T[];\n\n\t\treturn await this.load(namespaceName, modelConstructor.name, records);\n\t}\n\n\tprivate async getByKey<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tkeyValue: string[]\n\t): Promise<T> {\n\t\treturn <T>await this._get(storeName, keyValue);\n\t}\n\n\tprivate async getAll<T extends PersistentModel>(\n\t\tstoreName: string\n\t): Promise<T[]> {\n\t\treturn await this.db.getAll(storeName);\n\t}\n\n\tprivate keyValueFromPredicate<T extends PersistentModel>(\n\t\tpredicates: PredicatesGroup<T>,\n\t\tkeyPath: string[]\n\t): string[] | undefined {\n\t\tconst { predicates: predicateObjs } = predicates;\n\n\t\tif (predicateObjs.length !== keyPath.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst keyValues = [] as any[];\n\n\t\tfor (const key of keyPath) {\n\t\t\tconst predicateObj = predicateObjs.find(\n\t\t\t\tp => isPredicateObj(p) && p.field === key && p.operator === 'eq'\n\t\t\t) as PredicateObject<T>;\n\n\t\t\tpredicateObj && keyValues.push(predicateObj.operand);\n\t\t}\n\n\t\treturn keyValues.length === keyPath.length ? keyValues : undefined;\n\t}\n\n\tprivate matchingIndex(\n\t\tstoreName: string,\n\t\tfieldName: string,\n\t\ttransaction: idb.IDBPTransaction<unknown, [string]>\n\t) {\n\t\tconst store = transaction.objectStore(storeName);\n\t\tfor (const name of store.indexNames) {\n\t\t\tconst idx = store.index(name);\n\t\t\tif (idx.keyPath === fieldName) {\n\t\t\t\treturn idx;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async filterOnPredicate<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tpredicates: PredicatesGroup<T>\n\t) {\n\t\tlet { predicates: predicateObjs, type } = predicates;\n\n\t\t// the predicate objects we care about tend to be nested at least\n\t\t// one level down: `{and: {or: {and: { <the predicates we want> }}}}`\n\t\t// so, we unpack and/or groups until we find a group with more than 1\n\t\t// child OR a child that is not a group (and is therefore a predicate \"object\").\n\t\twhile (predicateObjs.length === 1 && isPredicateGroup(predicateObjs[0])) {\n\t\t\ttype = (predicateObjs[0] as PredicatesGroup<T>).type;\n\t\t\tpredicateObjs = (predicateObjs[0] as PredicatesGroup<T>).predicates;\n\t\t}\n\n\t\t// where we'll accumulate candidate results, which will be filtered at the end.\n\t\tlet candidateResults: T[];\n\n\t\t// AFAIK, this will always be a homogenous group of predicate objects at this point.\n\t\t// but, if that ever changes, this pulls out just the predicates from the list that\n\t\t// are field-level predicate objects we can potentially smash against an index.\n\t\tconst fieldPredicates = predicateObjs.filter(p =>\n\t\t\tisPredicateObj(p)\n\t\t) as PredicateObject<T>[];\n\n\t\t// several sub-queries could occur here. explicitly start a txn here to avoid\n\t\t// opening/closing multiple txns.\n\t\tconst txn = this.db.transaction(storeName);\n\n\t\t// our potential indexes or lacks thereof.\n\t\tconst predicateIndexes = fieldPredicates.map(p => {\n\t\t\treturn {\n\t\t\t\tpredicate: p,\n\t\t\t\tindex: this.matchingIndex(storeName, String(p.field), txn),\n\t\t\t};\n\t\t});\n\n\t\t// Explicitly wait for txns from index queries to complete before proceding.\n\t\t// This helps ensure IndexedDB is in a stable, ready state. Else, subseqeuent\n\t\t// qeuries can sometimes appear to deadlock (at least in FakeIndexedDB).\n\t\tawait txn.done;\n\n\t\t// semi-naive implementation:\n\t\tif (type === 'and') {\n\t\t\t// each condition must be satsified, we can form a base set with any\n\t\t\t// ONE of those conditions and then filter.\n\t\t\tconst actualPredicateIndexes = predicateIndexes.filter(\n\t\t\t\ti => i.index && i.predicate.operator === 'eq'\n\t\t\t);\n\n\t\t\tif (actualPredicateIndexes.length > 0) {\n\t\t\t\tconst predicateIndex = actualPredicateIndexes[0];\n\t\t\t\tcandidateResults = <T[]>(\n\t\t\t\t\tawait predicateIndex.index!.getAll(predicateIndex.predicate.operand)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// no usable indexes\n\t\t\t\tcandidateResults = <T[]>await this.getAll(storeName);\n\t\t\t}\n\t\t} else if (type === 'or') {\n\t\t\t// NOTE: each condition implies a potentially distinct set. we only benefit\n\t\t\t// from using indexes here if EVERY condition uses an index. if any one\n\t\t\t// index requires a table scan, we gain nothing from the indexes.\n\t\t\t// NOTE: results must be DISTINCT-ified if we leverage indexes.\n\t\t\tif (\n\t\t\t\tpredicateIndexes.length > 0 &&\n\t\t\t\tpredicateIndexes.every(i => i.index && i.predicate.operator === 'eq')\n\t\t\t) {\n\t\t\t\tconst distinctResults = new Map<string, T>();\n\t\t\t\tfor (const predicateIndex of predicateIndexes) {\n\t\t\t\t\tconst resultGroup = <T[]>(\n\t\t\t\t\t\tawait predicateIndex.index!.getAll(predicateIndex.predicate.operand)\n\t\t\t\t\t);\n\t\t\t\t\tfor (const item of resultGroup) {\n\t\t\t\t\t\t// TODO: custom PK\n\t\t\t\t\t\tdistinctResults.set(item.id, item);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// we could conceivably check for special conditions and return early here.\n\t\t\t\t// but, this is simpler and has not yet had a measurable performance impact.\n\t\t\t\tcandidateResults = Array.from(distinctResults.values());\n\t\t\t} else {\n\t\t\t\t// either no usable indexes or not all conditions can use one.\n\t\t\t\tcandidateResults = <T[]>await this.getAll(storeName);\n\t\t\t}\n\t\t} else {\n\t\t\t// nothing intelligent we can do with `not` groups unless or until we start\n\t\t\t// smashing comparison operators against indexes -- at which point we could\n\t\t\t// perform some reversal here.\n\t\t\tcandidateResults = <T[]>await this.getAll(storeName);\n\t\t}\n\n\t\tconst filtered = predicateObjs\n\t\t\t? candidateResults.filter(m => validatePredicate(m, type, predicateObjs))\n\t\t\t: candidateResults;\n\n\t\treturn filtered;\n\t}\n\n\tprivate inMemoryPagination<T extends PersistentModel>(\n\t\trecords: T[],\n\t\tpagination?: PaginationInput<T>\n\t): T[] {\n\t\treturn inMemoryPagination(records, pagination);\n\t}\n\n\tprivate async enginePagination<T extends PersistentModel>(\n\t\tstoreName: string,\n\t\tpagination?: PaginationInput<T>\n\t): Promise<T[]> {\n\t\tlet result: T[];\n\n\t\tif (pagination) {\n\t\t\tconst { page = 0, limit = 0 } = pagination;\n\t\t\tconst initialRecord = Math.max(0, page * limit) || 0;\n\n\t\t\tlet cursor = await this.db\n\t\t\t\t.transaction(storeName)\n\t\t\t\t.objectStore(storeName)\n\t\t\t\t.openCursor();\n\n\t\t\tif (cursor && initialRecord > 0) {\n\t\t\t\tawait cursor.advance(initialRecord);\n\t\t\t}\n\n\t\t\tconst pageResults: T[] = [];\n\t\t\tconst hasLimit = typeof limit === 'number' && limit > 0;\n\n\t\t\twhile (cursor && cursor.value) {\n\t\t\t\tpageResults.push(cursor.value);\n\n\t\t\t\tif (hasLimit && pageResults.length === limit) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcursor = await cursor.continue();\n\t\t\t}\n\n\t\t\tresult = pageResults;\n\t\t} else {\n\t\t\tresult = <T[]>await this.db.getAll(storeName);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync queryOne<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<T>,\n\t\tfirstOrLast: QueryOne = QueryOne.FIRST\n\t): Promise<T | undefined> {\n\t\tawait this.checkPrivate();\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\n\t\tconst cursor = await this.db\n\t\t\t.transaction([storeName], 'readonly')\n\t\t\t.objectStore(storeName)\n\t\t\t.openCursor(undefined, firstOrLast === QueryOne.FIRST ? 'next' : 'prev');\n\n\t\tconst result = cursor ? <T>cursor.value : undefined;\n\n\t\treturn result && this.modelInstanceCreator(modelConstructor, result);\n\t}\n\n\tasync delete<T extends PersistentModel>(\n\t\tmodelOrModelConstructor: T | PersistentModelConstructor<T>,\n\t\tcondition?: ModelPredicate<T>\n\t): Promise<[T[], T[]]> {\n\t\tawait this.checkPrivate();\n\t\tconst deleteQueue: { storeName: string; items: T[] }[] = [];\n\n\t\tif (isModelConstructor(modelOrModelConstructor)) {\n\t\t\tconst modelConstructor =\n\t\t\t\tmodelOrModelConstructor as PersistentModelConstructor<T>;\n\t\t\tconst nameSpace = this.namespaceResolver(modelConstructor) as NAMESPACES;\n\n\t\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\n\t\t\tconst models = await this.query(modelConstructor, condition);\n\t\t\tconst relations =\n\t\t\t\tthis.schema.namespaces![nameSpace].relationships![modelConstructor.name]\n\t\t\t\t\t.relationTypes;\n\n\t\t\tif (condition !== undefined) {\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\tmodels,\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnameSpace,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\n\t\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t\t<T[]>[]\n\t\t\t\t);\n\n\t\t\t\treturn [models, deletedModels];\n\t\t\t} else {\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\tmodels,\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnameSpace,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\n\t\t\t\t// Delete all\n\t\t\t\tawait this.db\n\t\t\t\t\t.transaction([storeName], 'readwrite')\n\t\t\t\t\t.objectStore(storeName)\n\t\t\t\t\t.clear();\n\n\t\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t\t<T[]>[]\n\t\t\t\t);\n\n\t\t\t\treturn [models, deletedModels];\n\t\t\t}\n\t\t} else {\n\t\t\tconst model = modelOrModelConstructor as T;\n\n\t\t\tconst modelConstructor = Object.getPrototypeOf(model)\n\t\t\t\t.constructor as PersistentModelConstructor<T>;\n\t\t\tconst namespaceName = this.namespaceResolver(\n\t\t\t\tmodelConstructor\n\t\t\t) as NAMESPACES;\n\n\t\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\n\t\t\tif (condition) {\n\t\t\t\tconst tx = this.db.transaction([storeName], 'readwrite');\n\t\t\t\tconst store = tx.objectStore(storeName);\n\t\t\t\tconst keyValues = this.getIndexKeyValuesFromModel(model);\n\n\t\t\t\tconst fromDB = await this._get(store, keyValues);\n\n\t\t\t\tif (fromDB === undefined) {\n\t\t\t\t\tconst msg = 'Model instance not found in storage';\n\t\t\t\t\tlogger.warn(msg, { model });\n\n\t\t\t\t\treturn [[model], []];\n\t\t\t\t}\n\n\t\t\t\tconst predicates = ModelPredicateCreator.getPredicates(condition);\n\t\t\t\tconst { predicates: predicateObjs, type } =\n\t\t\t\t\tpredicates as PredicatesGroup<T>;\n\n\t\t\t\tconst isValid = validatePredicate(fromDB as T, type, predicateObjs);\n\n\t\t\t\tif (!isValid) {\n\t\t\t\t\tconst msg = 'Conditional update failed';\n\t\t\t\t\tlogger.error(msg, { model: fromDB, condition: predicateObjs });\n\n\t\t\t\t\tthrow new Error(msg);\n\t\t\t\t}\n\t\t\t\tawait tx.done;\n\n\t\t\t\tconst relations =\n\t\t\t\t\tthis.schema.namespaces[namespaceName].relationships![\n\t\t\t\t\t\tmodelConstructor.name\n\t\t\t\t\t].relationTypes;\n\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\t[model],\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnamespaceName,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst relations =\n\t\t\t\t\tthis.schema.namespaces[namespaceName].relationships![\n\t\t\t\t\t\tmodelConstructor.name\n\t\t\t\t\t].relationTypes;\n\n\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\trelations,\n\t\t\t\t\t[model],\n\t\t\t\t\tmodelConstructor.name,\n\t\t\t\t\tnamespaceName,\n\t\t\t\t\tdeleteQueue\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tawait this.deleteItem(deleteQueue);\n\n\t\t\tconst deletedModels = deleteQueue.reduce(\n\t\t\t\t(acc, { items }) => acc.concat(items),\n\t\t\t\t<T[]>[]\n\t\t\t);\n\n\t\t\treturn [[model], deletedModels];\n\t\t}\n\t}\n\n\tprivate async deleteItem<T extends PersistentModel>(\n\t\tdeleteQueue?: {\n\t\t\tstoreName: string;\n\t\t\titems: T[] | IDBValidKey[];\n\t\t}[]\n\t) {\n\t\tconst connectionStoreNames = deleteQueue!.map(({ storeName }) => {\n\t\t\treturn storeName;\n\t\t});\n\n\t\tconst tx = this.db.transaction([...connectionStoreNames], 'readwrite');\n\t\tfor await (const deleteItem of deleteQueue!) {\n\t\t\tconst { storeName, items } = deleteItem;\n\t\t\tconst store = tx.objectStore(storeName);\n\n\t\t\tfor await (const item of items) {\n\t\t\t\tif (item) {\n\t\t\t\t\tlet key: IDBValidKey | undefined;\n\n\t\t\t\t\tif (typeof item === 'object') {\n\t\t\t\t\t\tconst keyValues = this.getIndexKeyValuesFromModel(item as T);\n\t\t\t\t\t\tkey = await store\n\t\t\t\t\t\t\t.index('byPk')\n\t\t\t\t\t\t\t.getKey(this.canonicalKeyPath(keyValues));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst itemKey = item.toString();\n\t\t\t\t\t\tkey = await store.index('byPk').getKey(itemKey);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key !== undefined) {\n\t\t\t\t\t\tawait store.delete(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async deleteTraverse<T extends PersistentModel>(\n\t\trelations: RelationType[],\n\t\tmodels: T[],\n\t\tsrcModel: string,\n\t\tnameSpace: NAMESPACES,\n\t\tdeleteQueue: { storeName: string; items: T[] }[]\n\t): Promise<void> {\n\t\tfor await (const rel of relations) {\n\t\t\tconst {\n\t\t\t\trelationType,\n\t\t\t\tmodelName,\n\t\t\t\ttargetName,\n\t\t\t\ttargetNames,\n\t\t\t\tassociatedWith,\n\t\t\t} = rel;\n\n\t\t\tconst storeName = getStorename(nameSpace, modelName);\n\n\t\t\tswitch (relationType) {\n\t\t\t\tcase 'HAS_ONE':\n\t\t\t\t\tfor await (const model of models) {\n\t\t\t\t\t\tconst hasOneIndex = 'byPk';\n\n\t\t\t\t\t\tif (targetNames?.length) {\n\t\t\t\t\t\t\t// CPK codegen\n\t\t\t\t\t\t\tconst values = targetNames\n\t\t\t\t\t\t\t\t.filter(targetName => model[targetName] ?? false)\n\t\t\t\t\t\t\t\t.map(targetName => model[targetName]);\n\n\t\t\t\t\t\t\tif (values.length === 0) break;\n\n\t\t\t\t\t\t\tconst recordToDelete = <T>(\n\t\t\t\t\t\t\t\tawait this.db\n\t\t\t\t\t\t\t\t\t.transaction(storeName, 'readwrite')\n\t\t\t\t\t\t\t\t\t.objectStore(storeName)\n\t\t\t\t\t\t\t\t\t.index(hasOneIndex)\n\t\t\t\t\t\t\t\t\t.get(this.canonicalKeyPath(values))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\t\t\t\tthis.schema.namespaces[nameSpace].relationships![modelName]\n\t\t\t\t\t\t\t\t\t.relationTypes,\n\t\t\t\t\t\t\t\trecordToDelete ? [recordToDelete] : [],\n\t\t\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t\t\tnameSpace,\n\t\t\t\t\t\t\t\tdeleteQueue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// PRE-CPK codegen\n\t\t\t\t\t\t\tlet index;\n\t\t\t\t\t\t\tlet values: string[];\n\n\t\t\t\t\t\t\tif (targetName && targetName in model) {\n\t\t\t\t\t\t\t\tindex = hasOneIndex;\n\t\t\t\t\t\t\t\tconst value = model[targetName];\n\t\t\t\t\t\t\t\tif (value === null) break;\n\t\t\t\t\t\t\t\tvalues = [value];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// backwards compatability for older versions of codegen that did not emit targetName for HAS_ONE relations\n\t\t\t\t\t\t\t\t// TODO: can we deprecate this? it's been ~2 years since codegen started including targetName for HAS_ONE\n\t\t\t\t\t\t\t\t// If we deprecate, we'll need to re-gen the MIPR in __tests__/schema.ts > newSchema\n\t\t\t\t\t\t\t\t// otherwise some unit tests will fail\n\t\t\t\t\t\t\t\tindex = getIndex(\n\t\t\t\t\t\t\t\t\tthis.schema.namespaces[nameSpace].relationships![modelName]\n\t\t\t\t\t\t\t\t\t\t.relationTypes,\n\t\t\t\t\t\t\t\t\tsrcModel\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tvalues = this.getIndexKeyValuesFromModel(model);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!values || !index) break;\n\n\t\t\t\t\t\t\tconst recordToDelete = <T>(\n\t\t\t\t\t\t\t\tawait this.db\n\t\t\t\t\t\t\t\t\t.transaction(storeName, 'readwrite')\n\t\t\t\t\t\t\t\t\t.objectStore(storeName)\n\t\t\t\t\t\t\t\t\t.index(index)\n\t\t\t\t\t\t\t\t\t.get(this.canonicalKeyPath(values))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\t\t\t\tthis.schema.namespaces[nameSpace].relationships![modelName]\n\t\t\t\t\t\t\t\t\t.relationTypes,\n\t\t\t\t\t\t\t\trecordToDelete ? [recordToDelete] : [],\n\t\t\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t\t\tnameSpace,\n\t\t\t\t\t\t\t\tdeleteQueue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'HAS_MANY':\n\t\t\t\t\tfor await (const model of models) {\n\t\t\t\t\t\tconst index =\n\t\t\t\t\t\t\t// explicit bi-directional @hasMany and @manyToMany\n\t\t\t\t\t\t\tgetIndex(\n\t\t\t\t\t\t\t\tthis.schema.namespaces[nameSpace].relationships![modelName]\n\t\t\t\t\t\t\t\t\t.relationTypes,\n\t\t\t\t\t\t\t\tsrcModel\n\t\t\t\t\t\t\t) ||\n\t\t\t\t\t\t\t// uni and/or implicit @hasMany\n\t\t\t\t\t\t\tgetIndexFromAssociation(\n\t\t\t\t\t\t\t\tthis.schema.namespaces[nameSpace].relationships![modelName]\n\t\t\t\t\t\t\t\t\t.indexes,\n\t\t\t\t\t\t\t\tassociatedWith!\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tconst keyValues = this.getIndexKeyValuesFromModel(model);\n\n\t\t\t\t\t\tconst childrenArray = await this.db\n\t\t\t\t\t\t\t.transaction(storeName, 'readwrite')\n\t\t\t\t\t\t\t.objectStore(storeName)\n\t\t\t\t\t\t\t.index(index as string)\n\t\t\t\t\t\t\t.getAll(this.canonicalKeyPath(keyValues));\n\n\t\t\t\t\t\tawait this.deleteTraverse(\n\t\t\t\t\t\t\tthis.schema.namespaces[nameSpace].relationships![modelName]\n\t\t\t\t\t\t\t\t.relationTypes,\n\t\t\t\t\t\t\tchildrenArray,\n\t\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t\tnameSpace,\n\t\t\t\t\t\t\tdeleteQueue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'BELONGS_TO':\n\t\t\t\t\t// Intentionally blank\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Invalid relation type ${relationType}`);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdeleteQueue.push({\n\t\t\tstoreName: getStorename(nameSpace, srcModel),\n\t\t\titems: models.map(record =>\n\t\t\t\tthis.modelInstanceCreator(\n\t\t\t\t\tthis.getModelConstructorByModelName!(nameSpace, srcModel),\n\t\t\t\t\trecord\n\t\t\t\t)\n\t\t\t),\n\t\t});\n\t}\n\n\tasync clear(): Promise<void> {\n\t\tawait this.checkPrivate();\n\n\t\tthis.db?.close();\n\n\t\tawait idb.deleteDB(this.dbName);\n\n\t\tthis.db = undefined!;\n\t\tthis.initPromise = undefined!;\n\t}\n\n\tasync batchSave<T extends PersistentModel>(\n\t\tmodelConstructor: PersistentModelConstructor<any>,\n\t\titems: ModelInstanceMetadata[]\n\t): Promise<[T, OpType][]> {\n\t\tif (items.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tawait this.checkPrivate();\n\n\t\tconst result: [T, OpType][] = [];\n\n\t\tconst storeName = this.getStorenameForModel(modelConstructor);\n\n\t\tconst txn = this.db.transaction(storeName, 'readwrite');\n\t\tconst store = txn.store;\n\n\t\tfor (const item of items) {\n\t\t\tconst namespaceName = this.namespaceResolver(modelConstructor);\n\t\t\tconst modelName = modelConstructor.name;\n\t\t\tconst model = this.modelInstanceCreator(modelConstructor, item);\n\n\t\t\tconst connectedModels = traverseModel(\n\t\t\t\tmodelName,\n\t\t\t\tmodel,\n\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\tthis.getModelConstructorByModelName!\n\t\t\t);\n\n\t\t\tconst keyValues = this.getIndexKeyValuesFromModel(model);\n\t\t\tconst { _deleted } = item;\n\n\t\t\tconst index = store.index('byPk');\n\n\t\t\tconst key = await index.getKey(this.canonicalKeyPath(keyValues));\n\n\t\t\tif (!_deleted) {\n\t\t\t\tconst { instance } = connectedModels.find(({ instance }) => {\n\t\t\t\t\tconst instanceKeyValues = this.getIndexKeyValuesFromModel(instance);\n\t\t\t\t\treturn keysEqual(instanceKeyValues, keyValues);\n\t\t\t\t})!;\n\n\t\t\t\tresult.push([\n\t\t\t\t\t<T>(<unknown>instance),\n\t\t\t\t\tkey ? OpType.UPDATE : OpType.INSERT,\n\t\t\t\t]);\n\t\t\t\tawait store.put(instance, key);\n\t\t\t} else {\n\t\t\t\tresult.push([<T>(<unknown>item), OpType.DELETE]);\n\n\t\t\t\tif (key) {\n\t\t\t\t\tawait store.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait txn.done;\n\n\t\treturn result;\n\t}\n\n\tprivate createObjectStoreForModel(\n\t\tdb: idb.IDBPDatabase,\n\t\tnamespaceName: string,\n\t\tstoreName: string,\n\t\tmodelName: string\n\t) {\n\t\tconst store = db.createObjectStore(storeName, {\n\t\t\tautoIncrement: true,\n\t\t});\n\n\t\tconst { indexes } =\n\t\t\tthis.schema.namespaces[namespaceName].relationships![modelName];\n\n\t\tindexes.forEach(([idxName, keyPath, options]) => {\n\t\t\tstore.createIndex(idxName, keyPath, options);\n\t\t});\n\n\t\treturn store;\n\t}\n\n\t/**\n\t * Checks the given path against the browser's IndexedDB implementation for\n\t * necessary compatibility transformations, applying those transforms if needed.\n\t *\n\t * @param `keyArr` strings to compatibilize for browser-indexeddb index operations\n\t * @returns An array or string, depending on and given key,\n\t * that is ensured to be compatible with the IndexedDB implementation's nuances.\n\t */\n\tprivate canonicalKeyPath = (keyArr: string[]) => {\n\t\tif (this.safariCompatabilityMode) {\n\t\t\treturn keyArr.length > 1 ? keyArr : keyArr[0];\n\t\t}\n\t\treturn keyArr;\n\t};\n}\n\nexport default new IndexedDBAdapter();\n"]},"metadata":{},"sourceType":"module"}